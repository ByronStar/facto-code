{
  "defines": {
    "type": "define",
    "properties": {
      "events": {
        "name": "events",
        "properties": {
          "on_tick": {
            "name": "defines.events.on_tick",
            "type": "define"
          },
          "on_gui_click": {
            "name": "defines.events.on_gui_click",
            "type": "define"
          },
          "on_gui_confirmed": {
            "name": "defines.events.on_gui_confirmed",
            "type": "define"
          },
          "on_gui_text_changed": {
            "name": "defines.events.on_gui_text_changed",
            "type": "define"
          },
          "on_gui_checked_state_changed": {
            "name": "defines.events.on_gui_checked_state_changed",
            "type": "define"
          },
          "on_entity_died": {
            "name": "defines.events.on_entity_died",
            "type": "define"
          },
          "on_post_entity_died": {
            "name": "defines.events.on_post_entity_died",
            "type": "define"
          },
          "on_entity_damaged": {
            "name": "defines.events.on_entity_damaged",
            "type": "define"
          },
          "on_picked_up_item": {
            "name": "defines.events.on_picked_up_item",
            "type": "define"
          },
          "on_built_entity": {
            "name": "defines.events.on_built_entity",
            "type": "define"
          },
          "on_sector_scanned": {
            "name": "defines.events.on_sector_scanned",
            "type": "define"
          },
          "on_player_mined_item": {
            "name": "defines.events.on_player_mined_item",
            "type": "define"
          },
          "on_pre_build": {
            "name": "defines.events.on_pre_build",
            "type": "define"
          },
          "on_rocket_launched": {
            "name": "defines.events.on_rocket_launched",
            "type": "define"
          },
          "on_pre_player_mined_item": {
            "name": "defines.events.on_pre_player_mined_item",
            "type": "define"
          },
          "on_chunk_generated": {
            "name": "defines.events.on_chunk_generated",
            "type": "define"
          },
          "on_player_crafted_item": {
            "name": "defines.events.on_player_crafted_item",
            "type": "define"
          },
          "on_robot_built_entity": {
            "name": "defines.events.on_robot_built_entity",
            "type": "define"
          },
          "on_robot_pre_mined": {
            "name": "defines.events.on_robot_pre_mined",
            "type": "define"
          },
          "on_robot_mined": {
            "name": "defines.events.on_robot_mined",
            "type": "define"
          },
          "on_research_started": {
            "name": "defines.events.on_research_started",
            "type": "define"
          },
          "on_research_finished": {
            "name": "defines.events.on_research_finished",
            "type": "define"
          },
          "on_research_reversed": {
            "name": "defines.events.on_research_reversed",
            "type": "define"
          },
          "on_research_cancelled": {
            "name": "defines.events.on_research_cancelled",
            "type": "define"
          },
          "on_player_rotated_entity": {
            "name": "defines.events.on_player_rotated_entity",
            "type": "define"
          },
          "on_marked_for_deconstruction": {
            "name": "defines.events.on_marked_for_deconstruction",
            "type": "define"
          },
          "on_cancelled_deconstruction": {
            "name": "defines.events.on_cancelled_deconstruction",
            "type": "define"
          },
          "on_trigger_created_entity": {
            "name": "defines.events.on_trigger_created_entity",
            "type": "define"
          },
          "on_trigger_fired_artillery": {
            "name": "defines.events.on_trigger_fired_artillery",
            "type": "define"
          },
          "on_train_changed_state": {
            "name": "defines.events.on_train_changed_state",
            "type": "define"
          },
          "on_player_created": {
            "name": "defines.events.on_player_created",
            "type": "define"
          },
          "on_resource_depleted": {
            "name": "defines.events.on_resource_depleted",
            "type": "define"
          },
          "on_player_driving_changed_state": {
            "name": "defines.events.on_player_driving_changed_state",
            "type": "define"
          },
          "on_force_created": {
            "name": "defines.events.on_force_created",
            "type": "define"
          },
          "on_forces_merging": {
            "name": "defines.events.on_forces_merging",
            "type": "define"
          },
          "on_player_cursor_stack_changed": {
            "name": "defines.events.on_player_cursor_stack_changed",
            "type": "define"
          },
          "on_pre_entity_settings_pasted": {
            "name": "defines.events.on_pre_entity_settings_pasted",
            "type": "define"
          },
          "on_entity_settings_pasted": {
            "name": "defines.events.on_entity_settings_pasted",
            "type": "define"
          },
          "on_player_main_inventory_changed": {
            "name": "defines.events.on_player_main_inventory_changed",
            "type": "define"
          },
          "on_player_armor_inventory_changed": {
            "name": "defines.events.on_player_armor_inventory_changed",
            "type": "define"
          },
          "on_player_ammo_inventory_changed": {
            "name": "defines.events.on_player_ammo_inventory_changed",
            "type": "define"
          },
          "on_player_gun_inventory_changed": {
            "name": "defines.events.on_player_gun_inventory_changed",
            "type": "define"
          },
          "on_player_placed_equipment": {
            "name": "defines.events.on_player_placed_equipment",
            "type": "define"
          },
          "on_player_removed_equipment": {
            "name": "defines.events.on_player_removed_equipment",
            "type": "define"
          },
          "on_pre_player_died": {
            "name": "defines.events.on_pre_player_died",
            "type": "define"
          },
          "on_player_died": {
            "name": "defines.events.on_player_died",
            "type": "define"
          },
          "on_player_respawned": {
            "name": "defines.events.on_player_respawned",
            "type": "define"
          },
          "on_player_joined_game": {
            "name": "defines.events.on_player_joined_game",
            "type": "define"
          },
          "on_player_left_game": {
            "name": "defines.events.on_player_left_game",
            "type": "define"
          },
          "on_player_built_tile": {
            "name": "defines.events.on_player_built_tile",
            "type": "define"
          },
          "on_player_mined_tile": {
            "name": "defines.events.on_player_mined_tile",
            "type": "define"
          },
          "on_robot_built_tile": {
            "name": "defines.events.on_robot_built_tile",
            "type": "define"
          },
          "on_robot_mined_tile": {
            "name": "defines.events.on_robot_mined_tile",
            "type": "define"
          },
          "on_player_selected_area": {
            "name": "defines.events.on_player_selected_area",
            "type": "define"
          },
          "on_player_alt_selected_area": {
            "name": "defines.events.on_player_alt_selected_area",
            "type": "define"
          },
          "on_player_changed_surface": {
            "name": "defines.events.on_player_changed_surface",
            "type": "define"
          },
          "on_selected_entity_changed": {
            "name": "defines.events.on_selected_entity_changed",
            "type": "define"
          },
          "on_market_item_purchased": {
            "name": "defines.events.on_market_item_purchased",
            "type": "define"
          },
          "on_player_dropped_item": {
            "name": "defines.events.on_player_dropped_item",
            "type": "define"
          },
          "on_biter_base_built": {
            "name": "defines.events.on_biter_base_built",
            "type": "define"
          },
          "on_player_changed_force": {
            "name": "defines.events.on_player_changed_force",
            "type": "define"
          },
          "on_entity_renamed": {
            "name": "defines.events.on_entity_renamed",
            "type": "define"
          },
          "on_gui_selection_state_changed": {
            "name": "defines.events.on_gui_selection_state_changed",
            "type": "define"
          },
          "on_runtime_mod_setting_changed": {
            "name": "defines.events.on_runtime_mod_setting_changed",
            "type": "define"
          },
          "on_difficulty_settings_changed": {
            "name": "defines.events.on_difficulty_settings_changed",
            "type": "define"
          },
          "on_surface_created": {
            "name": "defines.events.on_surface_created",
            "type": "define"
          },
          "on_surface_deleted": {
            "name": "defines.events.on_surface_deleted",
            "type": "define"
          },
          "on_pre_surface_deleted": {
            "name": "defines.events.on_pre_surface_deleted",
            "type": "define"
          },
          "on_player_mined_entity": {
            "name": "defines.events.on_player_mined_entity",
            "type": "define"
          },
          "on_robot_mined_entity": {
            "name": "defines.events.on_robot_mined_entity",
            "type": "define"
          },
          "on_train_created": {
            "name": "defines.events.on_train_created",
            "type": "define"
          },
          "on_gui_elem_changed": {
            "name": "defines.events.on_gui_elem_changed",
            "type": "define"
          },
          "on_player_setup_blueprint": {
            "name": "defines.events.on_player_setup_blueprint",
            "type": "define"
          },
          "on_player_deconstructed_area": {
            "name": "defines.events.on_player_deconstructed_area",
            "type": "define"
          },
          "on_player_configured_blueprint": {
            "name": "defines.events.on_player_configured_blueprint",
            "type": "define"
          },
          "on_console_chat": {
            "name": "defines.events.on_console_chat",
            "type": "define"
          },
          "on_console_command": {
            "name": "defines.events.on_console_command",
            "type": "define"
          },
          "on_player_removed": {
            "name": "defines.events.on_player_removed",
            "type": "define"
          },
          "on_pre_player_removed": {
            "name": "defines.events.on_pre_player_removed",
            "type": "define"
          },
          "on_player_used_capsule": {
            "name": "defines.events.on_player_used_capsule",
            "type": "define"
          },
          "script_raised_built": {
            "name": "defines.events.script_raised_built",
            "type": "define"
          },
          "script_raised_destroy": {
            "name": "defines.events.script_raised_destroy",
            "type": "define"
          },
          "script_raised_revive": {
            "name": "defines.events.script_raised_revive",
            "type": "define"
          },
          "script_raised_teleported": {
            "name": "defines.events.script_raised_teleported",
            "type": "define"
          },
          "script_raised_set_tiles": {
            "name": "defines.events.script_raised_set_tiles",
            "type": "define"
          },
          "on_player_promoted": {
            "name": "defines.events.on_player_promoted",
            "type": "define"
          },
          "on_player_demoted": {
            "name": "defines.events.on_player_demoted",
            "type": "define"
          },
          "on_combat_robot_expired": {
            "name": "defines.events.on_combat_robot_expired",
            "type": "define"
          },
          "on_worker_robot_expired": {
            "name": "defines.events.on_worker_robot_expired",
            "type": "define"
          },
          "on_player_changed_position": {
            "name": "defines.events.on_player_changed_position",
            "type": "define"
          },
          "on_mod_item_opened": {
            "name": "defines.events.on_mod_item_opened",
            "type": "define"
          },
          "on_gui_opened": {
            "name": "defines.events.on_gui_opened",
            "type": "define"
          },
          "on_gui_closed": {
            "name": "defines.events.on_gui_closed",
            "type": "define"
          },
          "on_gui_value_changed": {
            "name": "defines.events.on_gui_value_changed",
            "type": "define"
          },
          "on_player_muted": {
            "name": "defines.events.on_player_muted",
            "type": "define"
          },
          "on_player_unmuted": {
            "name": "defines.events.on_player_unmuted",
            "type": "define"
          },
          "on_player_cheat_mode_enabled": {
            "name": "defines.events.on_player_cheat_mode_enabled",
            "type": "define"
          },
          "on_player_cheat_mode_disabled": {
            "name": "defines.events.on_player_cheat_mode_disabled",
            "type": "define"
          },
          "on_character_corpse_expired": {
            "name": "defines.events.on_character_corpse_expired",
            "type": "define"
          },
          "on_pre_ghost_deconstructed": {
            "name": "defines.events.on_pre_ghost_deconstructed",
            "type": "define"
          },
          "on_pre_ghost_upgraded": {
            "name": "defines.events.on_pre_ghost_upgraded",
            "type": "define"
          },
          "on_player_pipette": {
            "name": "defines.events.on_player_pipette",
            "type": "define"
          },
          "on_player_display_resolution_changed": {
            "name": "defines.events.on_player_display_resolution_changed",
            "type": "define"
          },
          "on_player_display_scale_changed": {
            "name": "defines.events.on_player_display_scale_changed",
            "type": "define"
          },
          "on_pre_player_crafted_item": {
            "name": "defines.events.on_pre_player_crafted_item",
            "type": "define"
          },
          "on_player_cancelled_crafting": {
            "name": "defines.events.on_player_cancelled_crafting",
            "type": "define"
          },
          "on_chunk_charted": {
            "name": "defines.events.on_chunk_charted",
            "type": "define"
          },
          "on_technology_effects_reset": {
            "name": "defines.events.on_technology_effects_reset",
            "type": "define"
          },
          "on_force_reset": {
            "name": "defines.events.on_force_reset",
            "type": "define"
          },
          "on_land_mine_armed": {
            "name": "defines.events.on_land_mine_armed",
            "type": "define"
          },
          "on_forces_merged": {
            "name": "defines.events.on_forces_merged",
            "type": "define"
          },
          "on_player_trash_inventory_changed": {
            "name": "defines.events.on_player_trash_inventory_changed",
            "type": "define"
          },
          "on_pre_player_left_game": {
            "name": "defines.events.on_pre_player_left_game",
            "type": "define"
          },
          "on_pre_surface_cleared": {
            "name": "defines.events.on_pre_surface_cleared",
            "type": "define"
          },
          "on_surface_cleared": {
            "name": "defines.events.on_surface_cleared",
            "type": "define"
          },
          "on_chunk_deleted": {
            "name": "defines.events.on_chunk_deleted",
            "type": "define"
          },
          "on_pre_chunk_deleted": {
            "name": "defines.events.on_pre_chunk_deleted",
            "type": "define"
          },
          "on_train_schedule_changed": {
            "name": "defines.events.on_train_schedule_changed",
            "type": "define"
          },
          "on_player_banned": {
            "name": "defines.events.on_player_banned",
            "type": "define"
          },
          "on_player_kicked": {
            "name": "defines.events.on_player_kicked",
            "type": "define"
          },
          "on_player_unbanned": {
            "name": "defines.events.on_player_unbanned",
            "type": "define"
          },
          "on_rocket_launch_ordered": {
            "name": "defines.events.on_rocket_launch_ordered",
            "type": "define"
          },
          "on_script_path_request_finished": {
            "name": "defines.events.on_script_path_request_finished",
            "type": "define"
          },
          "on_ai_command_completed": {
            "name": "defines.events.on_ai_command_completed",
            "type": "define"
          },
          "on_marked_for_upgrade": {
            "name": "defines.events.on_marked_for_upgrade",
            "type": "define"
          },
          "on_cancelled_upgrade": {
            "name": "defines.events.on_cancelled_upgrade",
            "type": "define"
          },
          "on_player_toggled_map_editor": {
            "name": "defines.events.on_player_toggled_map_editor",
            "type": "define"
          },
          "on_entity_cloned": {
            "name": "defines.events.on_entity_cloned",
            "type": "define"
          },
          "on_area_cloned": {
            "name": "defines.events.on_area_cloned",
            "type": "define"
          },
          "on_brush_cloned": {
            "name": "defines.events.on_brush_cloned",
            "type": "define"
          },
          "on_game_created_from_scenario": {
            "name": "defines.events.on_game_created_from_scenario",
            "type": "define"
          },
          "on_surface_imported": {
            "name": "defines.events.on_surface_imported",
            "type": "define"
          },
          "on_surface_renamed": {
            "name": "defines.events.on_surface_renamed",
            "type": "define"
          },
          "on_player_toggled_alt_mode": {
            "name": "defines.events.on_player_toggled_alt_mode",
            "type": "define"
          },
          "on_player_repaired_entity": {
            "name": "defines.events.on_player_repaired_entity",
            "type": "define"
          },
          "on_player_fast_transferred": {
            "name": "defines.events.on_player_fast_transferred",
            "type": "define"
          },
          "on_pre_robot_exploded_cliff": {
            "name": "defines.events.on_pre_robot_exploded_cliff",
            "type": "define"
          },
          "on_robot_exploded_cliff": {
            "name": "defines.events.on_robot_exploded_cliff",
            "type": "define"
          },
          "on_entity_spawned": {
            "name": "defines.events.on_entity_spawned",
            "type": "define"
          },
          "on_cutscene_waypoint_reached": {
            "name": "defines.events.on_cutscene_waypoint_reached",
            "type": "define"
          },
          "on_unit_group_created": {
            "name": "defines.events.on_unit_group_created",
            "type": "define"
          },
          "on_unit_added_to_group": {
            "name": "defines.events.on_unit_added_to_group",
            "type": "define"
          },
          "on_unit_removed_from_group": {
            "name": "defines.events.on_unit_removed_from_group",
            "type": "define"
          },
          "on_unit_group_finished_gathering": {
            "name": "defines.events.on_unit_group_finished_gathering",
            "type": "define"
          },
          "on_build_base_arrived": {
            "name": "defines.events.on_build_base_arrived",
            "type": "define"
          },
          "on_chart_tag_added": {
            "name": "defines.events.on_chart_tag_added",
            "type": "define"
          },
          "on_chart_tag_modified": {
            "name": "defines.events.on_chart_tag_modified",
            "type": "define"
          },
          "on_chart_tag_removed": {
            "name": "defines.events.on_chart_tag_removed",
            "type": "define"
          },
          "on_lua_shortcut": {
            "name": "defines.events.on_lua_shortcut",
            "type": "define"
          },
          "on_gui_location_changed": {
            "name": "defines.events.on_gui_location_changed",
            "type": "define"
          },
          "on_gui_selected_tab_changed": {
            "name": "defines.events.on_gui_selected_tab_changed",
            "type": "define"
          },
          "on_gui_switch_state_changed": {
            "name": "defines.events.on_gui_switch_state_changed",
            "type": "define"
          },
          "on_force_cease_fire_changed": {
            "name": "defines.events.on_force_cease_fire_changed",
            "type": "define"
          },
          "on_force_friends_changed": {
            "name": "defines.events.on_force_friends_changed",
            "type": "define"
          },
          "on_string_translated": {
            "name": "defines.events.on_string_translated",
            "type": "define"
          },
          "on_script_trigger_effect": {
            "name": "defines.events.on_script_trigger_effect",
            "type": "define"
          },
          "on_player_set_quick_bar_slot": {
            "name": "defines.events.on_player_set_quick_bar_slot",
            "type": "define"
          },
          "on_pre_player_toggled_map_editor": {
            "name": "defines.events.on_pre_player_toggled_map_editor",
            "type": "define"
          },
          "on_pre_script_inventory_resized": {
            "name": "defines.events.on_pre_script_inventory_resized",
            "type": "define"
          },
          "on_script_inventory_resized": {
            "name": "defines.events.on_script_inventory_resized",
            "type": "define"
          },
          "on_entity_destroyed": {
            "name": "defines.events.on_entity_destroyed",
            "type": "define"
          },
          "on_player_clicked_gps_tag": {
            "name": "defines.events.on_player_clicked_gps_tag",
            "type": "define"
          },
          "on_player_flushed_fluid": {
            "name": "defines.events.on_player_flushed_fluid",
            "type": "define"
          },
          "on_permission_group_edited": {
            "name": "defines.events.on_permission_group_edited",
            "type": "define"
          },
          "on_pre_permission_string_imported": {
            "name": "defines.events.on_pre_permission_string_imported",
            "type": "define"
          },
          "on_permission_string_imported": {
            "name": "defines.events.on_permission_string_imported",
            "type": "define"
          },
          "on_pre_permission_group_deleted": {
            "name": "defines.events.on_pre_permission_group_deleted",
            "type": "define"
          },
          "on_permission_group_deleted": {
            "name": "defines.events.on_permission_group_deleted",
            "type": "define"
          },
          "on_permission_group_added": {
            "name": "defines.events.on_permission_group_added",
            "type": "define"
          },
          "on_cutscene_cancelled": {
            "name": "defines.events.on_cutscene_cancelled",
            "type": "define"
          },
          "on_player_configured_spider_remote": {
            "name": "defines.events.on_player_configured_spider_remote",
            "type": "define"
          },
          "on_player_used_spider_remote": {
            "name": "defines.events.on_player_used_spider_remote",
            "type": "define"
          },
          "on_spider_command_completed": {
            "name": "defines.events.on_spider_command_completed",
            "type": "define"
          },
          "on_entity_logistic_slot_changed": {
            "name": "defines.events.on_entity_logistic_slot_changed",
            "type": "define"
          },
          "on_equipment_inserted": {
            "name": "defines.events.on_equipment_inserted",
            "type": "define"
          },
          "on_equipment_removed": {
            "name": "defines.events.on_equipment_removed",
            "type": "define"
          },
          "on_player_reverse_selected_area": {
            "name": "defines.events.on_player_reverse_selected_area",
            "type": "define"
          },
          "on_player_alt_reverse_selected_area": {
            "name": "defines.events.on_player_alt_reverse_selected_area",
            "type": "define"
          },
          "on_gui_hover": {
            "name": "defines.events.on_gui_hover",
            "type": "define"
          },
          "on_gui_leave": {
            "name": "defines.events.on_gui_leave",
            "type": "define"
          },
          "on_entity_color_changed": {
            "name": "defines.events.on_entity_color_changed",
            "type": "define"
          },
          "on_cutscene_started": {
            "name": "defines.events.on_cutscene_started",
            "type": "define"
          },
          "on_cutscene_finished": {
            "name": "defines.events.on_cutscene_finished",
            "type": "define"
          },
          "on_player_input_method_changed": {
            "name": "defines.events.on_player_input_method_changed",
            "type": "define"
          }
        },
        "type": "define"
      },
      "alert_type": {
        "name": "alert_type",
        "properties": {
          "entity_destroyed": {
            "name": "defines.alert_type.entity_destroyed",
            "type": "define"
          },
          "entity_under_attack": {
            "name": "defines.alert_type.entity_under_attack",
            "type": "define"
          },
          "not_enough_construction_robots": {
            "name": "defines.alert_type.not_enough_construction_robots",
            "type": "define"
          },
          "no_material_for_construction": {
            "name": "defines.alert_type.no_material_for_construction",
            "type": "define"
          },
          "not_enough_repair_packs": {
            "name": "defines.alert_type.not_enough_repair_packs",
            "type": "define"
          },
          "turret_fire": {
            "name": "defines.alert_type.turret_fire",
            "type": "define"
          },
          "custom": {
            "name": "defines.alert_type.custom",
            "type": "define"
          },
          "no_storage": {
            "name": "defines.alert_type.no_storage",
            "type": "define"
          },
          "train_out_of_fuel": {
            "name": "defines.alert_type.train_out_of_fuel",
            "type": "define"
          }
        },
        "type": "define"
      },
      "behavior_result": {
        "name": "behavior_result",
        "properties": {
          "in_progress": {
            "name": "defines.behavior_result.in_progress",
            "type": "define"
          },
          "fail": {
            "name": "defines.behavior_result.fail",
            "type": "define"
          },
          "success": {
            "name": "defines.behavior_result.success",
            "type": "define"
          },
          "deleted": {
            "name": "defines.behavior_result.deleted",
            "type": "define"
          }
        },
        "type": "define"
      },
      "build_check_type": {
        "name": "build_check_type",
        "properties": {
          "script": {
            "name": "defines.build_check_type.script",
            "type": "define"
          },
          "manual": {
            "name": "defines.build_check_type.manual",
            "type": "define"
          },
          "manual_ghost": {
            "name": "defines.build_check_type.manual_ghost",
            "type": "define"
          },
          "script_ghost": {
            "name": "defines.build_check_type.script_ghost",
            "type": "define"
          },
          "blueprint_ghost": {
            "name": "defines.build_check_type.blueprint_ghost",
            "type": "define"
          },
          "ghost_revive": {
            "name": "defines.build_check_type.ghost_revive",
            "type": "define"
          }
        },
        "type": "define"
      },
      "chain_signal_state": {
        "name": "chain_signal_state",
        "properties": {
          "none": {
            "name": "defines.chain_signal_state.none",
            "type": "define"
          },
          "all_open": {
            "name": "defines.chain_signal_state.all_open",
            "type": "define"
          },
          "partially_open": {
            "name": "defines.chain_signal_state.partially_open",
            "type": "define"
          },
          "none_open": {
            "name": "defines.chain_signal_state.none_open",
            "type": "define"
          }
        },
        "type": "define"
      },
      "chunk_generated_status": {
        "name": "chunk_generated_status",
        "properties": {
          "nothing": {
            "name": "defines.chunk_generated_status.nothing",
            "type": "define"
          },
          "custom_tiles": {
            "name": "defines.chunk_generated_status.custom_tiles",
            "type": "define"
          },
          "basic_tiles": {
            "name": "defines.chunk_generated_status.basic_tiles",
            "type": "define"
          },
          "corrected_tiles": {
            "name": "defines.chunk_generated_status.corrected_tiles",
            "type": "define"
          },
          "tiles": {
            "name": "defines.chunk_generated_status.tiles",
            "type": "define"
          },
          "entities": {
            "name": "defines.chunk_generated_status.entities",
            "type": "define"
          }
        },
        "type": "define"
      },
      "circuit_condition_index": {
        "name": "circuit_condition_index",
        "properties": {
          "inserter_circuit": {
            "name": "defines.circuit_condition_index.inserter_circuit",
            "type": "define"
          },
          "inserter_logistic": {
            "name": "defines.circuit_condition_index.inserter_logistic",
            "type": "define"
          },
          "lamp": {
            "name": "defines.circuit_condition_index.lamp",
            "type": "define"
          },
          "arithmetic_combinator": {
            "name": "defines.circuit_condition_index.arithmetic_combinator",
            "type": "define"
          },
          "decider_combinator": {
            "name": "defines.circuit_condition_index.decider_combinator",
            "type": "define"
          },
          "constant_combinator": {
            "name": "defines.circuit_condition_index.constant_combinator",
            "type": "define"
          },
          "offshore_pump": {
            "name": "defines.circuit_condition_index.offshore_pump",
            "type": "define"
          },
          "pump": {
            "name": "defines.circuit_condition_index.pump",
            "type": "define"
          }
        },
        "type": "define"
      },
      "circuit_connector_id": {
        "name": "circuit_connector_id",
        "properties": {
          "accumulator": {
            "name": "defines.circuit_connector_id.accumulator",
            "type": "define"
          },
          "constant_combinator": {
            "name": "defines.circuit_connector_id.constant_combinator",
            "type": "define"
          },
          "container": {
            "name": "defines.circuit_connector_id.container",
            "type": "define"
          },
          "linked_container": {
            "name": "defines.circuit_connector_id.linked_container",
            "type": "define"
          },
          "programmable_speaker": {
            "name": "defines.circuit_connector_id.programmable_speaker",
            "type": "define"
          },
          "rail_signal": {
            "name": "defines.circuit_connector_id.rail_signal",
            "type": "define"
          },
          "rail_chain_signal": {
            "name": "defines.circuit_connector_id.rail_chain_signal",
            "type": "define"
          },
          "roboport": {
            "name": "defines.circuit_connector_id.roboport",
            "type": "define"
          },
          "storage_tank": {
            "name": "defines.circuit_connector_id.storage_tank",
            "type": "define"
          },
          "wall": {
            "name": "defines.circuit_connector_id.wall",
            "type": "define"
          },
          "electric_pole": {
            "name": "defines.circuit_connector_id.electric_pole",
            "type": "define"
          },
          "inserter": {
            "name": "defines.circuit_connector_id.inserter",
            "type": "define"
          },
          "lamp": {
            "name": "defines.circuit_connector_id.lamp",
            "type": "define"
          },
          "combinator_input": {
            "name": "defines.circuit_connector_id.combinator_input",
            "type": "define"
          },
          "combinator_output": {
            "name": "defines.circuit_connector_id.combinator_output",
            "type": "define"
          },
          "offshore_pump": {
            "name": "defines.circuit_connector_id.offshore_pump",
            "type": "define"
          },
          "pump": {
            "name": "defines.circuit_connector_id.pump",
            "type": "define"
          }
        },
        "type": "define"
      },
      "command": {
        "name": "command",
        "properties": {
          "attack": {
            "name": "defines.command.attack",
            "doc": "Attack another entity.",
            "type": "define"
          },
          "go_to_location": {
            "name": "defines.command.go_to_location",
            "doc": "Go to a specific position.",
            "type": "define"
          },
          "compound": {
            "name": "defines.command.compound",
            "doc": "Chain commands together, see defines.compound_command.",
            "type": "define"
          },
          "group": {
            "name": "defines.command.group",
            "doc": "Do what your group wants you to do.",
            "type": "define"
          },
          "attack_area": {
            "name": "defines.command.attack_area",
            "doc": "Go to a place and attack what you see.",
            "type": "define"
          },
          "wander": {
            "name": "defines.command.wander",
            "doc": "Chill.",
            "type": "define"
          },
          "flee": {
            "name": "defines.command.flee",
            "doc": "Flee from another entity.",
            "type": "define"
          },
          "stop": {
            "name": "defines.command.stop",
            "doc": "Stop moving and stay where you are.",
            "type": "define"
          },
          "build_base": {
            "name": "defines.command.build_base",
            "doc": "Go to a position and build a base there.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "compound_command": {
        "name": "compound_command",
        "properties": {
          "logical_and": {
            "name": "defines.compound_command.logical_and",
            "doc": "Fail on first failure. Only succeeds if all commands (executed one after another) succeed.",
            "type": "define"
          },
          "logical_or": {
            "name": "defines.compound_command.logical_or",
            "doc": "Succeed on first success. Only fails if all commands (executed one after another) fail.",
            "type": "define"
          },
          "return_last": {
            "name": "defines.compound_command.return_last",
            "doc": "Execute all commands in sequence and fail or succeed depending on the return status of the last command.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "control_behavior": {
        "name": "control_behavior",
        "properties": {
          "inserter.circuit_mode_of_operation.none": {
            "name": "defines.control_behavior.inserter.circuit_mode_of_operation.none",
            "type": "define"
          },
          "inserter.circuit_mode_of_operation.enable_disable": {
            "name": "defines.control_behavior.inserter.circuit_mode_of_operation.enable_disable",
            "type": "define"
          },
          "inserter.circuit_mode_of_operation.set_filters": {
            "name": "defines.control_behavior.inserter.circuit_mode_of_operation.set_filters",
            "type": "define"
          },
          "inserter.circuit_mode_of_operation.read_hand_contents": {
            "name": "defines.control_behavior.inserter.circuit_mode_of_operation.read_hand_contents",
            "type": "define"
          },
          "inserter.circuit_mode_of_operation.set_stack_size": {
            "name": "defines.control_behavior.inserter.circuit_mode_of_operation.set_stack_size",
            "type": "define"
          },
          "inserter.hand_read_mode.hold": {
            "name": "defines.control_behavior.inserter.hand_read_mode.hold",
            "type": "define"
          },
          "inserter.hand_read_mode.pulse": {
            "name": "defines.control_behavior.inserter.hand_read_mode.pulse",
            "type": "define"
          },
          "logistic_container.circuit_mode_of_operation.send_contents": {
            "name": "defines.control_behavior.logistic_container.circuit_mode_of_operation.send_contents",
            "type": "define"
          },
          "logistic_container.circuit_mode_of_operation.set_requests": {
            "name": "defines.control_behavior.logistic_container.circuit_mode_of_operation.set_requests",
            "type": "define"
          },
          "lamp.circuit_mode_of_operation.use_colors": {
            "name": "defines.control_behavior.lamp.circuit_mode_of_operation.use_colors",
            "type": "define"
          },
          "mining_drill.resource_read_mode.this_miner": {
            "name": "defines.control_behavior.mining_drill.resource_read_mode.this_miner",
            "type": "define"
          },
          "mining_drill.resource_read_mode.entire_patch": {
            "name": "defines.control_behavior.mining_drill.resource_read_mode.entire_patch",
            "type": "define"
          },
          "transport_belt.content_read_mode.pulse": {
            "name": "defines.control_behavior.transport_belt.content_read_mode.pulse",
            "type": "define"
          },
          "transport_belt.content_read_mode.hold": {
            "name": "defines.control_behavior.transport_belt.content_read_mode.hold",
            "type": "define"
          },
          "type.container": {
            "name": "defines.control_behavior.type.container",
            "doc": "LuaContainerControlBehavior",
            "type": "define"
          },
          "type.generic_on_off": {
            "name": "defines.control_behavior.type.generic_on_off",
            "doc": "LuaGenericOnOffControlBehavior",
            "type": "define"
          },
          "type.inserter": {
            "name": "defines.control_behavior.type.inserter",
            "doc": "LuaInserterControlBehavior",
            "type": "define"
          },
          "type.lamp": {
            "name": "defines.control_behavior.type.lamp",
            "doc": "LuaLampControlBehavior",
            "type": "define"
          },
          "type.logistic_container": {
            "name": "defines.control_behavior.type.logistic_container",
            "doc": "LuaLogisticContainerControlBehavior",
            "type": "define"
          },
          "type.roboport": {
            "name": "defines.control_behavior.type.roboport",
            "doc": "LuaRoboportControlBehavior",
            "type": "define"
          },
          "type.storage_tank": {
            "name": "defines.control_behavior.type.storage_tank",
            "doc": "LuaStorageTankControlBehavior",
            "type": "define"
          },
          "type.train_stop": {
            "name": "defines.control_behavior.type.train_stop",
            "doc": "LuaTrainStopControlBehavior",
            "type": "define"
          },
          "type.decider_combinator": {
            "name": "defines.control_behavior.type.decider_combinator",
            "doc": "LuaDeciderCombinatorControlBehavior",
            "type": "define"
          },
          "type.arithmetic_combinator": {
            "name": "defines.control_behavior.type.arithmetic_combinator",
            "doc": "LuaArithmeticCombinatorControlBehavior",
            "type": "define"
          },
          "type.constant_combinator": {
            "name": "defines.control_behavior.type.constant_combinator",
            "doc": "LuaConstantCombinatorControlBehavior",
            "type": "define"
          },
          "type.transport_belt": {
            "name": "defines.control_behavior.type.transport_belt",
            "doc": "LuaTransportBeltControlBehavior",
            "type": "define"
          },
          "type.accumulator": {
            "name": "defines.control_behavior.type.accumulator",
            "doc": "LuaAccumulatorControlBehavior",
            "type": "define"
          },
          "type.rail_signal": {
            "name": "defines.control_behavior.type.rail_signal",
            "doc": "LuaRailSignalControlBehavior",
            "type": "define"
          },
          "type.rail_chain_signal": {
            "name": "defines.control_behavior.type.rail_chain_signal",
            "doc": "LuaRailChainSignalControlBehavior",
            "type": "define"
          },
          "type.wall": {
            "name": "defines.control_behavior.type.wall",
            "doc": "LuaWallControlBehavior",
            "type": "define"
          },
          "type.mining_drill": {
            "name": "defines.control_behavior.type.mining_drill",
            "doc": "LuaMiningDrillControlBehavior",
            "type": "define"
          },
          "type.programmable_speaker": {
            "name": "defines.control_behavior.type.programmable_speaker",
            "doc": "LuaProgrammableSpeakerControlBehavior",
            "type": "define"
          }
        },
        "type": "define"
      },
      "controllers": {
        "name": "controllers",
        "properties": {
          "ghost": {
            "name": "defines.controllers.ghost",
            "doc": "Can't interact with the world, can only observe. Used in the multiplayer waiting-to-respawn screen.",
            "type": "define"
          },
          "character": {
            "name": "defines.controllers.character",
            "doc": "The controller controls a character. This is the default controller in freeplay.",
            "type": "define"
          },
          "god": {
            "name": "defines.controllers.god",
            "doc": "The controller isn't tied to a character. This is the default controller in sandbox.",
            "type": "define"
          },
          "editor": {
            "name": "defines.controllers.editor",
            "doc": "The Editor Controller near ultimate power to do almost anything in the game.",
            "type": "define"
          },
          "cutscene": {
            "name": "defines.controllers.cutscene",
            "doc": "The player can't interact with the world, and the camera pans around in a predefined manner.",
            "type": "define"
          },
          "spectator": {
            "name": "defines.controllers.spectator",
            "doc": "Can't change anything in the world but can view anything.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "deconstruction_item": {
        "name": "deconstruction_item",
        "properties": {
          "entity_filter_mode.whitelist": {
            "name": "defines.deconstruction_item.entity_filter_mode.whitelist",
            "type": "define"
          },
          "entity_filter_mode.blacklist": {
            "name": "defines.deconstruction_item.entity_filter_mode.blacklist",
            "type": "define"
          },
          "tile_filter_mode.whitelist": {
            "name": "defines.deconstruction_item.tile_filter_mode.whitelist",
            "type": "define"
          },
          "tile_filter_mode.blacklist": {
            "name": "defines.deconstruction_item.tile_filter_mode.blacklist",
            "type": "define"
          },
          "tile_selection_mode.normal": {
            "name": "defines.deconstruction_item.tile_selection_mode.normal",
            "type": "define"
          },
          "tile_selection_mode.always": {
            "name": "defines.deconstruction_item.tile_selection_mode.always",
            "type": "define"
          },
          "tile_selection_mode.never": {
            "name": "defines.deconstruction_item.tile_selection_mode.never",
            "type": "define"
          },
          "tile_selection_mode.only": {
            "name": "defines.deconstruction_item.tile_selection_mode.only",
            "type": "define"
          }
        },
        "type": "define"
      },
      "difficulty": {
        "name": "difficulty",
        "properties": {
          "easy": {
            "name": "defines.difficulty.easy",
            "type": "define"
          },
          "normal": {
            "name": "defines.difficulty.normal",
            "type": "define"
          },
          "hard": {
            "name": "defines.difficulty.hard",
            "type": "define"
          }
        },
        "type": "define"
      },
      "difficulty_settings": {
        "name": "difficulty_settings",
        "properties": {
          "recipe_difficulty.normal": {
            "name": "defines.difficulty_settings.recipe_difficulty.normal",
            "type": "define"
          },
          "recipe_difficulty.expensive": {
            "name": "defines.difficulty_settings.recipe_difficulty.expensive",
            "type": "define"
          },
          "technology_difficulty.normal": {
            "name": "defines.difficulty_settings.technology_difficulty.normal",
            "type": "define"
          },
          "technology_difficulty.expensive": {
            "name": "defines.difficulty_settings.technology_difficulty.expensive",
            "type": "define"
          }
        },
        "type": "define"
      },
      "direction": {
        "name": "direction",
        "properties": {
          "north": {
            "name": "defines.direction.north",
            "type": "define"
          },
          "northeast": {
            "name": "defines.direction.northeast",
            "type": "define"
          },
          "east": {
            "name": "defines.direction.east",
            "type": "define"
          },
          "southeast": {
            "name": "defines.direction.southeast",
            "type": "define"
          },
          "south": {
            "name": "defines.direction.south",
            "type": "define"
          },
          "southwest": {
            "name": "defines.direction.southwest",
            "type": "define"
          },
          "west": {
            "name": "defines.direction.west",
            "type": "define"
          },
          "northwest": {
            "name": "defines.direction.northwest",
            "type": "define"
          }
        },
        "type": "define"
      },
      "disconnect_reason": {
        "name": "disconnect_reason",
        "properties": {
          "quit": {
            "name": "defines.disconnect_reason.quit",
            "type": "define"
          },
          "dropped": {
            "name": "defines.disconnect_reason.dropped",
            "type": "define"
          },
          "reconnect": {
            "name": "defines.disconnect_reason.reconnect",
            "type": "define"
          },
          "wrong_input": {
            "name": "defines.disconnect_reason.wrong_input",
            "type": "define"
          },
          "desync_limit_reached": {
            "name": "defines.disconnect_reason.desync_limit_reached",
            "type": "define"
          },
          "cannot_keep_up": {
            "name": "defines.disconnect_reason.cannot_keep_up",
            "type": "define"
          },
          "afk": {
            "name": "defines.disconnect_reason.afk",
            "type": "define"
          },
          "kicked": {
            "name": "defines.disconnect_reason.kicked",
            "type": "define"
          },
          "kicked_and_deleted": {
            "name": "defines.disconnect_reason.kicked_and_deleted",
            "type": "define"
          },
          "banned": {
            "name": "defines.disconnect_reason.banned",
            "type": "define"
          },
          "switching_servers": {
            "name": "defines.disconnect_reason.switching_servers",
            "type": "define"
          }
        },
        "type": "define"
      },
      "distraction": {
        "name": "distraction",
        "properties": {
          "none": {
            "name": "defines.distraction.none",
            "doc": "Perform command even if someone attacks the unit.",
            "type": "define"
          },
          "by_enemy": {
            "name": "defines.distraction.by_enemy",
            "doc": "Attack closer enemy entities with force.",
            "type": "define"
          },
          "by_anything": {
            "name": "defines.distraction.by_anything",
            "doc": "Attack closer enemy entities, including entities \"built\" by player (belts, inserters, chests).",
            "type": "define"
          },
          "by_damage": {
            "name": "defines.distraction.by_damage",
            "doc": "Attack when attacked.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "entity_status": {
        "name": "entity_status",
        "properties": {
          "working": {
            "name": "defines.entity_status.working",
            "type": "define"
          },
          "normal": {
            "name": "defines.entity_status.normal",
            "type": "define"
          },
          "no_power": {
            "name": "defines.entity_status.no_power",
            "type": "define"
          },
          "low_power": {
            "name": "defines.entity_status.low_power",
            "type": "define"
          },
          "no_fuel": {
            "name": "defines.entity_status.no_fuel",
            "type": "define"
          },
          "disabled_by_control_behavior": {
            "name": "defines.entity_status.disabled_by_control_behavior",
            "type": "define"
          },
          "opened_by_circuit_network": {
            "name": "defines.entity_status.opened_by_circuit_network",
            "type": "define"
          },
          "closed_by_circuit_network": {
            "name": "defines.entity_status.closed_by_circuit_network",
            "type": "define"
          },
          "disabled_by_script": {
            "name": "defines.entity_status.disabled_by_script",
            "type": "define"
          },
          "marked_for_deconstruction": {
            "name": "defines.entity_status.marked_for_deconstruction",
            "type": "define"
          },
          "not_plugged_in_electric_network": {
            "name": "defines.entity_status.not_plugged_in_electric_network",
            "doc": "Used by generators and solar panels.",
            "type": "define"
          },
          "networks_connected": {
            "name": "defines.entity_status.networks_connected",
            "doc": "Used by power switches.",
            "type": "define"
          },
          "networks_disconnected": {
            "name": "defines.entity_status.networks_disconnected",
            "doc": "Used by power switches.",
            "type": "define"
          },
          "charging": {
            "name": "defines.entity_status.charging",
            "doc": "Used by accumulators.",
            "type": "define"
          },
          "discharging": {
            "name": "defines.entity_status.discharging",
            "doc": "Used by accumulators.",
            "type": "define"
          },
          "fully_charged": {
            "name": "defines.entity_status.fully_charged",
            "doc": "Used by accumulators.",
            "type": "define"
          },
          "out_of_logistic_network": {
            "name": "defines.entity_status.out_of_logistic_network",
            "doc": "Used by logistic containers.",
            "type": "define"
          },
          "no_recipe": {
            "name": "defines.entity_status.no_recipe",
            "doc": "Used by assembling machines.",
            "type": "define"
          },
          "no_ingredients": {
            "name": "defines.entity_status.no_ingredients",
            "doc": "Used by furnaces.",
            "type": "define"
          },
          "no_input_fluid": {
            "name": "defines.entity_status.no_input_fluid",
            "doc": "Used by boilers, fluid turrets and fluid energy sources: Boiler has no fluid to work with.",
            "type": "define"
          },
          "no_research_in_progress": {
            "name": "defines.entity_status.no_research_in_progress",
            "doc": "Used by labs.",
            "type": "define"
          },
          "no_minable_resources": {
            "name": "defines.entity_status.no_minable_resources",
            "doc": "Used by mining drills.",
            "type": "define"
          },
          "low_input_fluid": {
            "name": "defines.entity_status.low_input_fluid",
            "doc": "Used by boilers and fluid turrets: Boiler still has some fluid but is about to run out.",
            "type": "define"
          },
          "fluid_ingredient_shortage": {
            "name": "defines.entity_status.fluid_ingredient_shortage",
            "doc": "Used by crafting machines.",
            "type": "define"
          },
          "full_output": {
            "name": "defines.entity_status.full_output",
            "doc": "Used by crafting machines, boilers, burner energy sources and reactors: Reactor/burner has full burnt result inventory, boiler has full output fluidbox.",
            "type": "define"
          },
          "full_burnt_result_output": {
            "name": "defines.entity_status.full_burnt_result_output",
            "doc": "Used by burner energy sources.",
            "type": "define"
          },
          "item_ingredient_shortage": {
            "name": "defines.entity_status.item_ingredient_shortage",
            "doc": "Used by crafting machines.",
            "type": "define"
          },
          "missing_required_fluid": {
            "name": "defines.entity_status.missing_required_fluid",
            "doc": "Used by mining drills when the mining fluid is missing.",
            "type": "define"
          },
          "missing_science_packs": {
            "name": "defines.entity_status.missing_science_packs",
            "doc": "Used by labs.",
            "type": "define"
          },
          "waiting_for_source_items": {
            "name": "defines.entity_status.waiting_for_source_items",
            "doc": "Used by inserters.",
            "type": "define"
          },
          "waiting_for_space_in_destination": {
            "name": "defines.entity_status.waiting_for_space_in_destination",
            "doc": "Used by inserters and mining drills.",
            "type": "define"
          },
          "preparing_rocket_for_launch": {
            "name": "defines.entity_status.preparing_rocket_for_launch",
            "doc": "Used by the rocket silo.",
            "type": "define"
          },
          "waiting_to_launch_rocket": {
            "name": "defines.entity_status.waiting_to_launch_rocket",
            "doc": "Used by the rocket silo.",
            "type": "define"
          },
          "launching_rocket": {
            "name": "defines.entity_status.launching_rocket",
            "doc": "Used by the rocket silo.",
            "type": "define"
          },
          "no_modules_to_transmit": {
            "name": "defines.entity_status.no_modules_to_transmit",
            "doc": "Used by beacons.",
            "type": "define"
          },
          "recharging_after_power_outage": {
            "name": "defines.entity_status.recharging_after_power_outage",
            "doc": "Used by roboports.",
            "type": "define"
          },
          "waiting_for_target_to_be_built": {
            "name": "defines.entity_status.waiting_for_target_to_be_built",
            "doc": "Used by inserters targeting entity ghosts.",
            "type": "define"
          },
          "waiting_for_train": {
            "name": "defines.entity_status.waiting_for_train",
            "doc": "Used by inserters targeting rails.",
            "type": "define"
          },
          "no_ammo": {
            "name": "defines.entity_status.no_ammo",
            "doc": "Used by ammo turrets.",
            "type": "define"
          },
          "low_temperature": {
            "name": "defines.entity_status.low_temperature",
            "doc": "Used by heat energy sources.",
            "type": "define"
          },
          "disabled": {
            "name": "defines.entity_status.disabled",
            "doc": "Used by constant combinators: Combinator is turned off via switch in GUI.",
            "type": "define"
          },
          "turned_off_during_daytime": {
            "name": "defines.entity_status.turned_off_during_daytime",
            "doc": "Used by lamps.",
            "type": "define"
          },
          "not_connected_to_rail": {
            "name": "defines.entity_status.not_connected_to_rail",
            "doc": "Used by rail signals.",
            "type": "define"
          },
          "cant_divide_segments": {
            "name": "defines.entity_status.cant_divide_segments",
            "doc": "Used by rail signals.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "flow_precision_index": {
        "name": "flow_precision_index",
        "properties": {
          "five_seconds": {
            "name": "defines.flow_precision_index.five_seconds",
            "type": "define"
          },
          "one_minute": {
            "name": "defines.flow_precision_index.one_minute",
            "type": "define"
          },
          "ten_minutes": {
            "name": "defines.flow_precision_index.ten_minutes",
            "type": "define"
          },
          "one_hour": {
            "name": "defines.flow_precision_index.one_hour",
            "type": "define"
          },
          "ten_hours": {
            "name": "defines.flow_precision_index.ten_hours",
            "type": "define"
          },
          "fifty_hours": {
            "name": "defines.flow_precision_index.fifty_hours",
            "type": "define"
          },
          "two_hundred_fifty_hours": {
            "name": "defines.flow_precision_index.two_hundred_fifty_hours",
            "type": "define"
          },
          "one_thousand_hours": {
            "name": "defines.flow_precision_index.one_thousand_hours",
            "type": "define"
          }
        },
        "type": "define"
      },
      "game_controller_interaction": {
        "name": "game_controller_interaction",
        "properties": {
          "always": {
            "name": "defines.game_controller_interaction.always",
            "doc": "Game controller will always hover this element regardless of type or state.",
            "type": "define"
          },
          "never": {
            "name": "defines.game_controller_interaction.never",
            "doc": "Never hover this element with a game controller.",
            "type": "define"
          },
          "normal": {
            "name": "defines.game_controller_interaction.normal",
            "doc": "Hover according to the element type and implementation.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "group_state": {
        "name": "group_state",
        "properties": {
          "gathering": {
            "name": "defines.group_state.gathering",
            "type": "define"
          },
          "moving": {
            "name": "defines.group_state.moving",
            "type": "define"
          },
          "attacking_distraction": {
            "name": "defines.group_state.attacking_distraction",
            "type": "define"
          },
          "attacking_target": {
            "name": "defines.group_state.attacking_target",
            "type": "define"
          },
          "finished": {
            "name": "defines.group_state.finished",
            "type": "define"
          },
          "pathfinding": {
            "name": "defines.group_state.pathfinding",
            "type": "define"
          },
          "wander_in_group": {
            "name": "defines.group_state.wander_in_group",
            "type": "define"
          }
        },
        "type": "define"
      },
      "gui_type": {
        "name": "gui_type",
        "properties": {
          "none": {
            "name": "defines.gui_type.none",
            "type": "define"
          },
          "entity": {
            "name": "defines.gui_type.entity",
            "type": "define"
          },
          "research": {
            "name": "defines.gui_type.research",
            "type": "define"
          },
          "controller": {
            "name": "defines.gui_type.controller",
            "type": "define"
          },
          "production": {
            "name": "defines.gui_type.production",
            "type": "define"
          },
          "item": {
            "name": "defines.gui_type.item",
            "type": "define"
          },
          "bonus": {
            "name": "defines.gui_type.bonus",
            "type": "define"
          },
          "trains": {
            "name": "defines.gui_type.trains",
            "type": "define"
          },
          "achievement": {
            "name": "defines.gui_type.achievement",
            "type": "define"
          },
          "blueprint_library": {
            "name": "defines.gui_type.blueprint_library",
            "type": "define"
          },
          "equipment": {
            "name": "defines.gui_type.equipment",
            "type": "define"
          },
          "logistic": {
            "name": "defines.gui_type.logistic",
            "type": "define"
          },
          "other_player": {
            "name": "defines.gui_type.other_player",
            "type": "define"
          },
          "permissions": {
            "name": "defines.gui_type.permissions",
            "type": "define"
          },
          "tutorials": {
            "name": "defines.gui_type.tutorials",
            "type": "define"
          },
          "custom": {
            "name": "defines.gui_type.custom",
            "type": "define"
          },
          "server_management": {
            "name": "defines.gui_type.server_management",
            "type": "define"
          },
          "player_management": {
            "name": "defines.gui_type.player_management",
            "type": "define"
          },
          "tile": {
            "name": "defines.gui_type.tile",
            "type": "define"
          },
          "script_inventory": {
            "name": "defines.gui_type.script_inventory",
            "type": "define"
          }
        },
        "type": "define"
      },
      "input_action": {
        "name": "input_action",
        "properties": {
          "activate_copy": {
            "name": "defines.input_action.activate_copy",
            "type": "define"
          },
          "activate_cut": {
            "name": "defines.input_action.activate_cut",
            "type": "define"
          },
          "activate_paste": {
            "name": "defines.input_action.activate_paste",
            "type": "define"
          },
          "add_permission_group": {
            "name": "defines.input_action.add_permission_group",
            "type": "define"
          },
          "add_train_station": {
            "name": "defines.input_action.add_train_station",
            "type": "define"
          },
          "admin_action": {
            "name": "defines.input_action.admin_action",
            "type": "define"
          },
          "alt_reverse_select_area": {
            "name": "defines.input_action.alt_reverse_select_area",
            "type": "define"
          },
          "alt_select_area": {
            "name": "defines.input_action.alt_select_area",
            "type": "define"
          },
          "alt_select_blueprint_entities": {
            "name": "defines.input_action.alt_select_blueprint_entities",
            "type": "define"
          },
          "alternative_copy": {
            "name": "defines.input_action.alternative_copy",
            "type": "define"
          },
          "begin_mining": {
            "name": "defines.input_action.begin_mining",
            "type": "define"
          },
          "begin_mining_terrain": {
            "name": "defines.input_action.begin_mining_terrain",
            "type": "define"
          },
          "build": {
            "name": "defines.input_action.build",
            "type": "define"
          },
          "build_rail": {
            "name": "defines.input_action.build_rail",
            "type": "define"
          },
          "build_terrain": {
            "name": "defines.input_action.build_terrain",
            "type": "define"
          },
          "cancel_craft": {
            "name": "defines.input_action.cancel_craft",
            "type": "define"
          },
          "cancel_deconstruct": {
            "name": "defines.input_action.cancel_deconstruct",
            "type": "define"
          },
          "cancel_new_blueprint": {
            "name": "defines.input_action.cancel_new_blueprint",
            "type": "define"
          },
          "cancel_research": {
            "name": "defines.input_action.cancel_research",
            "type": "define"
          },
          "cancel_upgrade": {
            "name": "defines.input_action.cancel_upgrade",
            "type": "define"
          },
          "change_active_character_tab": {
            "name": "defines.input_action.change_active_character_tab",
            "type": "define"
          },
          "change_active_item_group_for_crafting": {
            "name": "defines.input_action.change_active_item_group_for_crafting",
            "type": "define"
          },
          "change_active_item_group_for_filters": {
            "name": "defines.input_action.change_active_item_group_for_filters",
            "type": "define"
          },
          "change_active_quick_bar": {
            "name": "defines.input_action.change_active_quick_bar",
            "type": "define"
          },
          "change_arithmetic_combinator_parameters": {
            "name": "defines.input_action.change_arithmetic_combinator_parameters",
            "type": "define"
          },
          "change_decider_combinator_parameters": {
            "name": "defines.input_action.change_decider_combinator_parameters",
            "type": "define"
          },
          "change_entity_label": {
            "name": "defines.input_action.change_entity_label",
            "type": "define"
          },
          "change_item_description": {
            "name": "defines.input_action.change_item_description",
            "type": "define"
          },
          "change_item_label": {
            "name": "defines.input_action.change_item_label",
            "type": "define"
          },
          "change_multiplayer_config": {
            "name": "defines.input_action.change_multiplayer_config",
            "type": "define"
          },
          "change_picking_state": {
            "name": "defines.input_action.change_picking_state",
            "type": "define"
          },
          "change_programmable_speaker_alert_parameters": {
            "name": "defines.input_action.change_programmable_speaker_alert_parameters",
            "type": "define"
          },
          "change_programmable_speaker_circuit_parameters": {
            "name": "defines.input_action.change_programmable_speaker_circuit_parameters",
            "type": "define"
          },
          "change_programmable_speaker_parameters": {
            "name": "defines.input_action.change_programmable_speaker_parameters",
            "type": "define"
          },
          "change_riding_state": {
            "name": "defines.input_action.change_riding_state",
            "type": "define"
          },
          "change_shooting_state": {
            "name": "defines.input_action.change_shooting_state",
            "type": "define"
          },
          "change_train_stop_station": {
            "name": "defines.input_action.change_train_stop_station",
            "type": "define"
          },
          "change_train_wait_condition": {
            "name": "defines.input_action.change_train_wait_condition",
            "type": "define"
          },
          "change_train_wait_condition_data": {
            "name": "defines.input_action.change_train_wait_condition_data",
            "type": "define"
          },
          "clear_cursor": {
            "name": "defines.input_action.clear_cursor",
            "type": "define"
          },
          "connect_rolling_stock": {
            "name": "defines.input_action.connect_rolling_stock",
            "type": "define"
          },
          "copy": {
            "name": "defines.input_action.copy",
            "type": "define"
          },
          "copy_entity_settings": {
            "name": "defines.input_action.copy_entity_settings",
            "type": "define"
          },
          "copy_opened_blueprint": {
            "name": "defines.input_action.copy_opened_blueprint",
            "type": "define"
          },
          "copy_opened_item": {
            "name": "defines.input_action.copy_opened_item",
            "type": "define"
          },
          "craft": {
            "name": "defines.input_action.craft",
            "type": "define"
          },
          "cursor_split": {
            "name": "defines.input_action.cursor_split",
            "type": "define"
          },
          "cursor_transfer": {
            "name": "defines.input_action.cursor_transfer",
            "type": "define"
          },
          "custom_input": {
            "name": "defines.input_action.custom_input",
            "type": "define"
          },
          "cycle_blueprint_book_backwards": {
            "name": "defines.input_action.cycle_blueprint_book_backwards",
            "type": "define"
          },
          "cycle_blueprint_book_forwards": {
            "name": "defines.input_action.cycle_blueprint_book_forwards",
            "type": "define"
          },
          "deconstruct": {
            "name": "defines.input_action.deconstruct",
            "type": "define"
          },
          "delete_blueprint_library": {
            "name": "defines.input_action.delete_blueprint_library",
            "type": "define"
          },
          "delete_blueprint_record": {
            "name": "defines.input_action.delete_blueprint_record",
            "type": "define"
          },
          "delete_custom_tag": {
            "name": "defines.input_action.delete_custom_tag",
            "type": "define"
          },
          "delete_permission_group": {
            "name": "defines.input_action.delete_permission_group",
            "type": "define"
          },
          "destroy_item": {
            "name": "defines.input_action.destroy_item",
            "type": "define"
          },
          "destroy_opened_item": {
            "name": "defines.input_action.destroy_opened_item",
            "type": "define"
          },
          "disconnect_rolling_stock": {
            "name": "defines.input_action.disconnect_rolling_stock",
            "type": "define"
          },
          "drag_train_schedule": {
            "name": "defines.input_action.drag_train_schedule",
            "type": "define"
          },
          "drag_train_wait_condition": {
            "name": "defines.input_action.drag_train_wait_condition",
            "type": "define"
          },
          "drop_blueprint_record": {
            "name": "defines.input_action.drop_blueprint_record",
            "type": "define"
          },
          "drop_item": {
            "name": "defines.input_action.drop_item",
            "type": "define"
          },
          "edit_blueprint_tool_preview": {
            "name": "defines.input_action.edit_blueprint_tool_preview",
            "type": "define"
          },
          "edit_custom_tag": {
            "name": "defines.input_action.edit_custom_tag",
            "type": "define"
          },
          "edit_permission_group": {
            "name": "defines.input_action.edit_permission_group",
            "type": "define"
          },
          "export_blueprint": {
            "name": "defines.input_action.export_blueprint",
            "type": "define"
          },
          "fast_entity_split": {
            "name": "defines.input_action.fast_entity_split",
            "type": "define"
          },
          "fast_entity_transfer": {
            "name": "defines.input_action.fast_entity_transfer",
            "type": "define"
          },
          "flush_opened_entity_fluid": {
            "name": "defines.input_action.flush_opened_entity_fluid",
            "type": "define"
          },
          "flush_opened_entity_specific_fluid": {
            "name": "defines.input_action.flush_opened_entity_specific_fluid",
            "type": "define"
          },
          "go_to_train_station": {
            "name": "defines.input_action.go_to_train_station",
            "type": "define"
          },
          "grab_blueprint_record": {
            "name": "defines.input_action.grab_blueprint_record",
            "type": "define"
          },
          "gui_checked_state_changed": {
            "name": "defines.input_action.gui_checked_state_changed",
            "type": "define"
          },
          "gui_click": {
            "name": "defines.input_action.gui_click",
            "type": "define"
          },
          "gui_confirmed": {
            "name": "defines.input_action.gui_confirmed",
            "type": "define"
          },
          "gui_elem_changed": {
            "name": "defines.input_action.gui_elem_changed",
            "type": "define"
          },
          "gui_hover": {
            "name": "defines.input_action.gui_hover",
            "type": "define"
          },
          "gui_leave": {
            "name": "defines.input_action.gui_leave",
            "type": "define"
          },
          "gui_location_changed": {
            "name": "defines.input_action.gui_location_changed",
            "type": "define"
          },
          "gui_selected_tab_changed": {
            "name": "defines.input_action.gui_selected_tab_changed",
            "type": "define"
          },
          "gui_selection_state_changed": {
            "name": "defines.input_action.gui_selection_state_changed",
            "type": "define"
          },
          "gui_switch_state_changed": {
            "name": "defines.input_action.gui_switch_state_changed",
            "type": "define"
          },
          "gui_text_changed": {
            "name": "defines.input_action.gui_text_changed",
            "type": "define"
          },
          "gui_value_changed": {
            "name": "defines.input_action.gui_value_changed",
            "type": "define"
          },
          "import_blueprint": {
            "name": "defines.input_action.import_blueprint",
            "type": "define"
          },
          "import_blueprint_string": {
            "name": "defines.input_action.import_blueprint_string",
            "type": "define"
          },
          "import_blueprints_filtered": {
            "name": "defines.input_action.import_blueprints_filtered",
            "type": "define"
          },
          "import_permissions_string": {
            "name": "defines.input_action.import_permissions_string",
            "type": "define"
          },
          "inventory_split": {
            "name": "defines.input_action.inventory_split",
            "type": "define"
          },
          "inventory_transfer": {
            "name": "defines.input_action.inventory_transfer",
            "type": "define"
          },
          "launch_rocket": {
            "name": "defines.input_action.launch_rocket",
            "type": "define"
          },
          "lua_shortcut": {
            "name": "defines.input_action.lua_shortcut",
            "type": "define"
          },
          "map_editor_action": {
            "name": "defines.input_action.map_editor_action",
            "type": "define"
          },
          "market_offer": {
            "name": "defines.input_action.market_offer",
            "type": "define"
          },
          "mod_settings_changed": {
            "name": "defines.input_action.mod_settings_changed",
            "type": "define"
          },
          "open_achievements_gui": {
            "name": "defines.input_action.open_achievements_gui",
            "type": "define"
          },
          "open_blueprint_library_gui": {
            "name": "defines.input_action.open_blueprint_library_gui",
            "type": "define"
          },
          "open_blueprint_record": {
            "name": "defines.input_action.open_blueprint_record",
            "type": "define"
          },
          "open_bonus_gui": {
            "name": "defines.input_action.open_bonus_gui",
            "type": "define"
          },
          "open_character_gui": {
            "name": "defines.input_action.open_character_gui",
            "type": "define"
          },
          "open_current_vehicle_gui": {
            "name": "defines.input_action.open_current_vehicle_gui",
            "type": "define"
          },
          "open_equipment": {
            "name": "defines.input_action.open_equipment",
            "type": "define"
          },
          "open_gui": {
            "name": "defines.input_action.open_gui",
            "type": "define"
          },
          "open_item": {
            "name": "defines.input_action.open_item",
            "type": "define"
          },
          "open_logistic_gui": {
            "name": "defines.input_action.open_logistic_gui",
            "type": "define"
          },
          "open_mod_item": {
            "name": "defines.input_action.open_mod_item",
            "type": "define"
          },
          "open_parent_of_opened_item": {
            "name": "defines.input_action.open_parent_of_opened_item",
            "type": "define"
          },
          "open_production_gui": {
            "name": "defines.input_action.open_production_gui",
            "type": "define"
          },
          "open_technology_gui": {
            "name": "defines.input_action.open_technology_gui",
            "type": "define"
          },
          "open_tips_and_tricks_gui": {
            "name": "defines.input_action.open_tips_and_tricks_gui",
            "type": "define"
          },
          "open_train_gui": {
            "name": "defines.input_action.open_train_gui",
            "type": "define"
          },
          "open_train_station_gui": {
            "name": "defines.input_action.open_train_station_gui",
            "type": "define"
          },
          "open_trains_gui": {
            "name": "defines.input_action.open_trains_gui",
            "type": "define"
          },
          "paste_entity_settings": {
            "name": "defines.input_action.paste_entity_settings",
            "type": "define"
          },
          "place_equipment": {
            "name": "defines.input_action.place_equipment",
            "type": "define"
          },
          "quick_bar_pick_slot": {
            "name": "defines.input_action.quick_bar_pick_slot",
            "type": "define"
          },
          "quick_bar_set_selected_page": {
            "name": "defines.input_action.quick_bar_set_selected_page",
            "type": "define"
          },
          "quick_bar_set_slot": {
            "name": "defines.input_action.quick_bar_set_slot",
            "type": "define"
          },
          "reassign_blueprint": {
            "name": "defines.input_action.reassign_blueprint",
            "type": "define"
          },
          "remove_cables": {
            "name": "defines.input_action.remove_cables",
            "type": "define"
          },
          "remove_train_station": {
            "name": "defines.input_action.remove_train_station",
            "type": "define"
          },
          "reset_assembling_machine": {
            "name": "defines.input_action.reset_assembling_machine",
            "type": "define"
          },
          "reset_item": {
            "name": "defines.input_action.reset_item",
            "type": "define"
          },
          "reverse_select_area": {
            "name": "defines.input_action.reverse_select_area",
            "type": "define"
          },
          "rotate_entity": {
            "name": "defines.input_action.rotate_entity",
            "type": "define"
          },
          "select_area": {
            "name": "defines.input_action.select_area",
            "type": "define"
          },
          "select_blueprint_entities": {
            "name": "defines.input_action.select_blueprint_entities",
            "type": "define"
          },
          "select_entity_slot": {
            "name": "defines.input_action.select_entity_slot",
            "type": "define"
          },
          "select_item": {
            "name": "defines.input_action.select_item",
            "type": "define"
          },
          "select_mapper_slot": {
            "name": "defines.input_action.select_mapper_slot",
            "type": "define"
          },
          "select_next_valid_gun": {
            "name": "defines.input_action.select_next_valid_gun",
            "type": "define"
          },
          "select_tile_slot": {
            "name": "defines.input_action.select_tile_slot",
            "type": "define"
          },
          "send_spidertron": {
            "name": "defines.input_action.send_spidertron",
            "type": "define"
          },
          "set_auto_launch_rocket": {
            "name": "defines.input_action.set_auto_launch_rocket",
            "type": "define"
          },
          "set_autosort_inventory": {
            "name": "defines.input_action.set_autosort_inventory",
            "type": "define"
          },
          "set_behavior_mode": {
            "name": "defines.input_action.set_behavior_mode",
            "type": "define"
          },
          "set_car_weapons_control": {
            "name": "defines.input_action.set_car_weapons_control",
            "type": "define"
          },
          "set_circuit_condition": {
            "name": "defines.input_action.set_circuit_condition",
            "type": "define"
          },
          "set_circuit_mode_of_operation": {
            "name": "defines.input_action.set_circuit_mode_of_operation",
            "type": "define"
          },
          "set_controller_logistic_trash_filter_item": {
            "name": "defines.input_action.set_controller_logistic_trash_filter_item",
            "type": "define"
          },
          "set_deconstruction_item_tile_selection_mode": {
            "name": "defines.input_action.set_deconstruction_item_tile_selection_mode",
            "type": "define"
          },
          "set_deconstruction_item_trees_and_rocks_only": {
            "name": "defines.input_action.set_deconstruction_item_trees_and_rocks_only",
            "type": "define"
          },
          "set_entity_color": {
            "name": "defines.input_action.set_entity_color",
            "type": "define"
          },
          "set_entity_energy_property": {
            "name": "defines.input_action.set_entity_energy_property",
            "type": "define"
          },
          "set_entity_logistic_trash_filter_item": {
            "name": "defines.input_action.set_entity_logistic_trash_filter_item",
            "type": "define"
          },
          "set_filter": {
            "name": "defines.input_action.set_filter",
            "type": "define"
          },
          "set_flat_controller_gui": {
            "name": "defines.input_action.set_flat_controller_gui",
            "type": "define"
          },
          "set_heat_interface_mode": {
            "name": "defines.input_action.set_heat_interface_mode",
            "type": "define"
          },
          "set_heat_interface_temperature": {
            "name": "defines.input_action.set_heat_interface_temperature",
            "type": "define"
          },
          "set_infinity_container_filter_item": {
            "name": "defines.input_action.set_infinity_container_filter_item",
            "type": "define"
          },
          "set_infinity_container_remove_unfiltered_items": {
            "name": "defines.input_action.set_infinity_container_remove_unfiltered_items",
            "type": "define"
          },
          "set_infinity_pipe_filter": {
            "name": "defines.input_action.set_infinity_pipe_filter",
            "type": "define"
          },
          "set_inserter_max_stack_size": {
            "name": "defines.input_action.set_inserter_max_stack_size",
            "type": "define"
          },
          "set_inventory_bar": {
            "name": "defines.input_action.set_inventory_bar",
            "type": "define"
          },
          "set_linked_container_link_i_d": {
            "name": "defines.input_action.set_linked_container_link_i_d",
            "type": "define"
          },
          "set_logistic_filter_item": {
            "name": "defines.input_action.set_logistic_filter_item",
            "type": "define"
          },
          "set_logistic_filter_signal": {
            "name": "defines.input_action.set_logistic_filter_signal",
            "type": "define"
          },
          "set_player_color": {
            "name": "defines.input_action.set_player_color",
            "type": "define"
          },
          "set_recipe_notifications": {
            "name": "defines.input_action.set_recipe_notifications",
            "type": "define"
          },
          "set_request_from_buffers": {
            "name": "defines.input_action.set_request_from_buffers",
            "type": "define"
          },
          "set_research_finished_stops_game": {
            "name": "defines.input_action.set_research_finished_stops_game",
            "type": "define"
          },
          "set_signal": {
            "name": "defines.input_action.set_signal",
            "type": "define"
          },
          "set_splitter_priority": {
            "name": "defines.input_action.set_splitter_priority",
            "type": "define"
          },
          "set_train_stopped": {
            "name": "defines.input_action.set_train_stopped",
            "type": "define"
          },
          "set_trains_limit": {
            "name": "defines.input_action.set_trains_limit",
            "type": "define"
          },
          "set_vehicle_automatic_targeting_parameters": {
            "name": "defines.input_action.set_vehicle_automatic_targeting_parameters",
            "type": "define"
          },
          "setup_assembling_machine": {
            "name": "defines.input_action.setup_assembling_machine",
            "type": "define"
          },
          "setup_blueprint": {
            "name": "defines.input_action.setup_blueprint",
            "type": "define"
          },
          "setup_single_blueprint_record": {
            "name": "defines.input_action.setup_single_blueprint_record",
            "type": "define"
          },
          "smart_pipette": {
            "name": "defines.input_action.smart_pipette",
            "type": "define"
          },
          "spawn_item": {
            "name": "defines.input_action.spawn_item",
            "type": "define"
          },
          "stack_split": {
            "name": "defines.input_action.stack_split",
            "type": "define"
          },
          "stack_transfer": {
            "name": "defines.input_action.stack_transfer",
            "type": "define"
          },
          "start_repair": {
            "name": "defines.input_action.start_repair",
            "type": "define"
          },
          "start_research": {
            "name": "defines.input_action.start_research",
            "type": "define"
          },
          "start_walking": {
            "name": "defines.input_action.start_walking",
            "type": "define"
          },
          "stop_building_by_moving": {
            "name": "defines.input_action.stop_building_by_moving",
            "type": "define"
          },
          "switch_connect_to_logistic_network": {
            "name": "defines.input_action.switch_connect_to_logistic_network",
            "type": "define"
          },
          "switch_constant_combinator_state": {
            "name": "defines.input_action.switch_constant_combinator_state",
            "type": "define"
          },
          "switch_inserter_filter_mode_state": {
            "name": "defines.input_action.switch_inserter_filter_mode_state",
            "type": "define"
          },
          "switch_power_switch_state": {
            "name": "defines.input_action.switch_power_switch_state",
            "type": "define"
          },
          "switch_to_rename_stop_gui": {
            "name": "defines.input_action.switch_to_rename_stop_gui",
            "type": "define"
          },
          "take_equipment": {
            "name": "defines.input_action.take_equipment",
            "type": "define"
          },
          "toggle_deconstruction_item_entity_filter_mode": {
            "name": "defines.input_action.toggle_deconstruction_item_entity_filter_mode",
            "type": "define"
          },
          "toggle_deconstruction_item_tile_filter_mode": {
            "name": "defines.input_action.toggle_deconstruction_item_tile_filter_mode",
            "type": "define"
          },
          "toggle_driving": {
            "name": "defines.input_action.toggle_driving",
            "type": "define"
          },
          "toggle_enable_vehicle_logistics_while_moving": {
            "name": "defines.input_action.toggle_enable_vehicle_logistics_while_moving",
            "type": "define"
          },
          "toggle_entity_logistic_requests": {
            "name": "defines.input_action.toggle_entity_logistic_requests",
            "type": "define"
          },
          "toggle_equipment_movement_bonus": {
            "name": "defines.input_action.toggle_equipment_movement_bonus",
            "type": "define"
          },
          "toggle_map_editor": {
            "name": "defines.input_action.toggle_map_editor",
            "type": "define"
          },
          "toggle_personal_logistic_requests": {
            "name": "defines.input_action.toggle_personal_logistic_requests",
            "type": "define"
          },
          "toggle_personal_roboport": {
            "name": "defines.input_action.toggle_personal_roboport",
            "type": "define"
          },
          "toggle_show_entity_info": {
            "name": "defines.input_action.toggle_show_entity_info",
            "type": "define"
          },
          "translate_string": {
            "name": "defines.input_action.translate_string",
            "type": "define"
          },
          "undo": {
            "name": "defines.input_action.undo",
            "type": "define"
          },
          "upgrade": {
            "name": "defines.input_action.upgrade",
            "type": "define"
          },
          "upgrade_opened_blueprint_by_item": {
            "name": "defines.input_action.upgrade_opened_blueprint_by_item",
            "type": "define"
          },
          "upgrade_opened_blueprint_by_record": {
            "name": "defines.input_action.upgrade_opened_blueprint_by_record",
            "type": "define"
          },
          "use_artillery_remote": {
            "name": "defines.input_action.use_artillery_remote",
            "type": "define"
          },
          "use_item": {
            "name": "defines.input_action.use_item",
            "type": "define"
          },
          "wire_dragging": {
            "name": "defines.input_action.wire_dragging",
            "type": "define"
          },
          "write_to_console": {
            "name": "defines.input_action.write_to_console",
            "type": "define"
          }
        },
        "type": "define"
      },
      "input_method": {
        "name": "input_method",
        "properties": {
          "keyboard_and_mouse": {
            "name": "defines.input_method.keyboard_and_mouse",
            "type": "define"
          },
          "game_controller": {
            "name": "defines.input_method.game_controller",
            "type": "define"
          }
        },
        "type": "define"
      },
      "inventory": {
        "name": "inventory",
        "properties": {
          "fuel": {
            "name": "defines.inventory.fuel",
            "type": "define"
          },
          "burnt_result": {
            "name": "defines.inventory.burnt_result",
            "type": "define"
          },
          "chest": {
            "name": "defines.inventory.chest",
            "type": "define"
          },
          "furnace_source": {
            "name": "defines.inventory.furnace_source",
            "type": "define"
          },
          "furnace_result": {
            "name": "defines.inventory.furnace_result",
            "type": "define"
          },
          "furnace_modules": {
            "name": "defines.inventory.furnace_modules",
            "type": "define"
          },
          "character_main": {
            "name": "defines.inventory.character_main",
            "type": "define"
          },
          "character_guns": {
            "name": "defines.inventory.character_guns",
            "type": "define"
          },
          "character_ammo": {
            "name": "defines.inventory.character_ammo",
            "type": "define"
          },
          "character_armor": {
            "name": "defines.inventory.character_armor",
            "type": "define"
          },
          "character_vehicle": {
            "name": "defines.inventory.character_vehicle",
            "type": "define"
          },
          "character_trash": {
            "name": "defines.inventory.character_trash",
            "type": "define"
          },
          "god_main": {
            "name": "defines.inventory.god_main",
            "type": "define"
          },
          "editor_main": {
            "name": "defines.inventory.editor_main",
            "type": "define"
          },
          "editor_guns": {
            "name": "defines.inventory.editor_guns",
            "type": "define"
          },
          "editor_ammo": {
            "name": "defines.inventory.editor_ammo",
            "type": "define"
          },
          "editor_armor": {
            "name": "defines.inventory.editor_armor",
            "type": "define"
          },
          "roboport_robot": {
            "name": "defines.inventory.roboport_robot",
            "type": "define"
          },
          "roboport_material": {
            "name": "defines.inventory.roboport_material",
            "type": "define"
          },
          "robot_cargo": {
            "name": "defines.inventory.robot_cargo",
            "type": "define"
          },
          "robot_repair": {
            "name": "defines.inventory.robot_repair",
            "type": "define"
          },
          "assembling_machine_input": {
            "name": "defines.inventory.assembling_machine_input",
            "type": "define"
          },
          "assembling_machine_output": {
            "name": "defines.inventory.assembling_machine_output",
            "type": "define"
          },
          "assembling_machine_modules": {
            "name": "defines.inventory.assembling_machine_modules",
            "type": "define"
          },
          "lab_input": {
            "name": "defines.inventory.lab_input",
            "type": "define"
          },
          "lab_modules": {
            "name": "defines.inventory.lab_modules",
            "type": "define"
          },
          "mining_drill_modules": {
            "name": "defines.inventory.mining_drill_modules",
            "type": "define"
          },
          "item_main": {
            "name": "defines.inventory.item_main",
            "type": "define"
          },
          "rocket_silo_rocket": {
            "name": "defines.inventory.rocket_silo_rocket",
            "type": "define"
          },
          "rocket_silo_result": {
            "name": "defines.inventory.rocket_silo_result",
            "type": "define"
          },
          "rocket_silo_input": {
            "name": "defines.inventory.rocket_silo_input",
            "type": "define"
          },
          "rocket_silo_output": {
            "name": "defines.inventory.rocket_silo_output",
            "type": "define"
          },
          "rocket_silo_modules": {
            "name": "defines.inventory.rocket_silo_modules",
            "type": "define"
          },
          "rocket": {
            "name": "defines.inventory.rocket",
            "type": "define"
          },
          "car_trunk": {
            "name": "defines.inventory.car_trunk",
            "type": "define"
          },
          "car_ammo": {
            "name": "defines.inventory.car_ammo",
            "type": "define"
          },
          "cargo_wagon": {
            "name": "defines.inventory.cargo_wagon",
            "type": "define"
          },
          "turret_ammo": {
            "name": "defines.inventory.turret_ammo",
            "type": "define"
          },
          "beacon_modules": {
            "name": "defines.inventory.beacon_modules",
            "type": "define"
          },
          "character_corpse": {
            "name": "defines.inventory.character_corpse",
            "type": "define"
          },
          "artillery_turret_ammo": {
            "name": "defines.inventory.artillery_turret_ammo",
            "type": "define"
          },
          "artillery_wagon_ammo": {
            "name": "defines.inventory.artillery_wagon_ammo",
            "type": "define"
          },
          "spider_trunk": {
            "name": "defines.inventory.spider_trunk",
            "type": "define"
          },
          "spider_ammo": {
            "name": "defines.inventory.spider_ammo",
            "type": "define"
          },
          "spider_trash": {
            "name": "defines.inventory.spider_trash",
            "type": "define"
          }
        },
        "type": "define"
      },
      "logistic_member_index": {
        "name": "logistic_member_index",
        "properties": {
          "logistic_container": {
            "name": "defines.logistic_member_index.logistic_container",
            "type": "define"
          },
          "vehicle_storage": {
            "name": "defines.logistic_member_index.vehicle_storage",
            "type": "define"
          },
          "character_requester": {
            "name": "defines.logistic_member_index.character_requester",
            "type": "define"
          },
          "character_storage": {
            "name": "defines.logistic_member_index.character_storage",
            "type": "define"
          },
          "character_provider": {
            "name": "defines.logistic_member_index.character_provider",
            "type": "define"
          },
          "generic_on_off_behavior": {
            "name": "defines.logistic_member_index.generic_on_off_behavior",
            "type": "define"
          }
        },
        "type": "define"
      },
      "logistic_mode": {
        "name": "logistic_mode",
        "properties": {
          "none": {
            "name": "defines.logistic_mode.none",
            "type": "define"
          },
          "active_provider": {
            "name": "defines.logistic_mode.active_provider",
            "type": "define"
          },
          "storage": {
            "name": "defines.logistic_mode.storage",
            "type": "define"
          },
          "requester": {
            "name": "defines.logistic_mode.requester",
            "type": "define"
          },
          "passive_provider": {
            "name": "defines.logistic_mode.passive_provider",
            "type": "define"
          },
          "buffer": {
            "name": "defines.logistic_mode.buffer",
            "type": "define"
          }
        },
        "type": "define"
      },
      "mouse_button_type": {
        "name": "mouse_button_type",
        "properties": {
          "none": {
            "name": "defines.mouse_button_type.none",
            "type": "define"
          },
          "left": {
            "name": "defines.mouse_button_type.left",
            "type": "define"
          },
          "right": {
            "name": "defines.mouse_button_type.right",
            "type": "define"
          },
          "middle": {
            "name": "defines.mouse_button_type.middle",
            "type": "define"
          }
        },
        "type": "define"
      },
      "print_skip": {
        "name": "print_skip",
        "properties": {
          "never": {
            "name": "defines.print_skip.never",
            "doc": "Print will not be skipped.",
            "type": "define"
          },
          "if_redundant": {
            "name": "defines.print_skip.if_redundant",
            "doc": "Print will be skipped if same text was recently printed (within last 60 ticks). Used by most game messages.",
            "type": "define"
          },
          "if_visible": {
            "name": "defines.print_skip.if_visible",
            "doc": "Print will be skipped if same text is still visible (printed within last 1152 ticks). Used by some notifications.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "print_sound": {
        "name": "print_sound",
        "properties": {
          "always": {
            "name": "defines.print_sound.always",
            "type": "define"
          },
          "never": {
            "name": "defines.print_sound.never",
            "type": "define"
          },
          "use_player_settings": {
            "name": "defines.print_sound.use_player_settings",
            "type": "define"
          }
        },
        "type": "define"
      },
      "prototypes": {
        "name": "prototypes",
        "properties": {
          "undefined": "prototypesA dictionary mapping all top-level prototypes by name to a list of their associated subtypes. This list is organized as a lookup table, meaning it maps the sub-prototype names to 0. As an example, defines.prototypes['entity'] looks like this: {furnace=0, inserter=0, container=0, ...}."
        },
        "type": "define"
      },
      "rail_connection_direction": {
        "name": "rail_connection_direction",
        "properties": {
          "left": {
            "name": "defines.rail_connection_direction.left",
            "type": "define"
          },
          "straight": {
            "name": "defines.rail_connection_direction.straight",
            "type": "define"
          },
          "right": {
            "name": "defines.rail_connection_direction.right",
            "type": "define"
          },
          "none": {
            "name": "defines.rail_connection_direction.none",
            "type": "define"
          }
        },
        "type": "define"
      },
      "rail_direction": {
        "name": "rail_direction",
        "properties": {
          "front": {
            "name": "defines.rail_direction.front",
            "type": "define"
          },
          "back": {
            "name": "defines.rail_direction.back",
            "type": "define"
          }
        },
        "type": "define"
      },
      "relative_gui_position": {
        "name": "relative_gui_position",
        "properties": {
          "top": {
            "name": "defines.relative_gui_position.top",
            "type": "define"
          },
          "bottom": {
            "name": "defines.relative_gui_position.bottom",
            "type": "define"
          },
          "left": {
            "name": "defines.relative_gui_position.left",
            "type": "define"
          },
          "right": {
            "name": "defines.relative_gui_position.right",
            "type": "define"
          }
        },
        "type": "define"
      },
      "relative_gui_type": {
        "name": "relative_gui_type",
        "properties": {
          "accumulator_gui": {
            "name": "defines.relative_gui_type.accumulator_gui",
            "type": "define"
          },
          "achievement_gui": {
            "name": "defines.relative_gui_type.achievement_gui",
            "type": "define"
          },
          "additional_entity_info_gui": {
            "name": "defines.relative_gui_type.additional_entity_info_gui",
            "type": "define"
          },
          "admin_gui": {
            "name": "defines.relative_gui_type.admin_gui",
            "type": "define"
          },
          "arithmetic_combinator_gui": {
            "name": "defines.relative_gui_type.arithmetic_combinator_gui",
            "type": "define"
          },
          "armor_gui": {
            "name": "defines.relative_gui_type.armor_gui",
            "type": "define"
          },
          "assembling_machine_gui": {
            "name": "defines.relative_gui_type.assembling_machine_gui",
            "type": "define"
          },
          "assembling_machine_select_recipe_gui": {
            "name": "defines.relative_gui_type.assembling_machine_select_recipe_gui",
            "type": "define"
          },
          "beacon_gui": {
            "name": "defines.relative_gui_type.beacon_gui",
            "type": "define"
          },
          "blueprint_book_gui": {
            "name": "defines.relative_gui_type.blueprint_book_gui",
            "type": "define"
          },
          "blueprint_library_gui": {
            "name": "defines.relative_gui_type.blueprint_library_gui",
            "type": "define"
          },
          "blueprint_setup_gui": {
            "name": "defines.relative_gui_type.blueprint_setup_gui",
            "type": "define"
          },
          "bonus_gui": {
            "name": "defines.relative_gui_type.bonus_gui",
            "type": "define"
          },
          "burner_equipment_gui": {
            "name": "defines.relative_gui_type.burner_equipment_gui",
            "type": "define"
          },
          "car_gui": {
            "name": "defines.relative_gui_type.car_gui",
            "type": "define"
          },
          "constant_combinator_gui": {
            "name": "defines.relative_gui_type.constant_combinator_gui",
            "type": "define"
          },
          "container_gui": {
            "name": "defines.relative_gui_type.container_gui",
            "type": "define"
          },
          "controller_gui": {
            "name": "defines.relative_gui_type.controller_gui",
            "type": "define"
          },
          "decider_combinator_gui": {
            "name": "defines.relative_gui_type.decider_combinator_gui",
            "type": "define"
          },
          "deconstruction_item_gui": {
            "name": "defines.relative_gui_type.deconstruction_item_gui",
            "type": "define"
          },
          "electric_energy_interface_gui": {
            "name": "defines.relative_gui_type.electric_energy_interface_gui",
            "type": "define"
          },
          "electric_network_gui": {
            "name": "defines.relative_gui_type.electric_network_gui",
            "type": "define"
          },
          "entity_variations_gui": {
            "name": "defines.relative_gui_type.entity_variations_gui",
            "type": "define"
          },
          "entity_with_energy_source_gui": {
            "name": "defines.relative_gui_type.entity_with_energy_source_gui",
            "type": "define"
          },
          "equipment_grid_gui": {
            "name": "defines.relative_gui_type.equipment_grid_gui",
            "type": "define"
          },
          "furnace_gui": {
            "name": "defines.relative_gui_type.furnace_gui",
            "type": "define"
          },
          "generic_on_off_entity_gui": {
            "name": "defines.relative_gui_type.generic_on_off_entity_gui",
            "type": "define"
          },
          "heat_interface_gui": {
            "name": "defines.relative_gui_type.heat_interface_gui",
            "type": "define"
          },
          "infinity_pipe_gui": {
            "name": "defines.relative_gui_type.infinity_pipe_gui",
            "type": "define"
          },
          "inserter_gui": {
            "name": "defines.relative_gui_type.inserter_gui",
            "type": "define"
          },
          "item_with_inventory_gui": {
            "name": "defines.relative_gui_type.item_with_inventory_gui",
            "type": "define"
          },
          "lab_gui": {
            "name": "defines.relative_gui_type.lab_gui",
            "type": "define"
          },
          "lamp_gui": {
            "name": "defines.relative_gui_type.lamp_gui",
            "type": "define"
          },
          "linked_container_gui": {
            "name": "defines.relative_gui_type.linked_container_gui",
            "type": "define"
          },
          "loader_gui": {
            "name": "defines.relative_gui_type.loader_gui",
            "type": "define"
          },
          "logistic_gui": {
            "name": "defines.relative_gui_type.logistic_gui",
            "type": "define"
          },
          "market_gui": {
            "name": "defines.relative_gui_type.market_gui",
            "type": "define"
          },
          "mining_drill_gui": {
            "name": "defines.relative_gui_type.mining_drill_gui",
            "type": "define"
          },
          "other_player_gui": {
            "name": "defines.relative_gui_type.other_player_gui",
            "type": "define"
          },
          "permissions_gui": {
            "name": "defines.relative_gui_type.permissions_gui",
            "type": "define"
          },
          "pipe_gui": {
            "name": "defines.relative_gui_type.pipe_gui",
            "type": "define"
          },
          "power_switch_gui": {
            "name": "defines.relative_gui_type.power_switch_gui",
            "type": "define"
          },
          "production_gui": {
            "name": "defines.relative_gui_type.production_gui",
            "type": "define"
          },
          "programmable_speaker_gui": {
            "name": "defines.relative_gui_type.programmable_speaker_gui",
            "type": "define"
          },
          "rail_chain_signal_gui": {
            "name": "defines.relative_gui_type.rail_chain_signal_gui",
            "type": "define"
          },
          "rail_signal_gui": {
            "name": "defines.relative_gui_type.rail_signal_gui",
            "type": "define"
          },
          "reactor_gui": {
            "name": "defines.relative_gui_type.reactor_gui",
            "type": "define"
          },
          "rename_stop_gui": {
            "name": "defines.relative_gui_type.rename_stop_gui",
            "type": "define"
          },
          "resource_entity_gui": {
            "name": "defines.relative_gui_type.resource_entity_gui",
            "type": "define"
          },
          "roboport_gui": {
            "name": "defines.relative_gui_type.roboport_gui",
            "type": "define"
          },
          "rocket_silo_gui": {
            "name": "defines.relative_gui_type.rocket_silo_gui",
            "type": "define"
          },
          "script_inventory_gui": {
            "name": "defines.relative_gui_type.script_inventory_gui",
            "type": "define"
          },
          "server_config_gui": {
            "name": "defines.relative_gui_type.server_config_gui",
            "type": "define"
          },
          "spider_vehicle_gui": {
            "name": "defines.relative_gui_type.spider_vehicle_gui",
            "type": "define"
          },
          "splitter_gui": {
            "name": "defines.relative_gui_type.splitter_gui",
            "type": "define"
          },
          "standalone_character_gui": {
            "name": "defines.relative_gui_type.standalone_character_gui",
            "type": "define"
          },
          "storage_tank_gui": {
            "name": "defines.relative_gui_type.storage_tank_gui",
            "type": "define"
          },
          "tile_variations_gui": {
            "name": "defines.relative_gui_type.tile_variations_gui",
            "type": "define"
          },
          "train_gui": {
            "name": "defines.relative_gui_type.train_gui",
            "type": "define"
          },
          "train_stop_gui": {
            "name": "defines.relative_gui_type.train_stop_gui",
            "type": "define"
          },
          "trains_gui": {
            "name": "defines.relative_gui_type.trains_gui",
            "type": "define"
          },
          "transport_belt_gui": {
            "name": "defines.relative_gui_type.transport_belt_gui",
            "type": "define"
          },
          "upgrade_item_gui": {
            "name": "defines.relative_gui_type.upgrade_item_gui",
            "type": "define"
          },
          "wall_gui": {
            "name": "defines.relative_gui_type.wall_gui",
            "type": "define"
          }
        },
        "type": "define"
      },
      "render_mode": {
        "name": "render_mode",
        "properties": {
          "game": {
            "name": "defines.render_mode.game",
            "type": "define"
          },
          "chart": {
            "name": "defines.render_mode.chart",
            "type": "define"
          },
          "chart_zoomed_in": {
            "name": "defines.render_mode.chart_zoomed_in",
            "type": "define"
          }
        },
        "type": "define"
      },
      "rich_text_setting": {
        "name": "rich_text_setting",
        "properties": {
          "enabled": {
            "name": "defines.rich_text_setting.enabled",
            "type": "define"
          },
          "disabled": {
            "name": "defines.rich_text_setting.disabled",
            "type": "define"
          },
          "highlight": {
            "name": "defines.rich_text_setting.highlight",
            "type": "define"
          }
        },
        "type": "define"
      },
      "riding": {
        "name": "riding",
        "properties": {
          "acceleration.nothing": {
            "name": "defines.riding.acceleration.nothing",
            "type": "define"
          },
          "acceleration.accelerating": {
            "name": "defines.riding.acceleration.accelerating",
            "type": "define"
          },
          "acceleration.braking": {
            "name": "defines.riding.acceleration.braking",
            "type": "define"
          },
          "acceleration.reversing": {
            "name": "defines.riding.acceleration.reversing",
            "type": "define"
          },
          "direction.left": {
            "name": "defines.riding.direction.left",
            "type": "define"
          },
          "direction.straight": {
            "name": "defines.riding.direction.straight",
            "type": "define"
          },
          "direction.right": {
            "name": "defines.riding.direction.right",
            "type": "define"
          }
        },
        "type": "define"
      },
      "rocket_silo_status": {
        "name": "rocket_silo_status",
        "properties": {
          "building_rocket": {
            "name": "defines.rocket_silo_status.building_rocket",
            "doc": "The rocket silo is crafting rocket parts. When there are enough rocket parts, the silo will switch into the create_rocket state.",
            "type": "define"
          },
          "create_rocket": {
            "name": "defines.rocket_silo_status.create_rocket",
            "doc": "The next state is lights_blinking_open. The rocket silo rocket entity gets created.",
            "type": "define"
          },
          "lights_blinking_open": {
            "name": "defines.rocket_silo_status.lights_blinking_open",
            "doc": "The next state is doors_opening. The rocket is getting prepared for launch.",
            "type": "define"
          },
          "doors_opening": {
            "name": "defines.rocket_silo_status.doors_opening",
            "doc": "The next state is doors_opened. The rocket is getting prepared for launch.",
            "type": "define"
          },
          "doors_opened": {
            "name": "defines.rocket_silo_status.doors_opened",
            "doc": "The next state is rocket_rising or if the rocket is destroyed in this state then the next state will be lights_blinking_close. The rocket is getting prepared for launch.",
            "type": "define"
          },
          "rocket_rising": {
            "name": "defines.rocket_silo_status.rocket_rising",
            "doc": "The next state is arms_advance or if the rocket is destroyed in this state then the next state will be lights_blinking_close. The rocket is getting prepared for launch.",
            "type": "define"
          },
          "arms_advance": {
            "name": "defines.rocket_silo_status.arms_advance",
            "doc": "The next state is rocket_ready or if the rocket is destroyed in this state then the next state will be lights_blinking_close. The rocket is getting prepared for launch.",
            "type": "define"
          },
          "rocket_ready": {
            "name": "defines.rocket_silo_status.rocket_ready",
            "doc": "The rocket launch can be started by the player. When the launch is started, the silo switches into the launch_starting state.",
            "type": "define"
          },
          "launch_starting": {
            "name": "defines.rocket_silo_status.launch_starting",
            "doc": "The next state is launch_started.",
            "type": "define"
          },
          "engine_starting": {
            "name": "defines.rocket_silo_status.engine_starting",
            "doc": "The next state is arms_retract or if the rocket is destroyed in this state then the next state will be lights_blinking_close. The rocket is getting launched.",
            "type": "define"
          },
          "arms_retract": {
            "name": "defines.rocket_silo_status.arms_retract",
            "doc": "The next state is rocket_flying or if the rocket is destroyed in this state then the next state will be lights_blinking_close. The rocket is getting launched.",
            "type": "define"
          },
          "rocket_flying": {
            "name": "defines.rocket_silo_status.rocket_flying",
            "doc": "The next state is lights_blinking_close. The rocket is getting launched.",
            "type": "define"
          },
          "lights_blinking_close": {
            "name": "defines.rocket_silo_status.lights_blinking_close",
            "doc": "The next state is doors_closing.",
            "type": "define"
          },
          "doors_closing": {
            "name": "defines.rocket_silo_status.doors_closing",
            "doc": "The next state is building_rocket.",
            "type": "define"
          },
          "launch_started": {
            "name": "defines.rocket_silo_status.launch_started",
            "doc": "The next state is engine_starting or if the rocket is destroyed in this state then the next state will be lights_blinking_close. The rocket is getting launched.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "shooting": {
        "name": "shooting",
        "properties": {
          "not_shooting": {
            "name": "defines.shooting.not_shooting",
            "type": "define"
          },
          "shooting_enemies": {
            "name": "defines.shooting.shooting_enemies",
            "type": "define"
          },
          "shooting_selected": {
            "name": "defines.shooting.shooting_selected",
            "type": "define"
          }
        },
        "type": "define"
      },
      "signal_state": {
        "name": "signal_state",
        "properties": {
          "open": {
            "name": "defines.signal_state.open",
            "doc": "Green.",
            "type": "define"
          },
          "closed": {
            "name": "defines.signal_state.closed",
            "doc": "Red.",
            "type": "define"
          },
          "reserved": {
            "name": "defines.signal_state.reserved",
            "doc": "Orange.",
            "type": "define"
          },
          "reserved_by_circuit_network": {
            "name": "defines.signal_state.reserved_by_circuit_network",
            "doc": "Red - From circuit network.",
            "type": "define"
          }
        },
        "type": "define"
      },
      "train_state": {
        "name": "train_state",
        "properties": {
          "on_the_path": {
            "name": "defines.train_state.on_the_path",
            "doc": "Normal state -- following the path.",
            "type": "define"
          },
          "path_lost": {
            "name": "defines.train_state.path_lost",
            "doc": "Had path and lost it -- must stop.",
            "type": "define"
          },
          "no_schedule": {
            "name": "defines.train_state.no_schedule",
            "doc": "Doesn't have anywhere to go.",
            "type": "define"
          },
          "no_path": {
            "name": "defines.train_state.no_path",
            "doc": "Has no path and is stopped.",
            "type": "define"
          },
          "arrive_signal": {
            "name": "defines.train_state.arrive_signal",
            "doc": "Braking before a rail signal.",
            "type": "define"
          },
          "wait_signal": {
            "name": "defines.train_state.wait_signal",
            "doc": "Waiting at a signal.",
            "type": "define"
          },
          "arrive_station": {
            "name": "defines.train_state.arrive_station",
            "doc": "Braking before a station.",
            "type": "define"
          },
          "wait_station": {
            "name": "defines.train_state.wait_station",
            "doc": "Waiting at a station.",
            "type": "define"
          },
          "manual_control_stop": {
            "name": "defines.train_state.manual_control_stop",
            "doc": "Switched to manual control and has to stop.",
            "type": "define"
          },
          "manual_control": {
            "name": "defines.train_state.manual_control",
            "doc": "Can move if user explicitly sits in and rides the train.",
            "type": "define"
          },
          "destination_full": {
            "name": "defines.train_state.destination_full",
            "doc": "Same as no_path but all candidate train stops are full",
            "type": "define"
          }
        },
        "type": "define"
      },
      "transport_line": {
        "name": "transport_line",
        "properties": {
          "left_line": {
            "name": "defines.transport_line.left_line",
            "type": "define"
          },
          "right_line": {
            "name": "defines.transport_line.right_line",
            "type": "define"
          },
          "left_underground_line": {
            "name": "defines.transport_line.left_underground_line",
            "type": "define"
          },
          "right_underground_line": {
            "name": "defines.transport_line.right_underground_line",
            "type": "define"
          },
          "secondary_left_line": {
            "name": "defines.transport_line.secondary_left_line",
            "type": "define"
          },
          "secondary_right_line": {
            "name": "defines.transport_line.secondary_right_line",
            "type": "define"
          },
          "left_split_line": {
            "name": "defines.transport_line.left_split_line",
            "type": "define"
          },
          "right_split_line": {
            "name": "defines.transport_line.right_split_line",
            "type": "define"
          },
          "secondary_left_split_line": {
            "name": "defines.transport_line.secondary_left_split_line",
            "type": "define"
          },
          "secondary_right_split_line": {
            "name": "defines.transport_line.secondary_right_split_line",
            "type": "define"
          }
        },
        "type": "define"
      },
      "wire_connection_id": {
        "name": "wire_connection_id",
        "properties": {
          "electric_pole": {
            "name": "defines.wire_connection_id.electric_pole",
            "type": "define"
          },
          "power_switch_left": {
            "name": "defines.wire_connection_id.power_switch_left",
            "type": "define"
          },
          "power_switch_right": {
            "name": "defines.wire_connection_id.power_switch_right",
            "type": "define"
          }
        },
        "type": "define"
      },
      "wire_type": {
        "name": "wire_type",
        "properties": {
          "red": {
            "name": "defines.wire_type.red",
            "type": "define"
          },
          "green": {
            "name": "defines.wire_type.green",
            "type": "define"
          },
          "copper": {
            "name": "defines.wire_type.copper",
            "type": "define"
          }
        },
        "type": "define"
      }
    }
  },
  "LuaAISettings": {
    "name": "LuaAISettings",
    "type": "LuaAISettings",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "allow_destroy_when_commands_fail": {
        "name": "allow_destroy_when_commands_fail",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If enabled, units that repeatedly fail to succeed at commands will be destroyed.",
        "short": "If enabled, units that repeatedly fail to succeed at commands will be destroyed.",
        "member": "allow_destroy_when_commands_fail  ::boolean Read/Write"
      },
      "allow_try_return_to_spawner": {
        "name": "allow_try_return_to_spawner",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If enabled, units that have nothing else to do will attempt to return to a spawner.",
        "short": "If enabled, units that have nothing else to do will attempt to return to a spawner.",
        "member": "allow_try_return_to_spawner  ::boolean Read/Write"
      },
      "do_separation": {
        "name": "do_separation",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If enabled, units will try to separate themselves from nearby friendly units.",
        "short": "If enabled, units will try to separate themselves from nearby friendly units.",
        "member": "do_separation  ::boolean Read/Write"
      },
      "path_resolution_modifier": {
        "name": "path_resolution_modifier",
        "type": "int8",
        "mode": "[RW]",
        "doc": "Defines how coarse the pathfinder's grid is, where smaller values mean a coarser grid. Defaults to 0, which equals a resolution of 1x1 tiles, centered on tile centers. Values range from -8 to 8 inclusive, where each integer increment doubles/halves the resolution. So, a resolution of -8 equals a grid of 256x256 tiles, and a resolution of 8 equals 1/256 of a tile.",
        "short": "Defines how coarse the pathfinder's grid is, where smaller values mean a coarser grid. [...]",
        "member": "path_resolution_modifier  ::int8 Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaAccumulatorControlBehavior": {
    "name": "LuaAccumulatorControlBehavior",
    "type": "LuaAccumulatorControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "output_signal": {
        "name": "output_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "output_signal  ::SignalID Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaAchievementPrototype": {
    "name": "LuaAchievementPrototype",
    "type": "LuaAchievementPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "allowed_without_fight": {
        "name": "allowed_without_fight",
        "type": "boolean",
        "mode": "[R]",
        "member": "allowed_without_fight  ::boolean Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "member": "hidden  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaAmmoCategoryPrototype": {
    "name": "LuaAmmoCategoryPrototype",
    "type": "LuaAmmoCategoryPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "bonus_gui_order": {
        "name": "bonus_gui_order",
        "type": "string",
        "mode": "[R]",
        "member": "bonus_gui_order  ::string Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaArithmeticCombinatorControlBehavior": {
    "name": "LuaArithmeticCombinatorControlBehavior",
    "type": "LuaArithmeticCombinatorControlBehavior",
    "inherits": [
      "Inherited from LuaCombinatorControlBehavior: signals_last_tick, get_signal_last_tick",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "parameters": {
        "name": "parameters",
        "type": "ArithmeticCombinatorParameters",
        "mode": "[RW]",
        "doc": "This arithmetic combinator's parameters.",
        "short": "This arithmetic combinator's parameters.",
        "member": "parameters  ::ArithmeticCombinatorParameters Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaAutoplaceControlPrototype": {
    "name": "LuaAutoplaceControlPrototype",
    "type": "LuaAutoplaceControlPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "richness": {
        "name": "richness",
        "type": "boolean",
        "mode": "[R]",
        "member": "richness  ::boolean Read"
      },
      "can_be_disabled": {
        "name": "can_be_disabled",
        "type": "boolean",
        "mode": "[R]",
        "member": "can_be_disabled  ::boolean Read"
      },
      "control_order": {
        "name": "control_order",
        "type": "string",
        "mode": "[R]",
        "member": "control_order  ::string Read"
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[R]",
        "doc": "Category name of this prototype.",
        "short": "Category name of this prototype.",
        "member": "category  ::string Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaBootstrap": {
    "name": "LuaBootstrap",
    "type": "LuaBootstrap",
    "inherits": [],
    "properties": {
      "on_init": {
        "name": "on_init",
        "doc": "Register a function to be run on mod initialization. This is only called when a new save game is created or when a save file is loaded that previously didn't contain the mod. During it, the mod gets the chance to set up initial values that it will use for its lifetime. It has full access to LuaGameScript and the global table and can change anything about them that it deems appropriate. No other events will be raised for the mod until it has finished this step.",
        "short": "Register a function to be run on mod initialization. [...]",
        "member": "on_init(handler)",
        "type": "function",
        "args": {
          "handler": {
            "name": "handler",
            "type": "function() or nil",
            "doc": "The handler for this event. Passing nil will unregister it."
          }
        }
      },
      "on_load": {
        "name": "on_load",
        "doc": "Register a function to be run on save load. This is only called for mods that have been part of the save previously, or for players connecting to a running multiplayer session.",
        "short": "Register a function to be run on save load. [...]",
        "member": "on_load(handler)",
        "type": "function",
        "args": {
          "handler": {
            "name": "handler",
            "type": "function() or nil",
            "doc": "The handler for this event. Passing nil will unregister it."
          }
        }
      },
      "on_configuration_changed": {
        "name": "on_configuration_changed",
        "doc": "Register a function to be run when mod configuration changes. This is called when the game version or any mod version changed, when any mod was added or removed, when a startup setting has changed, when any prototypes have been added or removed, or when a migration was applied. It allows the mod to make any changes it deems appropriate to both the data structures in its global table or to the game state through LuaGameScript.",
        "short": "Register a function to be run when mod configuration changes. [...]",
        "member": "on_configuration_changed(handler)",
        "type": "function",
        "args": {
          "handler": {
            "name": "handler",
            "type": "function(ConfigurationChangedData) or nil",
            "doc": "The handler for this event. Passing nil will unregister it."
          }
        }
      },
      "on_event": {
        "name": "on_event",
        "doc": "Register a handler to run on the specified event(s). Each mod can only register once for every event, as any additional registration will overwrite the previous one. This holds true even if different filters are used for subsequent registrations.",
        "short": "Register a handler to run on the specified event(s). [...]",
        "member": "on_event(event, handler, filters?)",
        "type": "function",
        "args": {
          "event": {
            "name": "event",
            "type": "defines.events or string or array[defines.events or string]",
            "doc": "The event(s) or custom-input to invoke the handler on."
          },
          "handler": {
            "name": "handler",
            "type": "function(EventData) or nil",
            "doc": "The handler for this event. Passing nil will unregister it."
          },
          "filters": {
            "name": "filters",
            "type": "EventFilter?",
            "doc": "The filters for this event. Can only be used when registering for individual events."
          }
        }
      },
      "on_nth_tick": {
        "name": "on_nth_tick",
        "doc": "Register a handler to run every nth-tick(s). When the game is on tick 0 it will trigger all registered handlers.",
        "short": "Register a handler to run every nth-tick(s). [...]",
        "member": "on_nth_tick(tick, handler)",
        "type": "function",
        "args": {
          "tick": {
            "name": "tick",
            "type": "uint or array[uint] or nil",
            "doc": "The nth-tick(s) to invoke the handler on. Passing nil as the only parameter will unregister all nth-tick handlers."
          },
          "handler": {
            "name": "handler",
            "type": "function(NthTickEventData) or nil",
            "doc": "The handler to run. Passing nil will unregister it for the provided nth-tick(s)."
          }
        }
      },
      "register_on_entity_destroyed": {
        "name": "register_on_entity_destroyed",
        "type": "function",
        "doc": "Registers an entity so that after it's destroyed, on_entity_destroyed is called. Once an entity is registered, it stays registered until it is actually destroyed, even through save/load cycles. The registration is global across all mods, meaning once one mod registers an entity, all mods listening to on_entity_destroyed will receive the event when it is destroyed. Registering the same entity multiple times will still only fire the destruction event once, and will return the same registration number. Returns: The registration number. It is used to identify the entity in the on_entity_destroyed event.",
        "short": "Registers an entity so that after it's destroyed, on_entity_destroyed is called. [...]",
        "member": "register_on_entity_destroyed(entity)  uint64",
        "returns": "uint64",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity to register."
          }
        }
      },
      "register_metatable": {
        "name": "register_metatable",
        "doc": "Register a metatable to have linkage recorded and restored when saving/loading. The metatable itself will not be saved. Instead, only the linkage to a registered metatable is saved, and the metatable registered under that name will be used when loading the table.",
        "short": "Register a metatable to have linkage recorded and restored when saving/loading. [...]",
        "member": "register_metatable(name, metatable)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The name of this metatable. Names must be unique per mod."
          },
          "metatable": {
            "name": "metatable",
            "type": "table",
            "doc": "The metatable to register."
          }
        }
      },
      "generate_event_name": {
        "name": "generate_event_name",
        "type": "function",
        "doc": "Generate a new, unique event ID that can be used to raise custom events with LuaBootstrap::raise_event. Returns: The newly generated event ID.",
        "short": "Generate a new, unique event ID that can be used to raise custom events with LuaBootstrap::raise_event.",
        "member": "generate_event_name()  uint",
        "returns": "uint"
      },
      "get_event_handler": {
        "name": "get_event_handler",
        "type": "function",
        "doc": "Find the event handler for an event. Returns: Reference to the function currently registered as the handler, if it was found.",
        "short": "Find the event handler for an event.",
        "member": "get_event_handler(event)  function(EventData)?",
        "returns": "function(EventData)?",
        "args": {
          "event": {
            "name": "event",
            "type": "uint",
            "doc": "The event identifier to get a handler for."
          }
        }
      },
      "get_event_order": {
        "name": "get_event_order",
        "type": "function",
        "doc": "Gets the mod event order as a string.",
        "short": "Gets the mod event order as a string.",
        "member": "get_event_order()  string"
      },
      "set_event_filter": {
        "name": "set_event_filter",
        "doc": "Sets the filters for the given event. The filters are only retained when set after the actual event registration, because registering for an event with different or no filters will overwrite previously set ones.",
        "short": "Sets the filters for the given event. [...]",
        "member": "set_event_filter(event, filters?)",
        "type": "function",
        "args": {
          "event": {
            "name": "event",
            "type": "uint",
            "doc": "ID of the event to filter."
          },
          "filters": {
            "name": "filters",
            "type": "EventFilter?",
            "doc": "The filters or nil to clear them."
          }
        }
      },
      "get_event_filter": {
        "name": "get_event_filter",
        "type": "function",
        "doc": "Gets the filters for the given event. Returns: The filters or nil if none are defined.",
        "short": "Gets the filters for the given event.",
        "member": "get_event_filter(event)  EventFilter?",
        "returns": "EventFilter?",
        "args": {
          "event": {
            "name": "event",
            "type": "uint",
            "doc": "ID of the event to get."
          }
        }
      },
      "get_prototype_history": {
        "name": "get_prototype_history",
        "type": "function",
        "doc": "Gets the prototype history for the given type and name.",
        "short": "Gets the prototype history for the given type and name.",
        "member": "get_prototype_history(type, name)  PrototypeHistory",
        "args": {
          "type": {
            "name": "type",
            "type": "string",
            "doc": ""
          },
          "name": {
            "name": "name",
            "type": "string",
            "doc": ""
          }
        }
      },
      "raise_event": {
        "name": "raise_event",
        "doc": "Raise an event. Only events generated with LuaBootstrap::generate_event_name and the following can be raised:",
        "short": "Raise an event. [...]",
        "member": "raise_event(event, data)",
        "type": "function",
        "args": {
          "event": {
            "name": "event",
            "type": "uint",
            "doc": "ID of the event to raise."
          },
          "data": {
            "name": "data",
            "type": "table",
            "doc": "Table with extra data that will be passed to the event handler. Any invalid LuaObjects will silently stop the event from being raised."
          }
        }
      },
      "raise_console_chat": {
        "name": "raise_console_chat",
        "doc": "The player doing the chatting.",
        "member": "raise_console_chat{player_index=, message=}",
        "args": {
          "player_index": {
            "name": "player_index",
            "type": "uint",
            "doc": "The player doing the chatting."
          },
          "message": {
            "name": "message",
            "type": "string",
            "doc": "The chat message to send."
          },
          "on_console_chat": {
            "name": "on_console_chat",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_player_crafted_item": {
        "name": "raise_player_crafted_item",
        "doc": "The item that has been crafted.",
        "member": "raise_player_crafted_item{item_stack=, player_index=, recipe=}",
        "args": {
          "item_stack": {
            "name": "item_stack",
            "type": "LuaItemStack",
            "doc": "The item that has been crafted."
          },
          "player_index": {
            "name": "player_index",
            "type": "uint",
            "doc": "The player doing the crafting."
          },
          "recipe": {
            "name": "recipe",
            "type": "LuaRecipe",
            "doc": "The recipe used to craft this item."
          },
          "on_player_crafted_item": {
            "name": "on_player_crafted_item",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_player_fast_transferred": {
        "name": "raise_player_fast_transferred",
        "doc": "The player transferred from or to.",
        "member": "raise_player_fast_transferred{player_index=, entity=, from_player=, is_split=}",
        "args": {
          "player_index": {
            "name": "player_index",
            "type": "uint",
            "doc": "The player transferred from or to."
          },
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity transferred from or to."
          },
          "from_player": {
            "name": "from_player",
            "type": "boolean",
            "doc": "Whether the transfer was from player to entity. If false, the transfer was from entity to player."
          },
          "is_split": {
            "name": "is_split",
            "type": "boolean",
            "doc": "Whether the transfer was a split action (half stack)."
          },
          "on_player_fast_transferred": {
            "name": "on_player_fast_transferred",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_biter_base_built": {
        "name": "raise_biter_base_built",
        "doc": "The entity that was built.",
        "member": "raise_biter_base_built{entity=}",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity that was built."
          },
          "on_biter_base_built": {
            "name": "on_biter_base_built",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_market_item_purchased": {
        "name": "raise_market_item_purchased",
        "doc": "The player who did the purchasing.",
        "member": "raise_market_item_purchased{player_index=, market=, offer_index=, count=}",
        "args": {
          "player_index": {
            "name": "player_index",
            "type": "uint",
            "doc": "The player who did the purchasing."
          },
          "market": {
            "name": "market",
            "type": "LuaEntity",
            "doc": "The market entity."
          },
          "offer_index": {
            "name": "offer_index",
            "type": "uint",
            "doc": "The index of the offer purchased."
          },
          "count": {
            "name": "count",
            "type": "uint",
            "doc": "The amount of offers purchased."
          },
          "on_market_item_purchased": {
            "name": "on_market_item_purchased",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_script_built": {
        "name": "raise_script_built",
        "doc": "The entity that has been built.",
        "member": "raise_script_built{entity=}",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity that has been built."
          },
          "script_raised_built": {
            "name": "script_raised_built",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_script_destroy": {
        "name": "raise_script_destroy",
        "doc": "The entity that was destroyed.",
        "member": "raise_script_destroy{entity=}",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity that was destroyed."
          },
          "script_raised_destroy": {
            "name": "script_raised_destroy",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_script_revive": {
        "name": "raise_script_revive",
        "doc": "The entity that was revived.",
        "member": "raise_script_revive{entity=, tags?=}",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity that was revived."
          },
          "tags": {
            "name": "tags",
            "type": "Tags?",
            "doc": "The tags associated with this entity, if any."
          },
          "script_raised_revive": {
            "name": "script_raised_revive",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_script_teleported": {
        "name": "raise_script_teleported",
        "doc": "The entity that was teleported.",
        "member": "raise_script_teleported{entity=, old_surface_index=, old_position=}",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity that was teleported."
          },
          "old_surface_index": {
            "name": "old_surface_index",
            "type": "uint8",
            "doc": "The entity's surface before the teleportation."
          },
          "old_position": {
            "name": "old_position",
            "type": "MapPosition",
            "doc": "The entity's position before the teleportation."
          },
          "script_raised_teleported": {
            "name": "script_raised_teleported",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "raise_script_set_tiles": {
        "name": "raise_script_set_tiles",
        "doc": "The surface whose tiles have been changed.",
        "member": "raise_script_set_tiles{surface_index=, tiles=}",
        "args": {
          "surface_index": {
            "name": "surface_index",
            "type": "uint",
            "doc": "The surface whose tiles have been changed."
          },
          "tiles": {
            "name": "tiles",
            "type": "array[Tile]",
            "doc": "The tiles that have been changed."
          },
          "script_raised_set_tiles": {
            "name": "script_raised_set_tiles",
            "doc": "Raised with the provided arguments."
          }
        }
      },
      "mod_name": {
        "name": "mod_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The name of the mod from the environment this is used in.",
        "short": "The name of the mod from the environment this is used in.",
        "member": "mod_name  ::string Read"
      },
      "level": {
        "name": "level",
        "mode": "[R]",
        "doc": "Information about the currently running scenario/campaign/tutorial.",
        "short": "Information about the currently running scenario/campaign/tutorial.",
        "member": "level  ::table Read",
        "args": {
          "is_simulation": {
            "name": "is_simulation",
            "type": "boolean?",
            "doc": "Is this level a simulation? (The main menu and 'Tips and tricks' use simulations)"
          },
          "is_tutorial": {
            "name": "is_tutorial",
            "type": "boolean?",
            "doc": "Is this level a tutorial?"
          },
          "campaign_name": {
            "name": "campaign_name",
            "type": "string?",
            "doc": "The campaign name if any."
          },
          "level_name": {
            "name": "level_name",
            "type": "string",
            "doc": "The level name."
          },
          "mod_name": {
            "name": "mod_name",
            "type": "string?",
            "doc": "The mod name if any."
          }
        }
      },
      "active_mods": {
        "name": "active_mods",
        "type": "string",
        "mode": "[R]",
        "doc": "A dictionary listing the names of all currently active mods and mapping them to their version.",
        "short": "A dictionary listing the names of all currently active mods and mapping them to their version.",
        "member": "active_mods  ::dictionary[string string] Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaBurner": {
    "name": "LuaBurner",
    "type": "LuaBurner",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The owner of this burner energy source",
        "short": "The owner of this burner energy source",
        "member": "owner  ::LuaEntity or LuaEquipment Read"
      },
      "inventory": {
        "name": "inventory",
        "type": "LuaInventory",
        "mode": "[R]",
        "doc": "The fuel inventory.",
        "short": "The fuel inventory.",
        "member": "inventory  ::LuaInventory Read"
      },
      "burnt_result_inventory": {
        "name": "burnt_result_inventory",
        "type": "LuaInventory",
        "mode": "[R]",
        "doc": "The burnt result inventory.",
        "short": "The burnt result inventory.",
        "member": "burnt_result_inventory  ::LuaInventory Read"
      },
      "heat": {
        "name": "heat",
        "type": "double",
        "mode": "[RW]",
        "doc": "The current heat (energy) stored in this burner.",
        "short": "The current heat (energy) stored in this burner.",
        "member": "heat  ::double Read/Write"
      },
      "heat_capacity": {
        "name": "heat_capacity",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum heat (maximum energy) that this burner can store.",
        "short": "The maximum heat (maximum energy) that this burner can store.",
        "member": "heat_capacity  ::double Read"
      },
      "remaining_burning_fuel": {
        "name": "remaining_burning_fuel",
        "type": "double",
        "mode": "[RW]",
        "doc": "The amount of energy left in the currently-burning fuel item.",
        "short": "The amount of energy left in the currently-burning fuel item.",
        "member": "remaining_burning_fuel  ::double Read/Write"
      },
      "currently_burning": {
        "name": "currently_burning",
        "type": "LuaItemPrototype",
        "mode": "[RW]",
        "doc": "The currently burning item. Writing nil will void the currently burning item without producing a LuaBurner::burnt_result.",
        "short": "The currently burning item. [...]",
        "member": "currently_burning  ::LuaItemPrototype? Read/Write"
      },
      "fuel_categories": {
        "name": "fuel_categories",
        "type": "string",
        "mode": "[R]",
        "doc": "The fuel categories this burner uses.",
        "short": "The fuel categories this burner uses.",
        "member": "fuel_categories  ::dictionary[string boolean] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaBurnerPrototype": {
    "name": "LuaBurnerPrototype",
    "type": "LuaBurnerPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions of this energy source in pollution/Joule. Multiplying it by energy consumption in Watt gives pollution/second.",
        "short": "The emissions of this energy source in pollution/Joule. [...]",
        "member": "emissions  ::double Read"
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_network_icon  ::boolean Read"
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_power_icon  ::boolean Read"
      },
      "effectivity": {
        "name": "effectivity",
        "type": "double",
        "mode": "[R]",
        "member": "effectivity  ::double Read"
      },
      "fuel_inventory_size": {
        "name": "fuel_inventory_size",
        "type": "uint",
        "mode": "[R]",
        "member": "fuel_inventory_size  ::uint Read"
      },
      "burnt_inventory_size": {
        "name": "burnt_inventory_size",
        "type": "uint",
        "mode": "[R]",
        "member": "burnt_inventory_size  ::uint Read"
      },
      "smoke": {
        "name": "smoke",
        "type": "SmokeSource",
        "mode": "[R]",
        "doc": "The smoke sources for this burner prototype.",
        "short": "The smoke sources for this burner prototype.",
        "member": "smoke  ::array[SmokeSource]? Read"
      },
      "light_flicker": {
        "name": "light_flicker",
        "mode": "[R]",
        "doc": "The light flicker definition for this burner prototype.",
        "short": "The light flicker definition for this burner prototype.",
        "member": "light_flicker  ::table? Read",
        "args": {
          "minimum_intensity": {
            "name": "minimum_intensity",
            "type": "float",
            "doc": ""
          },
          "maximum_intensity": {
            "name": "maximum_intensity",
            "type": "float",
            "doc": ""
          },
          "derivation_change_frequency": {
            "name": "derivation_change_frequency",
            "type": "float",
            "doc": ""
          },
          "derivation_change_deviation": {
            "name": "derivation_change_deviation",
            "type": "float",
            "doc": ""
          },
          "border_fix_speed": {
            "name": "border_fix_speed",
            "type": "float",
            "doc": ""
          },
          "minimum_light_size": {
            "name": "minimum_light_size",
            "type": "float",
            "doc": ""
          },
          "light_intensity_to_size_coefficient": {
            "name": "light_intensity_to_size_coefficient",
            "type": "float",
            "doc": ""
          },
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          }
        }
      },
      "fuel_categories": {
        "name": "fuel_categories",
        "type": "string",
        "mode": "[R]",
        "doc": "The value in the dictionary is meaningless and exists just to allow for easy lookup.",
        "member": "fuel_categories  ::dictionary[string boolean] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaChunkIterator": {
    "name": "LuaChunkIterator",
    "type": "LuaChunkIterator",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "() (call)": {
        "name": "() (call)",
        "type": "ChunkPositionAndArea",
        "doc": "Gets the next chunk position if the iterator is not yet done and increments the it."
      }
    }
  },
  "LuaCircuitNetwork": {
    "name": "LuaCircuitNetwork",
    "type": "LuaCircuitNetwork",
    "inherits": [],
    "properties": {
      "get_signal": {
        "name": "get_signal",
        "type": "function",
        "doc": "The signal to read. Returns: The current value of the signal.",
        "member": "get_signal(signal)  int",
        "returns": "int",
        "args": {
          "signal": {
            "name": "signal",
            "type": "SignalID",
            "doc": "The signal to read."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "entity": {
        "name": "entity",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The entity this circuit network reference is associated with.",
        "short": "The entity this circuit network reference is associated with.",
        "member": "entity  ::LuaEntity Read"
      },
      "wire_type": {
        "name": "wire_type",
        "type": "defines.wire_type",
        "mode": "[R]",
        "doc": "The wire type this network is associated with.",
        "short": "The wire type this network is associated with.",
        "member": "wire_type  ::defines.wire_type Read"
      },
      "circuit_connector_id": {
        "name": "circuit_connector_id",
        "type": "defines.circuit_connector_id",
        "mode": "[R]",
        "doc": "The circuit connector ID on the associated entity this network was gotten from.",
        "short": "The circuit connector ID on the associated entity this network was gotten from.",
        "member": "circuit_connector_id  ::defines.circuit_connector_id Read"
      },
      "signals": {
        "name": "signals",
        "type": "Signal",
        "mode": "[R]",
        "doc": "The circuit network signals last tick. nil if there were no signals last tick.",
        "short": "The circuit network signals last tick. [...]",
        "member": "signals  ::array[Signal]? Read"
      },
      "network_id": {
        "name": "network_id",
        "type": "uint",
        "mode": "[R]",
        "doc": "The circuit networks ID.",
        "short": "The circuit networks ID.",
        "member": "network_id  ::uint Read"
      },
      "connected_circuit_count": {
        "name": "connected_circuit_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of circuits connected to this network.",
        "short": "The number of circuits connected to this network.",
        "member": "connected_circuit_count  ::uint Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaCombinatorControlBehavior": {
    "name": "LuaCombinatorControlBehavior",
    "type": "LuaCombinatorControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "get_signal_last_tick": {
        "name": "get_signal_last_tick",
        "type": "function",
        "doc": "Gets the value of a specific signal sent by this combinator behavior last tick or nil if the signal didn't exist.",
        "short": "Gets the value of a specific signal sent by this combinator behavior last tick or nil if the signal didn't exist.",
        "member": "get_signal_last_tick(signal)  int?",
        "args": {
          "signal": {
            "name": "signal",
            "type": "SignalID",
            "doc": "The signal to get"
          }
        }
      },
      "signals_last_tick": {
        "name": "signals_last_tick",
        "type": "Signal",
        "mode": "[R]",
        "doc": "The circuit network signals sent by this combinator last tick.",
        "short": "The circuit network signals sent by this combinator last tick.",
        "member": "signals_last_tick  ::array[Signal] Read"
      }
    }
  },
  "LuaCommandProcessor": {
    "name": "LuaCommandProcessor",
    "type": "LuaCommandProcessor",
    "inherits": [],
    "properties": {
      "add_command": {
        "name": "add_command",
        "doc": "Add a custom console command.",
        "short": "Add a custom console command.",
        "member": "add_command(name, help, function)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The desired name of the command (case sensitive)."
          },
          "help": {
            "name": "help",
            "type": "LocalisedString",
            "doc": "The localised help message. It will be shown to players using the /help command."
          },
          "function": {
            "name": "function",
            "type": "function(CustomCommandData)",
            "doc": "The function that will be called when this command is invoked."
          }
        }
      },
      "remove_command": {
        "name": "remove_command",
        "type": "function",
        "doc": "Remove a custom console command. Returns: Whether the command was successfully removed. Returns false if the command didn't exist.",
        "short": "Remove a custom console command.",
        "member": "remove_command(name)  boolean",
        "returns": "boolean",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The name of the command to remove (case sensitive)."
          }
        }
      },
      "commands": {
        "name": "commands",
        "type": "string",
        "mode": "[R]",
        "doc": "Lists the custom commands registered by scripts through LuaCommandProcessor.",
        "short": "Lists the custom commands registered by scripts through LuaCommandProcessor.",
        "member": "commands  ::dictionary[string LocalisedString] Read"
      },
      "game_commands": {
        "name": "game_commands",
        "type": "string",
        "mode": "[R]",
        "doc": "Lists the built-in commands of the core game. The wiki has an overview of these.",
        "short": "Lists the built-in commands of the core game. [...]",
        "member": "game_commands  ::dictionary[string LocalisedString] Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaConstantCombinatorControlBehavior": {
    "name": "LuaConstantCombinatorControlBehavior",
    "type": "LuaConstantCombinatorControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "set_signal": {
        "name": "set_signal",
        "doc": "Sets the signal at the given index.",
        "short": "Sets the signal at the given index.",
        "member": "set_signal(index, signal?)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          },
          "signal": {
            "name": "signal",
            "type": "Signal?",
            "doc": "Passing nil clears the signal."
          }
        }
      },
      "get_signal": {
        "name": "get_signal",
        "type": "function",
        "doc": "Gets the signal at the given index. Returned Signal will not contain signal if none is set for the index.",
        "short": "Gets the signal at the given index. [...]",
        "member": "get_signal(index)  Signal",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "parameters": {
        "name": "parameters",
        "type": "ConstantCombinatorParameters",
        "mode": "[RW]",
        "doc": "This constant combinator's parameters. nil if the item_slot_count of the combinator's prototype is 0.",
        "short": "This constant combinator's parameters. [...]",
        "member": "parameters  ::array[ConstantCombinatorParameters]? Read/Write"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Turns this constant combinator on and off.",
        "short": "Turns this constant combinator on and off.",
        "member": "enabled  ::boolean Read/Write"
      },
      "signals_count": {
        "name": "signals_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of signals this constant combinator supports.",
        "short": "The number of signals this constant combinator supports.",
        "member": "signals_count  ::uint Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaContainerControlBehavior": {
    "name": "LuaContainerControlBehavior",
    "type": "LuaContainerControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaControl": {
    "name": "LuaControl",
    "type": "LuaControl",
    "inherits": [],
    "properties": {
      "get_inventory": {
        "name": "get_inventory",
        "type": "function",
        "doc": "Get an inventory belonging to this entity. This can be either the \"main\" inventory or some auxiliary one, like the module slots or logistic trash slots. Returns: The inventory or nil if none with the given index was found.",
        "short": "Get an inventory belonging to this entity. [...]",
        "member": "get_inventory(inventory)  LuaInventory?",
        "returns": "LuaInventory?",
        "args": {
          "inventory": {
            "name": "inventory",
            "type": "defines.inventory",
            "doc": ""
          }
        }
      },
      "get_max_inventory_index": {
        "name": "get_max_inventory_index",
        "type": "function",
        "doc": "The highest index of all inventories this entity can use. Allows iteration over all of them if desired.",
        "short": "The highest index of all inventories this entity can use. [...]",
        "member": "get_max_inventory_index()  defines.inventory"
      },
      "get_main_inventory": {
        "name": "get_main_inventory",
        "type": "function",
        "doc": "Gets the main inventory for this character or player if this is a character or player. Returns: The inventory or nil if this entity is not a character or player.",
        "short": "Gets the main inventory for this character or player if this is a character or player.",
        "member": "get_main_inventory()  LuaInventory?",
        "returns": "LuaInventory?"
      },
      "can_insert": {
        "name": "can_insert",
        "type": "function",
        "doc": "Can at least some items be inserted? Returns: true if at least a part of the given items could be inserted into this inventory.",
        "short": "Can at least some items be inserted?",
        "member": "can_insert(items)  boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items that would be inserted."
          }
        }
      },
      "insert": {
        "name": "insert",
        "type": "function",
        "doc": "Insert items into this entity. This works the same way as inserters or shift-clicking: the \"best\" inventory is chosen automatically. Returns: The number of items that were actually inserted.",
        "short": "Insert items into this entity. [...]",
        "member": "insert(items)  uint",
        "returns": "uint",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "The items to insert."
          }
        }
      },
      "set_gui_arrow": {
        "name": "set_gui_arrow",
        "doc": "Create an arrow which points at this entity. This is used in the tutorial. For examples, see control.lua in the campaign missions.",
        "short": "Create an arrow which points at this entity. [...]",
        "member": "set_gui_arrow{margin=, type=}",
        "args": {
          "margin": {
            "name": "margin",
            "type": "uint",
            "doc": ""
          },
          "type": {
            "name": "type",
            "type": "GuiArrowType",
            "doc": "Where to point to. This field determines what other fields are mandatory."
          },
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "crafting_queueindex": {
            "name": "crafting_queueindex",
            "type": "uint",
            "doc": "Index in the crafting queue to point to."
          },
          "inventory_index": {
            "name": "inventory_index",
            "type": "defines.inventory",
            "doc": "Which inventory the stack is in."
          },
          "item_stack_index": {
            "name": "item_stack_index",
            "type": "uint",
            "doc": "Which stack to point to."
          },
          "source": {
            "name": "source",
            "type": "\"player\" or \"target\" or \"player-quickbar\" or \"player-equipment-bar\"",
            "doc": ""
          }
        }
      },
      "clear_gui_arrow": {
        "name": "clear_gui_arrow",
        "doc": "Removes the arrow created by set_gui_arrow.",
        "short": "Removes the arrow created by set_gui_arrow.",
        "member": "clear_gui_arrow()",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count",
        "type": "function",
        "doc": "Get the number of all or some items in this entity.",
        "short": "Get the number of all or some items in this entity.",
        "member": "get_item_count(item?)  uint",
        "args": {
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "Prototype name of the item to count. If not specified, count all items."
          }
        }
      },
      "has_items_inside": {
        "name": "has_items_inside",
        "type": "function",
        "doc": "Does this entity have any item inside it?",
        "short": "Does this entity have any item inside it?",
        "member": "has_items_inside()  boolean"
      },
      "can_reach_entity": {
        "name": "can_reach_entity",
        "type": "function",
        "doc": "Can a given entity be opened or accessed?",
        "short": "Can a given entity be opened or accessed?",
        "member": "can_reach_entity(entity)  boolean",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": ""
          }
        }
      },
      "clear_items_inside": {
        "name": "clear_items_inside",
        "doc": "Remove all items from this entity.",
        "short": "Remove all items from this entity.",
        "member": "clear_items_inside()",
        "type": "function"
      },
      "remove_item": {
        "name": "remove_item",
        "type": "function",
        "doc": "Remove items from this entity. Returns: The number of items that were actually removed.",
        "short": "Remove items from this entity.",
        "member": "remove_item(items)  uint",
        "returns": "uint",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "The items to remove."
          }
        }
      },
      "teleport": {
        "name": "teleport",
        "type": "function",
        "doc": "Teleport the entity to a given position, possibly on another surface. Returns: true if the entity was successfully teleported.",
        "short": "Teleport the entity to a given position, possibly on another surface.",
        "member": "teleport(position, surface?, raise_teleported?)  boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where to teleport to."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "Surface to teleport to. If not given, will teleport to the entity's current surface. Only players, cars, and spidertrons can be teleported cross-surface."
          },
          "raise_teleported": {
            "name": "raise_teleported",
            "type": "boolean?",
            "doc": "If true, defines.events.script_raised_teleported will be fired on successful entity teleportation."
          },
          "on_player_changed_position?": {
            "name": "on_player_changed_position?",
            "doc": "Raised if the teleported entity is a player character."
          },
          "script_raised_teleported?": {
            "name": "script_raised_teleported?",
            "doc": "Raised if the raise_teleported flag was set and the entity was successfully teleported."
          }
        }
      },
      "update_selected_entity": {
        "name": "update_selected_entity",
        "doc": "Select an entity, as if by hovering the mouse above it.",
        "short": "Select an entity, as if by hovering the mouse above it.",
        "member": "update_selected_entity(position)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Position of the entity to select."
          },
          "on_selected_entity_changed?": {
            "name": "on_selected_entity_changed?",
            "doc": "Raised if there is an entity at the given position to select."
          }
        }
      },
      "clear_selected_entity": {
        "name": "clear_selected_entity",
        "doc": "Unselect any selected entity.",
        "short": "Unselect any selected entity.",
        "member": "clear_selected_entity()",
        "type": "function",
        "args": {
          "on_selected_entity_changed?": {
            "name": "on_selected_entity_changed?",
            "doc": "Raised if there is a currently selected entity."
          }
        }
      },
      "disable_flashlight": {
        "name": "disable_flashlight",
        "doc": "Disable the flashlight.",
        "short": "Disable the flashlight.",
        "member": "disable_flashlight()",
        "type": "function"
      },
      "enable_flashlight": {
        "name": "enable_flashlight",
        "doc": "Enable the flashlight.",
        "short": "Enable the flashlight.",
        "member": "enable_flashlight()",
        "type": "function"
      },
      "is_flashlight_enabled": {
        "name": "is_flashlight_enabled",
        "type": "function",
        "doc": "Is the flashlight enabled.",
        "short": "Is the flashlight enabled.",
        "member": "is_flashlight_enabled()  boolean"
      },
      "get_craftable_count": {
        "name": "get_craftable_count",
        "type": "function",
        "doc": "Gets the count of the given recipe that can be crafted. Returns: The count that can be crafted.",
        "short": "Gets the count of the given recipe that can be crafted.",
        "member": "get_craftable_count(recipe)  uint",
        "returns": "uint",
        "args": {
          "recipe": {
            "name": "recipe",
            "type": "string or LuaRecipe",
            "doc": "The recipe."
          }
        }
      },
      "begin_crafting": {
        "name": "begin_crafting",
        "type": "uint",
        "doc": "Begins crafting the given count of the given recipe. Returns: The count that was actually started crafting.",
        "short": "Begins crafting the given count of the given recipe.",
        "member": "begin_crafting{count=, recipe=, silent?=}  uint",
        "returns": "uint",
        "args": {
          "count": {
            "name": "count",
            "type": "uint",
            "doc": "The count to craft."
          },
          "recipe": {
            "name": "recipe",
            "type": "string or LuaRecipe",
            "doc": "The recipe to craft."
          },
          "silent": {
            "name": "silent",
            "type": "boolean?",
            "doc": "If false and the recipe can't be crafted the requested number of times printing the failure is skipped."
          },
          "on_pre_player_crafted_item?": {
            "name": "on_pre_player_crafted_item?",
            "doc": "Raised if crafting was able to be started."
          },
          "on_player_main_inventory_changed?": {
            "name": "on_player_main_inventory_changed?",
            "doc": "Raised if crafting was able to be started."
          }
        }
      },
      "cancel_crafting": {
        "name": "cancel_crafting",
        "doc": "Cancels crafting the given count of the given crafting queue index.",
        "short": "Cancels crafting the given count of the given crafting queue index.",
        "member": "cancel_crafting{index=, count=}",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The crafting queue index."
          },
          "count": {
            "name": "count",
            "type": "uint",
            "doc": "The count to cancel crafting."
          },
          "on_player_cancelled_crafting?": {
            "name": "on_player_cancelled_crafting?",
            "doc": "Raised if crafting was able to be cancelled."
          },
          "on_player_main_inventory_changed?": {
            "name": "on_player_main_inventory_changed?",
            "doc": "Raised if crafting was able to be cancelled."
          }
        }
      },
      "mine_entity": {
        "name": "mine_entity",
        "type": "function",
        "doc": "Mines the given entity as if this player (or character) mined it. Returns: Whether the mining succeeded.",
        "short": "Mines the given entity as if this player (or character) mined it.",
        "member": "mine_entity(entity, force?)  boolean",
        "returns": "boolean",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity to mine"
          },
          "force": {
            "name": "force",
            "type": "boolean?",
            "doc": "Forces mining the entity even if the items can't fit in the player."
          },
          "on_pre_player_mined_item?": {
            "name": "on_pre_player_mined_item?",
            "doc": "Raised if mining is possible."
          },
          "on_player_mined_entity?": {
            "name": "on_player_mined_entity?",
            "doc": "Raised if mining is successful."
          },
          "on_player_mined_item?": {
            "name": "on_player_mined_item?",
            "doc": "Raised if mining is successful."
          }
        }
      },
      "mine_tile": {
        "name": "mine_tile",
        "type": "function",
        "doc": "Mines the given tile as if this player (or character) mined it. Returns: Whether the mining succeeded.",
        "short": "Mines the given tile as if this player (or character) mined it.",
        "member": "mine_tile(tile)  boolean",
        "returns": "boolean",
        "args": {
          "tile": {
            "name": "tile",
            "type": "LuaTile",
            "doc": "The tile to mine."
          },
          "on_player_mined_item?": {
            "name": "on_player_mined_item?",
            "doc": "Raised if mining is successful."
          },
          "on_player_mined_tile?": {
            "name": "on_player_mined_tile?",
            "doc": "Raised if mining is successful."
          }
        }
      },
      "is_player": {
        "name": "is_player",
        "type": "function",
        "doc": "When true control adapter is a LuaPlayer object, false for entities including characters with players.",
        "short": "When true control adapter is a LuaPlayer object, false for entities including characters with players.",
        "member": "is_player()  boolean"
      },
      "open_technology_gui": {
        "name": "open_technology_gui",
        "doc": "Open the technology GUI and select a given technology.",
        "short": "Open the technology GUI and select a given technology.",
        "member": "open_technology_gui(technology?)",
        "type": "function",
        "args": {
          "technology": {
            "name": "technology",
            "type": "TechnologyIdentification?",
            "doc": "The technology to select after opening the GUI."
          }
        }
      },
      "set_personal_logistic_slot": {
        "name": "set_personal_logistic_slot",
        "type": "function",
        "doc": "Sets a personal logistic request and auto-trash slot to the given value. Returns: Whether the slot was set successfully. false if personal logistics are not researched yet.",
        "short": "Sets a personal logistic request and auto-trash slot to the given value.",
        "member": "set_personal_logistic_slot(slot_index, value)  boolean",
        "returns": "boolean",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "The slot to set."
          },
          "value": {
            "name": "value",
            "type": "LogisticParameters",
            "doc": "The logistic request parameters."
          },
          "on_entity_logistic_slot_changed?": {
            "name": "on_entity_logistic_slot_changed?",
            "doc": "Raised if setting of logistic slot was successful."
          }
        }
      },
      "set_vehicle_logistic_slot": {
        "name": "set_vehicle_logistic_slot",
        "type": "function",
        "doc": "Sets a vehicle logistic request and auto-trash slot to the given value. Only used on spider-vehicle. Returns: Whether the slot was set successfully. false if the vehicle does not use logistics.",
        "short": "Sets a vehicle logistic request and auto-trash slot to the given value. [...]",
        "member": "set_vehicle_logistic_slot(slot_index, value)  boolean",
        "returns": "boolean",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "The slot to set."
          },
          "value": {
            "name": "value",
            "type": "LogisticParameters",
            "doc": "The logistic request parameters."
          },
          "on_entity_logistic_slot_changed?": {
            "name": "on_entity_logistic_slot_changed?",
            "doc": "Raised if setting of logistic slot was successful."
          }
        }
      },
      "get_personal_logistic_slot": {
        "name": "get_personal_logistic_slot",
        "type": "function",
        "doc": "Gets the parameters of a personal logistic request and auto-trash slot. Returns: The logistic parameters. If personal logistics are not researched yet, their name will be nil.",
        "short": "Gets the parameters of a personal logistic request and auto-trash slot.",
        "member": "get_personal_logistic_slot(slot_index)  LogisticParameters",
        "returns": "LogisticParameters",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "The slot to get."
          }
        }
      },
      "get_vehicle_logistic_slot": {
        "name": "get_vehicle_logistic_slot",
        "type": "function",
        "doc": "Gets the parameters of a vehicle logistic request and auto-trash slot. Only used on spider-vehicle. Returns: The logistic parameters. If the vehicle does not use logistics, their name will be nil.",
        "short": "Gets the parameters of a vehicle logistic request and auto-trash slot. [...]",
        "member": "get_vehicle_logistic_slot(slot_index)  LogisticParameters",
        "returns": "LogisticParameters",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "The slot to get."
          }
        }
      },
      "clear_personal_logistic_slot": {
        "name": "clear_personal_logistic_slot",
        "doc": "The slot to clear.",
        "member": "clear_personal_logistic_slot(slot_index)",
        "type": "function",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "The slot to clear."
          },
          "on_entity_logistic_slot_changed?": {
            "name": "on_entity_logistic_slot_changed?",
            "doc": "Raised if clearing of logistic slot was successful."
          }
        }
      },
      "clear_vehicle_logistic_slot": {
        "name": "clear_vehicle_logistic_slot",
        "doc": "The slot to clear.",
        "member": "clear_vehicle_logistic_slot(slot_index)",
        "type": "function",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "The slot to clear."
          },
          "on_entity_logistic_slot_changed?": {
            "name": "on_entity_logistic_slot_changed?",
            "doc": "Raised if clearing of logistic slot was successful."
          }
        }
      },
      "is_cursor_blueprint": {
        "name": "is_cursor_blueprint",
        "type": "function",
        "doc": "Returns whether the player is holding a blueprint. This takes both blueprint items as well as blueprint records from the blueprint library into account.",
        "short": "Returns whether the player is holding a blueprint. [...]",
        "member": "is_cursor_blueprint()  boolean"
      },
      "get_blueprint_entities": {
        "name": "get_blueprint_entities",
        "type": "function",
        "doc": "Gets the entities that are part of the currently selected blueprint, regardless of it being in a blueprint book or picked from the blueprint library. Returns: Returns nil if there is no currently selected blueprint.",
        "short": "Gets the entities that are part of the currently selected blueprint, regardless of it being in a blueprint book or picked from the blueprint library.",
        "member": "get_blueprint_entities()  array[BlueprintEntity]?",
        "returns": "array[BlueprintEntity]?"
      },
      "is_cursor_empty": {
        "name": "is_cursor_empty",
        "type": "function",
        "doc": "Returns whether the player is holding something in the cursor. It takes into account items from the blueprint library, as well as items and ghost cursor.",
        "short": "Returns whether the player is holding something in the cursor. [...]",
        "member": "is_cursor_empty()  boolean"
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[R]",
        "doc": "The surface this entity is currently on.",
        "short": "The surface this entity is currently on.",
        "member": "surface  ::LuaSurface Read"
      },
      "surface_index": {
        "name": "surface_index",
        "type": "uint",
        "mode": "[R]",
        "doc": "Unique index (ID) associated with the surface this entity is currently on.",
        "short": "Unique index (ID) associated with the surface this entity is currently on.",
        "member": "surface_index  ::uint Read"
      },
      "position": {
        "name": "position",
        "type": "MapPosition",
        "mode": "[R]",
        "doc": "The current position of the entity.",
        "short": "The current position of the entity.",
        "member": "position  ::MapPosition Read"
      },
      "vehicle": {
        "name": "vehicle",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The vehicle the player is currently sitting in.",
        "short": "The vehicle the player is currently sitting in.",
        "member": "vehicle  ::LuaEntity? Read"
      },
      "force": {
        "name": "force",
        "type": "ForceIdentification",
        "mode": "[RW]",
        "doc": "The force of this entity. Reading will always give a LuaForce, but it is possible to assign either string or LuaForce to this attribute to change the force.",
        "short": "The force of this entity. [...]",
        "member": "force  ::ForceIdentification Read/Write"
      },
      "force_index": {
        "name": "force_index",
        "type": "uint",
        "mode": "[R]",
        "doc": "Unique index (ID) associated with the force of this entity.",
        "short": "Unique index (ID) associated with the force of this entity.",
        "member": "force_index  ::uint Read"
      },
      "selected": {
        "name": "selected",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The currently selected entity. Assigning an entity will select it if is selectable, otherwise the selection is cleared.",
        "short": "The currently selected entity. [...]",
        "member": "selected  ::LuaEntity? Read/Write",
        "args": {
          "on_selected_entity_changed?": {
            "name": "on_selected_entity_changed?",
            "doc": "Raised when a selectable entity is written to this attribute."
          }
        }
      },
      "opened": {
        "name": "opened",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The GUI the player currently has open.",
        "short": "The GUI the player currently has open. [...]",
        "member": "opened  ::LuaEntity or LuaItemStack or LuaEquipment or LuaEquipmentGrid or LuaPlayer or LuaGuiElement or LuaInventory or LuaTechnology or defines.gui_type? Read/Write",
        "args": {
          "on_gui_opened?": {
            "name": "on_gui_opened?",
            "doc": "Raised when writing a valid GUI target to this attribute."
          }
        }
      },
      "crafting_queue_size": {
        "name": "crafting_queue_size",
        "type": "uint",
        "mode": "[R]",
        "doc": "Size of the crafting queue.",
        "short": "Size of the crafting queue.",
        "member": "crafting_queue_size  ::uint Read"
      },
      "crafting_queue_progress": {
        "name": "crafting_queue_progress",
        "type": "double",
        "mode": "[RW]",
        "doc": "The crafting queue progress in the range [0-1]. 0 when no recipe is being crafted.",
        "short": "The crafting queue progress in the range [0-1]. [...]",
        "member": "crafting_queue_progress  ::double Read/Write"
      },
      "walking_state": {
        "name": "walking_state",
        "mode": "[RW]",
        "doc": "Current walking state.",
        "short": "Current walking state.",
        "member": "walking_state  ::table Read/Write",
        "args": {
          "walking": {
            "name": "walking",
            "type": "boolean",
            "doc": "If false, the player is currently not walking; otherwise it's going somewhere"
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction",
            "doc": "Direction where the player is walking"
          }
        }
      },
      "riding_state": {
        "name": "riding_state",
        "type": "RidingState",
        "mode": "[RW]",
        "doc": "Current riding state of this car, or of the car this player is riding in.",
        "short": "Current riding state of this car, or of the car this player is riding in.",
        "member": "riding_state  ::RidingState Read/Write"
      },
      "mining_state": {
        "name": "mining_state",
        "mode": "[RW]",
        "doc": "Current mining state.",
        "short": "Current mining state.",
        "member": "mining_state  ::table Read/Write",
        "args": {
          "mining": {
            "name": "mining",
            "type": "boolean",
            "doc": "Whether the player is mining at all."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "What location the player is mining. Only relevant if mining is true."
          }
        }
      },
      "shooting_state": {
        "name": "shooting_state",
        "mode": "[RW]",
        "doc": "Current shooting state.",
        "short": "Current shooting state.",
        "member": "shooting_state  ::table Read/Write",
        "args": {
          "state": {
            "name": "state",
            "type": "defines.shooting",
            "doc": "The current state"
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position being shot at"
          }
        }
      },
      "picking_state": {
        "name": "picking_state",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Current item-picking state.",
        "short": "Current item-picking state.",
        "member": "picking_state  ::boolean Read/Write"
      },
      "repair_state": {
        "name": "repair_state",
        "mode": "[RW]",
        "doc": "Current repair state.",
        "short": "Current repair state.",
        "member": "repair_state  ::table Read/Write",
        "args": {
          "repairing": {
            "name": "repairing",
            "type": "boolean",
            "doc": "The current state"
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position being repaired"
          }
        }
      },
      "cursor_stack": {
        "name": "cursor_stack",
        "type": "LuaItemStack",
        "mode": "[R]",
        "doc": "The player's cursor stack. nil if the player controller is a spectator.",
        "short": "The player's cursor stack. [...]",
        "member": "cursor_stack  ::LuaItemStack? Read"
      },
      "cursor_ghost": {
        "name": "cursor_ghost",
        "type": "ItemPrototypeIdentification",
        "mode": "[RW]",
        "doc": "The ghost prototype in the player's cursor. When read, it will be a LuaItemPrototype.",
        "short": "The ghost prototype in the player's cursor. [...]",
        "member": "cursor_ghost  ::ItemPrototypeIdentification? Read/Write"
      },
      "driving": {
        "name": "driving",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the player is in a vehicle. Writing to this attribute puts the player in or out of a vehicle.",
        "short": "true if the player is in a vehicle. [...]",
        "member": "driving  ::boolean Read/Write",
        "args": {
          "on_player_driving_changed_state?": {
            "name": "on_player_driving_changed_state?",
            "doc": "Raised if the driving state successfully changed."
          }
        }
      },
      "crafting_queue": {
        "name": "crafting_queue",
        "type": "CraftingQueueItem",
        "mode": "[R]",
        "doc": "The current crafting queue items.",
        "short": "The current crafting queue items.",
        "member": "crafting_queue  ::array[CraftingQueueItem] Read"
      },
      "following_robots": {
        "name": "following_robots",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The current combat robots following the character.",
        "short": "The current combat robots following the character.",
        "member": "following_robots  ::array[LuaEntity] Read"
      },
      "cheat_mode": {
        "name": "cheat_mode",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "When true hand crafting is free and instant.",
        "short": "When true hand crafting is free and instant.",
        "member": "cheat_mode  ::boolean Read/Write"
      },
      "character_crafting_speed_modifier": {
        "name": "character_crafting_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_crafting_speed_modifier  ::double Read/Write"
      },
      "character_mining_speed_modifier": {
        "name": "character_mining_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_mining_speed_modifier  ::double Read/Write"
      },
      "character_additional_mining_categories": {
        "name": "character_additional_mining_categories",
        "type": "string",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_additional_mining_categories  ::array[string] Read/Write"
      },
      "character_running_speed_modifier": {
        "name": "character_running_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "Modifies the running speed of this character by the given value as a percentage. Setting the running modifier to 0.5 makes the character run 50% faster. The minimum value of -1 reduces the movement speed by 100%, resulting in a speed of 0.",
        "short": "Modifies the running speed of this character by the given value as a percentage. [...]",
        "member": "character_running_speed_modifier  ::double Read/Write"
      },
      "character_build_distance_bonus": {
        "name": "character_build_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_build_distance_bonus  ::uint Read/Write"
      },
      "character_item_drop_distance_bonus": {
        "name": "character_item_drop_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_item_drop_distance_bonus  ::uint Read/Write"
      },
      "character_reach_distance_bonus": {
        "name": "character_reach_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_reach_distance_bonus  ::uint Read/Write"
      },
      "character_resource_reach_distance_bonus": {
        "name": "character_resource_reach_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_resource_reach_distance_bonus  ::uint Read/Write"
      },
      "character_item_pickup_distance_bonus": {
        "name": "character_item_pickup_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_item_pickup_distance_bonus  ::uint Read/Write"
      },
      "character_loot_pickup_distance_bonus": {
        "name": "character_loot_pickup_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_loot_pickup_distance_bonus  ::uint Read/Write"
      },
      "character_inventory_slots_bonus": {
        "name": "character_inventory_slots_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_inventory_slots_bonus  ::uint Read/Write"
      },
      "character_trash_slot_count_bonus": {
        "name": "character_trash_slot_count_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_trash_slot_count_bonus  ::uint Read/Write"
      },
      "character_maximum_following_robot_count_bonus": {
        "name": "character_maximum_following_robot_count_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_maximum_following_robot_count_bonus  ::uint Read/Write"
      },
      "character_health_bonus": {
        "name": "character_health_bonus",
        "type": "float",
        "mode": "[RW]",
        "doc": "When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).",
        "member": "character_health_bonus  ::float Read/Write"
      },
      "character_personal_logistic_requests_enabled": {
        "name": "character_personal_logistic_requests_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If personal logistic requests are enabled for this character or players character.",
        "short": "If personal logistic requests are enabled for this character or players character.",
        "member": "character_personal_logistic_requests_enabled  ::boolean Read/Write"
      },
      "vehicle_logistic_requests_enabled": {
        "name": "vehicle_logistic_requests_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If personal logistic requests are enabled for this vehicle (spidertron).",
        "short": "If personal logistic requests are enabled for this vehicle (spidertron).",
        "member": "vehicle_logistic_requests_enabled  ::boolean Read/Write"
      },
      "opened_gui_type": {
        "name": "opened_gui_type",
        "type": "defines.gui_type",
        "mode": "[R]",
        "member": "opened_gui_type  ::defines.gui_type? Read"
      },
      "build_distance": {
        "name": "build_distance",
        "type": "uint",
        "mode": "[R]",
        "doc": "The build distance of this character or max uint when not a character or player connected to a character.",
        "short": "The build distance of this character or max uint when not a character or player connected to a character.",
        "member": "build_distance  ::uint Read"
      },
      "drop_item_distance": {
        "name": "drop_item_distance",
        "type": "uint",
        "mode": "[R]",
        "doc": "The item drop distance of this character or max uint when not a character or player connected to a character.",
        "short": "The item drop distance of this character or max uint when not a character or player connected to a character.",
        "member": "drop_item_distance  ::uint Read"
      },
      "reach_distance": {
        "name": "reach_distance",
        "type": "uint",
        "mode": "[R]",
        "doc": "The reach distance of this character or max uint when not a character or player connected to a character.",
        "short": "The reach distance of this character or max uint when not a character or player connected to a character.",
        "member": "reach_distance  ::uint Read"
      },
      "item_pickup_distance": {
        "name": "item_pickup_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The item pickup distance of this character or max double when not a character or player connected to a character.",
        "short": "The item pickup distance of this character or max double when not a character or player connected to a character.",
        "member": "item_pickup_distance  ::double Read"
      },
      "loot_pickup_distance": {
        "name": "loot_pickup_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The loot pickup distance of this character or max double when not a character or player connected to a character.",
        "short": "The loot pickup distance of this character or max double when not a character or player connected to a character.",
        "member": "loot_pickup_distance  ::double Read"
      },
      "resource_reach_distance": {
        "name": "resource_reach_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The resource reach distance of this character or max double when not a character or player connected to a character.",
        "short": "The resource reach distance of this character or max double when not a character or player connected to a character.",
        "member": "resource_reach_distance  ::double Read"
      },
      "in_combat": {
        "name": "in_combat",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this character entity is in combat.",
        "short": "Whether this character entity is in combat.",
        "member": "in_combat  ::boolean Read"
      },
      "character_running_speed": {
        "name": "character_running_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The current movement speed of this character, including effects from exoskeletons, tiles, stickers and shooting.",
        "short": "The current movement speed of this character, including effects from exoskeletons, tiles, stickers and shooting.",
        "member": "character_running_speed  ::double Read"
      },
      "character_mining_progress": {
        "name": "character_mining_progress",
        "type": "double",
        "mode": "[R]",
        "doc": "The current mining progress between 0 and 1 of this character, or 0 if they aren't mining.",
        "short": "The current mining progress between 0 and 1 of this character, or 0 if they aren't mining.",
        "member": "character_mining_progress  ::double Read"
      }
    }
  },
  "LuaControlBehavior": {
    "name": "LuaControlBehavior",
    "type": "LuaControlBehavior",
    "inherits": [],
    "properties": {
      "get_circuit_network": {
        "name": "get_circuit_network",
        "type": "function",
        "doc": "Wire color of the network connected to this entity. Returns: The circuit network or nil.",
        "member": "get_circuit_network(wire, circuit_connector?)  LuaCircuitNetwork",
        "returns": "LuaCircuitNetwork",
        "args": {
          "wire": {
            "name": "wire",
            "type": "defines.wire_type",
            "doc": "Wire color of the network connected to this entity."
          },
          "circuit_connector": {
            "name": "circuit_connector",
            "type": "defines.circuit_connector_id?",
            "doc": "The connector to get circuit network for. Must be specified for entities with more than one circuit network connector."
          }
        }
      },
      "type": {
        "name": "type",
        "type": "defines.control_behavior.type",
        "mode": "[R]",
        "doc": "The concrete type of this control behavior.",
        "short": "The concrete type of this control behavior.",
        "member": "type  ::defines.control_behavior.type Read"
      },
      "entity": {
        "name": "entity",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The entity this control behavior belongs to.",
        "short": "The entity this control behavior belongs to.",
        "member": "entity  ::LuaEntity Read"
      }
    }
  },
  "LuaCustomChartTag": {
    "name": "LuaCustomChartTag",
    "type": "LuaCustomChartTag",
    "inherits": [],
    "properties": {
      "destroy": {
        "name": "destroy",
        "doc": "Destroys this tag.",
        "short": "Destroys this tag.",
        "member": "destroy()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "icon": {
        "name": "icon",
        "type": "SignalID",
        "mode": "[RW]",
        "doc": "This tag's icon, if it has one. Writing nil removes it.",
        "short": "This tag's icon, if it has one. [...]",
        "member": "icon  ::SignalID Read/Write"
      },
      "last_user": {
        "name": "last_user",
        "type": "LuaPlayer",
        "mode": "[RW]",
        "doc": "The player who last edited this tag.",
        "short": "The player who last edited this tag.",
        "member": "last_user  ::LuaPlayer? Read/Write"
      },
      "position": {
        "name": "position",
        "type": "MapPosition",
        "mode": "[R]",
        "doc": "The position of this tag.",
        "short": "The position of this tag.",
        "member": "position  ::MapPosition Read"
      },
      "text": {
        "name": "text",
        "type": "string",
        "mode": "[RW]",
        "member": "text  ::string Read/Write"
      },
      "tag_number": {
        "name": "tag_number",
        "type": "uint",
        "mode": "[R]",
        "doc": "The unique ID for this tag on this force.",
        "short": "The unique ID for this tag on this force.",
        "member": "tag_number  ::uint Read"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force this tag belongs to.",
        "short": "The force this tag belongs to.",
        "member": "force  ::LuaForce Read"
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[R]",
        "doc": "The surface this tag belongs to.",
        "short": "The surface this tag belongs to.",
        "member": "surface  ::LuaSurface Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaCustomInputPrototype": {
    "name": "LuaCustomInputPrototype",
    "type": "LuaCustomInputPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "key_sequence": {
        "name": "key_sequence",
        "type": "string",
        "mode": "[R]",
        "doc": "The default key sequence for this custom input.",
        "short": "The default key sequence for this custom input.",
        "member": "key_sequence  ::string Read"
      },
      "alternative_key_sequence": {
        "name": "alternative_key_sequence",
        "type": "string",
        "mode": "[R]",
        "doc": "The default alternative key sequence for this custom input, if any",
        "short": "The default alternative key sequence for this custom input, if any",
        "member": "alternative_key_sequence  ::string? Read"
      },
      "controller_key_sequence": {
        "name": "controller_key_sequence",
        "type": "string",
        "mode": "[R]",
        "doc": "The default controller key sequence for this custom input, if any",
        "short": "The default controller key sequence for this custom input, if any",
        "member": "controller_key_sequence  ::string? Read"
      },
      "controller_alternative_key_sequence": {
        "name": "controller_alternative_key_sequence",
        "type": "string",
        "mode": "[R]",
        "doc": "The default controller alternative key sequence for this custom input, if any",
        "short": "The default controller alternative key sequence for this custom input, if any",
        "member": "controller_alternative_key_sequence  ::string? Read"
      },
      "linked_game_control": {
        "name": "linked_game_control",
        "type": "string",
        "mode": "[R]",
        "doc": "The linked game control name, if any.",
        "short": "The linked game control name, if any.",
        "member": "linked_game_control  ::string? Read"
      },
      "consuming": {
        "name": "consuming",
        "mode": "[R]",
        "doc": "The consuming type.",
        "short": "The consuming type.",
        "member": "consuming  ::\"none\" or \"game-only\" Read"
      },
      "action": {
        "name": "action",
        "type": "string",
        "mode": "[R]",
        "doc": "The action that happens when this custom input is triggered.",
        "short": "The action that happens when this custom input is triggered.",
        "member": "action  ::string Read"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this custom input is enabled. Disabled custom inputs exist but are not used by the game.",
        "short": "Whether this custom input is enabled. [...]",
        "member": "enabled  ::boolean Read"
      },
      "enabled_while_spectating": {
        "name": "enabled_while_spectating",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this custom input is enabled while using the spectator controller.",
        "short": "Whether this custom input is enabled while using the spectator controller.",
        "member": "enabled_while_spectating  ::boolean Read"
      },
      "enabled_while_in_cutscene": {
        "name": "enabled_while_in_cutscene",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this custom input is enabled while using the cutscene controller.",
        "short": "Whether this custom input is enabled while using the cutscene controller.",
        "member": "enabled_while_in_cutscene  ::boolean Read"
      },
      "include_selected_prototype": {
        "name": "include_selected_prototype",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this custom input will include the selected prototype (if any) when triggered.",
        "short": "Whether this custom input will include the selected prototype (if any) when triggered.",
        "member": "include_selected_prototype  ::boolean Read"
      },
      "item_to_spawn": {
        "name": "item_to_spawn",
        "type": "LuaItemPrototype",
        "mode": "[R]",
        "doc": "The item that gets spawned when this custom input is fired, if any.",
        "short": "The item that gets spawned when this custom input is fired, if any.",
        "member": "item_to_spawn  ::LuaItemPrototype? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaCustomTable": {
    "name": "LuaCustomTable",
    "type": "LuaCustomTable",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "[] (index)": {
        "name": "[] (index)",
        "type": "Any",
        "mode": "[RW]",
        "doc": "Access an element of this custom table."
      },
      "# (length)": {
        "name": "# (length)",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of elements in this table."
      }
    }
  },
  "LuaDamagePrototype": {
    "name": "LuaDamagePrototype",
    "type": "LuaDamagePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this damage type is hidden from entity tooltips.",
        "short": "Whether this damage type is hidden from entity tooltips.",
        "member": "hidden  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaDeciderCombinatorControlBehavior": {
    "name": "LuaDeciderCombinatorControlBehavior",
    "type": "LuaDeciderCombinatorControlBehavior",
    "inherits": [
      "Inherited from LuaCombinatorControlBehavior: signals_last_tick, get_signal_last_tick",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "parameters": {
        "name": "parameters",
        "type": "DeciderCombinatorParameters",
        "mode": "[RW]",
        "doc": "This decider combinator's parameters.",
        "short": "This decider combinator's parameters.",
        "member": "parameters  ::DeciderCombinatorParameters Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaDecorativePrototype": {
    "name": "LuaDecorativePrototype",
    "type": "LuaDecorativePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "collision_box": {
        "name": "collision_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box used for collision checking.",
        "short": "The bounding box used for collision checking.",
        "member": "collision_box  ::BoundingBox Read"
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "CollisionMask",
        "mode": "[R]",
        "doc": "The collision masks this decorative uses",
        "short": "The collision masks this decorative uses",
        "member": "collision_mask  ::CollisionMask Read"
      },
      "collision_mask_with_flags": {
        "name": "collision_mask_with_flags",
        "type": "CollisionMaskWithFlags",
        "mode": "[R]",
        "member": "collision_mask_with_flags  ::CollisionMaskWithFlags Read"
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[R]",
        "doc": "Autoplace specification for this decorative prototype, if any.",
        "short": "Autoplace specification for this decorative prototype, if any.",
        "member": "autoplace_specification  ::AutoplaceSpecification? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaElectricEnergySourcePrototype": {
    "name": "LuaElectricEnergySourcePrototype",
    "type": "LuaElectricEnergySourcePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "buffer_capacity": {
        "name": "buffer_capacity",
        "type": "double",
        "mode": "[R]",
        "member": "buffer_capacity  ::double Read"
      },
      "usage_priority": {
        "name": "usage_priority",
        "type": "string",
        "mode": "[R]",
        "member": "usage_priority  ::string Read"
      },
      "input_flow_limit": {
        "name": "input_flow_limit",
        "type": "double",
        "mode": "[R]",
        "member": "input_flow_limit  ::double Read"
      },
      "output_flow_limit": {
        "name": "output_flow_limit",
        "type": "double",
        "mode": "[R]",
        "member": "output_flow_limit  ::double Read"
      },
      "drain": {
        "name": "drain",
        "type": "double",
        "mode": "[R]",
        "member": "drain  ::double Read"
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions of this energy source in pollution/Joule. Multiplying it by energy consumption in Watt gives pollution/second.",
        "short": "The emissions of this energy source in pollution/Joule. [...]",
        "member": "emissions  ::double Read"
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_network_icon  ::boolean Read"
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_power_icon  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEntity": {
    "name": "LuaEntity",
    "type": "LuaEntity",
    "inherits": [
      "Inherited from LuaControl: surface, surface_index, position, vehicle, force, force_index, selected, opened, crafting_queue_size, crafting_queue_progress, walking_state, riding_state, mining_state, shooting_state, picking_state, repair_state, cursor_stack, cursor_ghost, driving, crafting_queue, following_robots, cheat_mode, character_crafting_speed_modifier, character_mining_speed_modifier, character_additional_mining_categories, character_running_speed_modifier, character_build_distance_bonus, character_item_drop_distance_bonus, character_reach_distance_bonus, character_resource_reach_distance_bonus, character_item_pickup_distance_bonus, character_loot_pickup_distance_bonus, character_inventory_slots_bonus, character_trash_slot_count_bonus, character_maximum_following_robot_count_bonus, character_health_bonus, character_personal_logistic_requests_enabled, vehicle_logistic_requests_enabled, opened_gui_type, build_distance, drop_item_distance, reach_distance, item_pickup_distance, loot_pickup_distance, resource_reach_distance, in_combat, character_running_speed, character_mining_progress, get_inventory, get_max_inventory_index, get_main_inventory, can_insert, insert, set_gui_arrow, clear_gui_arrow, get_item_count, has_items_inside, can_reach_entity, clear_items_inside, remove_item, teleport, update_selected_entity, clear_selected_entity, disable_flashlight, enable_flashlight, is_flashlight_enabled, get_craftable_count, begin_crafting, cancel_crafting, mine_entity, mine_tile, is_player, open_technology_gui, set_personal_logistic_slot, set_vehicle_logistic_slot, get_personal_logistic_slot, get_vehicle_logistic_slot, clear_personal_logistic_slot, clear_vehicle_logistic_slot, is_cursor_blueprint, get_blueprint_entities, is_cursor_empty"
    ],
    "properties": {
      "get_output_inventory": {
        "name": "get_output_inventory",
        "type": "function",
        "doc": "Gets the entity's output inventory if it has one. Returns: A reference to the entity's output inventory.",
        "short": "Gets the entity's output inventory if it has one.",
        "member": "get_output_inventory()  LuaInventory?",
        "returns": "LuaInventory?"
      },
      "get_module_inventory": {
        "name": "get_module_inventory",
        "type": "function",
        "doc": "Inventory for storing modules of this entity; nil if this entity has no module inventory.",
        "short": "Inventory for storing modules of this entity; nil if this entity has no module inventory.",
        "member": "get_module_inventory()  LuaInventory?"
      },
      "get_fuel_inventory": {
        "name": "get_fuel_inventory",
        "type": "function",
        "doc": "The fuel inventory for this entity or nil if this entity doesn't have a fuel inventory.",
        "short": "The fuel inventory for this entity or nil if this entity doesn't have a fuel inventory.",
        "member": "get_fuel_inventory()  LuaInventory?"
      },
      "get_burnt_result_inventory": {
        "name": "get_burnt_result_inventory",
        "type": "function",
        "doc": "The burnt result inventory for this entity or nil if this entity doesn't have a burnt result inventory.",
        "short": "The burnt result inventory for this entity or nil if this entity doesn't have a burnt result inventory.",
        "member": "get_burnt_result_inventory()  LuaInventory?"
      },
      "damage": {
        "name": "damage",
        "type": "function",
        "doc": "Damages the entity. Returns: the total damage actually applied after resistances.",
        "short": "Damages the entity.",
        "member": "damage(damage, force, type?, dealer?)  float",
        "returns": "float",
        "args": {
          "damage": {
            "name": "damage",
            "type": "float",
            "doc": "The amount of damage to be done."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force that will be doing the damage."
          },
          "type": {
            "name": "type",
            "type": "string?",
            "doc": "The type of damage to be done, defaults to \"impact\". Can't be nil."
          },
          "dealer": {
            "name": "dealer",
            "type": "LuaEntity?",
            "doc": "The entity to consider as the damage dealer. Needs to be on the same surface as the entity being damaged."
          },
          "on_entity_damaged": {
            "name": "on_entity_damaged",
            "doc": ""
          }
        }
      },
      "can_be_destroyed": {
        "name": "can_be_destroyed",
        "type": "function",
        "doc": "Whether the entity can be destroyed",
        "short": "Whether the entity can be destroyed",
        "member": "can_be_destroyed()  boolean"
      },
      "destroy": {
        "name": "destroy",
        "type": "boolean",
        "doc": "Destroys the entity. Returns: Returns false if the entity was valid and destruction failed, true in all other cases.",
        "short": "Destroys the entity.",
        "member": "destroy{do_cliff_correction?=, raise_destroy?=}  boolean",
        "returns": "boolean",
        "args": {
          "do_cliff_correction": {
            "name": "do_cliff_correction",
            "type": "boolean?",
            "doc": "Whether neighbouring cliffs should be corrected. Defaults to false."
          },
          "raise_destroy": {
            "name": "raise_destroy",
            "type": "boolean?",
            "doc": "If true, script_raised_destroy will be called. Defaults to false."
          },
          "script_raised_destroy?": {
            "name": "script_raised_destroy?",
            "doc": "Raised if the raise_destroy flag was set and the entity was successfully destroyed."
          }
        }
      },
      "set_command": {
        "name": "set_command",
        "doc": "Give the entity a command.",
        "short": "Give the entity a command.",
        "member": "set_command(command)",
        "type": "function",
        "args": {
          "command": {
            "name": "command",
            "type": "Command",
            "doc": ""
          }
        }
      },
      "set_distraction_command": {
        "name": "set_distraction_command",
        "doc": "Give the entity a distraction command.",
        "short": "Give the entity a distraction command.",
        "member": "set_distraction_command(command)",
        "type": "function",
        "args": {
          "command": {
            "name": "command",
            "type": "Command",
            "doc": ""
          }
        }
      },
      "has_command": {
        "name": "has_command",
        "type": "function",
        "doc": "Has this unit been assigned a command?",
        "short": "Has this unit been assigned a command?",
        "member": "has_command()  boolean"
      },
      "die": {
        "name": "die",
        "type": "function",
        "doc": "Immediately kills the entity. Does nothing if the entity doesn't have health.",
        "short": "Immediately kills the entity. [...]",
        "member": "die(force?, cause?)  boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force to attribute the kill to."
          },
          "cause": {
            "name": "cause",
            "type": "LuaEntity?",
            "doc": "The cause to attribute the kill to."
          },
          "on_entity_died?": {
            "name": "on_entity_died?",
            "doc": "Raised if the entity was successfully killed. If force is not specified, the event will blame the \"neutral\" force."
          },
          "on_post_entity_died?": {
            "name": "on_post_entity_died?",
            "doc": "Raised if the entity was successfully killed."
          }
        }
      },
      "has_flag": {
        "name": "has_flag",
        "type": "function",
        "doc": "Test whether this entity's prototype has a certain flag set. Returns: true if this entity has the given flag set.",
        "short": "Test whether this entity's prototype has a certain flag set.",
        "member": "has_flag(flag)  boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "name": "flag",
            "type": "EntityPrototypeFlag",
            "doc": "The flag to test."
          }
        }
      },
      "ghost_has_flag": {
        "name": "ghost_has_flag",
        "type": "function",
        "doc": "Same as LuaEntity::has_flag, but targets the inner entity on a entity ghost. Returns: true if the entity has the given flag set.",
        "short": "Same as LuaEntity::has_flag, but targets the inner entity on a entity ghost.",
        "member": "ghost_has_flag(flag)  boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "name": "flag",
            "type": "EntityPrototypeFlag",
            "doc": "The flag to test."
          }
        }
      },
      "add_market_item": {
        "name": "add_market_item",
        "doc": "Offer a thing on the market.",
        "short": "Offer a thing on the market.",
        "member": "add_market_item(offer)",
        "type": "function",
        "args": {
          "offer": {
            "name": "offer",
            "type": "Offer",
            "doc": ""
          }
        }
      },
      "remove_market_item": {
        "name": "remove_market_item",
        "type": "function",
        "doc": "Remove an offer from a market. Returns: true if the offer was successfully removed; false when the given index was not valid.",
        "short": "Remove an offer from a market.",
        "member": "remove_market_item(offer)  boolean",
        "returns": "boolean",
        "args": {
          "offer": {
            "name": "offer",
            "type": "uint",
            "doc": "Index of offer to remove."
          }
        }
      },
      "get_market_items": {
        "name": "get_market_items",
        "type": "function",
        "doc": "Get all offers in a market as an array.",
        "short": "Get all offers in a market as an array.",
        "member": "get_market_items()  array[Offer]"
      },
      "clear_market_items": {
        "name": "clear_market_items",
        "doc": "Removes all offers from a market.",
        "short": "Removes all offers from a market.",
        "member": "clear_market_items()",
        "type": "function"
      },
      "connect_neighbour": {
        "name": "connect_neighbour",
        "type": "function",
        "doc": "Connect two devices with a circuit wire or copper cable. Depending on which type of connection should be made, there are different procedures: Returns: Whether the connection was successfully formed.",
        "short": "Connect two devices with a circuit wire or copper cable. [...]",
        "member": "connect_neighbour(target)  boolean",
        "returns": "boolean",
        "args": {
          "target": {
            "name": "target",
            "type": "LuaEntity or WireConnectionDefinition",
            "doc": "The target with which to establish a connection."
          }
        }
      },
      "disconnect_neighbour": {
        "name": "disconnect_neighbour",
        "doc": "Disconnect circuit wires or copper cables between devices. Depending on which type of connection should be cut, there are different procedures:",
        "short": "Disconnect circuit wires or copper cables between devices. [...]",
        "member": "disconnect_neighbour(target?)",
        "type": "function",
        "args": {
          "target": {
            "name": "target",
            "type": "defines.wire_type or LuaEntity or WireConnectionDefinition?",
            "doc": "The target with which to cut a connection."
          }
        }
      },
      "order_deconstruction": {
        "name": "order_deconstruction",
        "type": "function",
        "doc": "Sets the entity to be deconstructed by construction robots. Returns: if the entity was marked for deconstruction.",
        "short": "Sets the entity to be deconstructed by construction robots.",
        "member": "order_deconstruction(force, player?)  boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose robots are supposed to do the deconstruction."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "on_marked_for_deconstruction?": {
            "name": "on_marked_for_deconstruction?",
            "doc": "Raised if the entity was successfully marked for deconstruction."
          }
        }
      },
      "cancel_deconstruction": {
        "name": "cancel_deconstruction",
        "doc": "Cancels deconstruction if it is scheduled, does nothing otherwise.",
        "short": "Cancels deconstruction if it is scheduled, does nothing otherwise.",
        "member": "cancel_deconstruction(force, player?)",
        "type": "function",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force who did the deconstruction order."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "on_cancelled_deconstruction?": {
            "name": "on_cancelled_deconstruction?",
            "doc": "Raised if the entity's deconstruction was successfully cancelled."
          }
        }
      },
      "to_be_deconstructed": {
        "name": "to_be_deconstructed",
        "type": "function",
        "doc": "Is this entity marked for deconstruction?",
        "short": "Is this entity marked for deconstruction?",
        "member": "to_be_deconstructed()  boolean"
      },
      "order_upgrade": {
        "name": "order_upgrade",
        "type": "boolean",
        "doc": "Sets the entity to be upgraded by construction robots. Returns: Whether the entity was marked for upgrade.",
        "short": "Sets the entity to be upgraded by construction robots.",
        "member": "order_upgrade{force=, target=, player?=, direction?=}  boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose robots are supposed to do the upgrade."
          },
          "target": {
            "name": "target",
            "type": "EntityPrototypeIdentification",
            "doc": "The prototype of the entity to upgrade to."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": ""
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "The new direction if any."
          },
          "on_marked_for_upgrade?": {
            "name": "on_marked_for_upgrade?",
            "doc": "Raised if the entity was successfully marked for upgrade."
          }
        }
      },
      "cancel_upgrade": {
        "name": "cancel_upgrade",
        "type": "function",
        "doc": "Cancels upgrade if it is scheduled, does nothing otherwise. Returns: Whether the cancel was successful.",
        "short": "Cancels upgrade if it is scheduled, does nothing otherwise.",
        "member": "cancel_upgrade(force, player?)  boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force who did the upgrade order."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "on_cancelled_upgrade?": {
            "name": "on_cancelled_upgrade?",
            "doc": "Raised if the entity way previously marked for upgrade."
          }
        }
      },
      "to_be_upgraded": {
        "name": "to_be_upgraded",
        "type": "function",
        "doc": "Is this entity marked for upgrade?",
        "short": "Is this entity marked for upgrade?",
        "member": "to_be_upgraded()  boolean"
      },
      "get_request_slot": {
        "name": "get_request_slot",
        "type": "function",
        "doc": "Get a logistic requester slot. Returns: Contents of the specified slot; nil if the given slot contains no request.",
        "short": "Get a logistic requester slot.",
        "member": "get_request_slot(slot)  SimpleItemStack?",
        "returns": "SimpleItemStack?",
        "args": {
          "slot": {
            "name": "slot",
            "type": "uint",
            "doc": "The slot index."
          }
        }
      },
      "set_request_slot": {
        "name": "set_request_slot",
        "type": "function",
        "doc": "Set a logistic requester slot. Returns: Whether the slot was set.",
        "short": "Set a logistic requester slot.",
        "member": "set_request_slot(request, slot)  boolean",
        "returns": "boolean",
        "args": {
          "request": {
            "name": "request",
            "type": "ItemStackIdentification",
            "doc": "What to request."
          },
          "slot": {
            "name": "slot",
            "type": "uint",
            "doc": "The slot index."
          }
        }
      },
      "clear_request_slot": {
        "name": "clear_request_slot",
        "doc": "Clear a logistic requester slot.",
        "short": "Clear a logistic requester slot.",
        "member": "clear_request_slot(slot)",
        "type": "function",
        "args": {
          "slot": {
            "name": "slot",
            "type": "uint",
            "doc": "The slot index."
          }
        }
      },
      "is_crafting": {
        "name": "is_crafting",
        "type": "function",
        "doc": "Returns whether a craft is currently in process. It does not indicate whether progress is currently being made, but whether a crafting process has been started in this machine.",
        "short": "Returns whether a craft is currently in process. [...]",
        "member": "is_crafting()  boolean"
      },
      "is_opened": {
        "name": "is_opened",
        "type": "function",
        "doc": "true if this gate is currently opened. Returns: true if this gate is currently opened.",
        "member": "is_opened()  boolean",
        "returns": "boolean"
      },
      "is_opening": {
        "name": "is_opening",
        "type": "function",
        "doc": "true if this gate is currently opening. Returns: true if this gate is currently opening.",
        "member": "is_opening()  boolean",
        "returns": "boolean"
      },
      "is_closed": {
        "name": "is_closed",
        "type": "function",
        "doc": "true if this gate is currently closed. Returns: true if this gate is currently closed.",
        "member": "is_closed()  boolean",
        "returns": "boolean"
      },
      "is_closing": {
        "name": "is_closing",
        "type": "function",
        "doc": "true if this gate is currently closing Returns: true if this gate is currently closing",
        "member": "is_closing()  boolean",
        "returns": "boolean"
      },
      "request_to_open": {
        "name": "request_to_open",
        "doc": "The force that requests the gate to be open.",
        "member": "request_to_open(force, extra_time?)",
        "type": "function",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force that requests the gate to be open."
          },
          "extra_time": {
            "name": "extra_time",
            "type": "uint?",
            "doc": "Extra ticks to stay open."
          }
        }
      },
      "request_to_close": {
        "name": "request_to_close",
        "doc": "The force that requests the gate to be closed.",
        "member": "request_to_close(force)",
        "type": "function",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force that requests the gate to be closed."
          }
        }
      },
      "get_transport_line": {
        "name": "get_transport_line",
        "type": "function",
        "doc": "Get a transport line of a belt or belt connectable entity.",
        "short": "Get a transport line of a belt or belt connectable entity.",
        "member": "get_transport_line(index)  LuaTransportLine",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "Index of the requested transport line. Transport lines are 1-indexed."
          }
        }
      },
      "get_max_transport_line_index": {
        "name": "get_max_transport_line_index",
        "type": "function",
        "doc": "Get the maximum transport line index of a belt or belt connectable entity.",
        "short": "Get the maximum transport line index of a belt or belt connectable entity.",
        "member": "get_max_transport_line_index()  uint"
      },
      "launch_rocket": {
        "name": "launch_rocket",
        "type": "function",
        "doc": "true if the rocket was successfully launched. Return value of false means the silo is not ready for launch. Returns: true if the rocket was successfully launched. Return value of false means the silo is not ready for launch.",
        "member": "launch_rocket()  boolean",
        "returns": "boolean",
        "args": {
          "on_rocket_launch_ordered?": {
            "name": "on_rocket_launch_ordered?",
            "doc": "Raised if the rocket launch was successfully initiated."
          }
        }
      },
      "revive": {
        "name": "revive",
        "type": "string",
        "doc": "Revive a ghost. I.e. turn it from a ghost to a real entity or tile. Returns: The item request proxy if it was requested with return_item_request_proxy.",
        "short": "Revive a ghost. [...]",
        "member": "revive{return_item_request_proxy?=, raise_revive?=}  dictionary[string uint]?, LuaEntity?, LuaEntity?",
        "returns": "LuaEntity?",
        "args": {
          "return_item_request_proxy": {
            "name": "return_item_request_proxy",
            "type": "boolean?",
            "doc": "If true the function will return item request proxy as the third return value."
          },
          "raise_revive": {
            "name": "raise_revive",
            "type": "boolean?",
            "doc": "If true, and an entity ghost; script_raised_revive will be called. Else if true, and a tile ghost; script_raised_set_tiles will be called."
          },
          "script_raised_revive?": {
            "name": "script_raised_revive?",
            "doc": "Raised if this was an entity ghost and the raise_revive flag was set and the entity was successfully revived."
          },
          "script_raised_set_tiles?": {
            "name": "script_raised_set_tiles?",
            "doc": "Raised if this was a tile ghost and the raise_revive flag was set and the tile was successfully revived."
          }
        }
      },
      "silent_revive": {
        "name": "silent_revive",
        "type": "string",
        "doc": "Revives a ghost silently. Returns: The item request proxy if it was requested with return_item_request_proxy.",
        "short": "Revives a ghost silently.",
        "member": "silent_revive{return_item_request_proxy?=, raise_revive?=}  dictionary[string uint]?, LuaEntity?, LuaEntity?",
        "returns": "LuaEntity?",
        "args": {
          "return_item_request_proxy": {
            "name": "return_item_request_proxy",
            "type": "boolean?",
            "doc": "If true the function will return item request proxy as the third parameter."
          },
          "raise_revive": {
            "name": "raise_revive",
            "type": "boolean?",
            "doc": "If true, and an entity ghost; script_raised_revive will be called. Else if true, and a tile ghost; script_raised_set_tiles will be called."
          },
          "script_raised_revive?": {
            "name": "script_raised_revive?",
            "doc": "Raised if this was an entity ghost and the raise_revive flag was set and the entity was successfully revived."
          },
          "script_raised_set_tiles?": {
            "name": "script_raised_set_tiles?",
            "doc": "Raised if this was a tile ghost and the raise_revive flag was set and the tile was successfully revived."
          }
        }
      },
      "get_connected_rail": {
        "name": "get_connected_rail",
        "type": "LuaEntity",
        "member": "get_connected_rail{rail_direction=, rail_connection_direction=}  LuaEntity?, defines.rail_direction?, defines.rail_connection_direction?",
        "returns": "defines.rail_connection_direction?",
        "doc": "undefined Returns: Turn to be taken when going back from returned rail to origin rail",
        "args": {
          "rail_direction": {
            "name": "rail_direction",
            "type": "defines.rail_direction",
            "doc": ""
          },
          "rail_connection_direction": {
            "name": "rail_connection_direction",
            "type": "defines.rail_connection_direction",
            "doc": ""
          }
        }
      },
      "get_connected_rails": {
        "name": "get_connected_rails",
        "type": "function",
        "doc": "Get the rails that this signal is connected to.",
        "short": "Get the rails that this signal is connected to.",
        "member": "get_connected_rails()  array[LuaEntity]"
      },
      "get_rail_segment_entity": {
        "name": "get_rail_segment_entity",
        "type": "function",
        "doc": "Get the rail signal or train stop at the start/end of the rail segment this rail is in. Returns: nil if the rail segment doesn't start/end with a signal nor a train stop.",
        "short": "Get the rail signal or train stop at the start/end of the rail segment this rail is in.",
        "member": "get_rail_segment_entity(direction, in_else_out)  LuaEntity?",
        "returns": "LuaEntity?",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.rail_direction",
            "doc": "The direction of travel relative to this rail."
          },
          "in_else_out": {
            "name": "in_else_out",
            "type": "boolean",
            "doc": "If true, gets the entity at the entrance of the rail segment, otherwise gets the entity at the exit of the rail segment."
          }
        }
      },
      "get_rail_segment_end": {
        "name": "get_rail_segment_end",
        "type": "function",
        "doc": "Get the rail at the end of the rail segment this rail is in. Returns: A rail direction pointing out of the rail segment from the end rail.",
        "short": "Get the rail at the end of the rail segment this rail is in.",
        "member": "get_rail_segment_end(direction)  LuaEntity, defines.rail_direction",
        "returns": "defines.rail_direction",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.rail_direction",
            "doc": ""
          }
        }
      },
      "get_rail_segment_rails": {
        "name": "get_rail_segment_rails",
        "type": "function",
        "doc": "Get all rails of a rail segment this rail is in Returns: Rails of this rail segment",
        "short": "Get all rails of a rail segment this rail is in",
        "member": "get_rail_segment_rails(direction)  array[LuaEntity]",
        "returns": "array[LuaEntity]",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.rail_direction",
            "doc": "Selects end of this rail that points to a rail segment end from which to start returning rails"
          }
        }
      },
      "get_rail_segment_length": {
        "name": "get_rail_segment_length",
        "type": "function",
        "doc": "Get the length of the rail segment this rail is in.",
        "short": "Get the length of the rail segment this rail is in.",
        "member": "get_rail_segment_length()  double"
      },
      "get_rail_segment_overlaps": {
        "name": "get_rail_segment_overlaps",
        "type": "function",
        "doc": "Get a rail from each rail segment that overlaps with this rail's rail segment.",
        "short": "Get a rail from each rail segment that overlaps with this rail's rail segment.",
        "member": "get_rail_segment_overlaps()  array[LuaEntity]"
      },
      "is_rail_in_same_rail_segment_as": {
        "name": "is_rail_in_same_rail_segment_as",
        "type": "function",
        "doc": "Checks if this rail and other rail both belong to the same rail segment.",
        "short": "Checks if this rail and other rail both belong to the same rail segment.",
        "member": "is_rail_in_same_rail_segment_as(other_rail)  boolean",
        "args": {
          "other_rail": {
            "name": "other_rail",
            "type": "LuaEntity",
            "doc": ""
          }
        }
      },
      "is_rail_in_same_rail_block_as": {
        "name": "is_rail_in_same_rail_block_as",
        "type": "function",
        "doc": "Checks if this rail and other rail both belong to the same rail block.",
        "short": "Checks if this rail and other rail both belong to the same rail block.",
        "member": "is_rail_in_same_rail_block_as(other_rail)  boolean",
        "args": {
          "other_rail": {
            "name": "other_rail",
            "type": "LuaEntity",
            "doc": ""
          }
        }
      },
      "get_parent_signals": {
        "name": "get_parent_signals",
        "type": "function",
        "doc": "Returns all parent signals. Parent signals are always RailChainSignal. Parent signals are those signals that are checking state of this signal to determine their own chain state.",
        "short": "Returns all parent signals. [...]",
        "member": "get_parent_signals()  array[LuaEntity]"
      },
      "get_child_signals": {
        "name": "get_child_signals",
        "type": "function",
        "doc": "Returns all child signals. Child signals can be either RailSignal or RailChainSignal. Child signals are signals which are checked by this signal to determine a chain state.",
        "short": "Returns all child signals. [...]",
        "member": "get_child_signals()  array[LuaEntity]"
      },
      "get_inbound_signals": {
        "name": "get_inbound_signals",
        "type": "function",
        "doc": "Returns all signals guarding entrance to a rail block this rail belongs to.",
        "short": "Returns all signals guarding entrance to a rail block this rail belongs to.",
        "member": "get_inbound_signals()  array[LuaEntity]"
      },
      "get_outbound_signals": {
        "name": "get_outbound_signals",
        "type": "function",
        "doc": "Returns all signals guarding exit from a rail block this rail belongs to.",
        "short": "Returns all signals guarding exit from a rail block this rail belongs to.",
        "member": "get_outbound_signals()  array[LuaEntity]"
      },
      "get_filter": {
        "name": "get_filter",
        "type": "function",
        "doc": "Get the filter for a slot in an inserter, loader, or logistic storage container. Returns: Prototype name of the item being filtered. nil if the given slot has no filter.",
        "short": "Get the filter for a slot in an inserter, loader, or logistic storage container.",
        "member": "get_filter(slot_index)  string?",
        "returns": "string?",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "Index of the slot to get the filter for."
          }
        }
      },
      "set_filter": {
        "name": "set_filter",
        "doc": "Set the filter for a slot in an inserter, loader, or logistic storage container.",
        "short": "Set the filter for a slot in an inserter, loader, or logistic storage container.",
        "member": "set_filter(slot_index, item)",
        "type": "function",
        "args": {
          "slot_index": {
            "name": "slot_index",
            "type": "uint",
            "doc": "Index of the slot to set the filter for."
          },
          "item": {
            "name": "item",
            "type": "string or nil",
            "doc": "Prototype name of the item to filter, or nil to clear the filter."
          }
        }
      },
      "get_infinity_container_filter": {
        "name": "get_infinity_container_filter",
        "type": "function",
        "doc": "Gets the filter for this infinity container at the given index, or nil if the filter index doesn't exist or is empty.",
        "short": "Gets the filter for this infinity container at the given index, or nil if the filter index doesn't exist or is empty.",
        "member": "get_infinity_container_filter(index)  InfinityInventoryFilter?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index to get."
          }
        }
      },
      "set_infinity_container_filter": {
        "name": "set_infinity_container_filter",
        "doc": "Sets the filter for this infinity container at the given index.",
        "short": "Sets the filter for this infinity container at the given index.",
        "member": "set_infinity_container_filter(index, filter)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index to set."
          },
          "filter": {
            "name": "filter",
            "type": "InfinityInventoryFilter or nil",
            "doc": "The new filter, or nil to clear the filter."
          }
        }
      },
      "get_infinity_pipe_filter": {
        "name": "get_infinity_pipe_filter",
        "type": "function",
        "doc": "Gets the filter for this infinity pipe, or nil if the filter is empty.",
        "short": "Gets the filter for this infinity pipe, or nil if the filter is empty.",
        "member": "get_infinity_pipe_filter()  InfinityPipeFilter?"
      },
      "set_infinity_pipe_filter": {
        "name": "set_infinity_pipe_filter",
        "doc": "Sets the filter for this infinity pipe.",
        "short": "Sets the filter for this infinity pipe.",
        "member": "set_infinity_pipe_filter(filter)",
        "type": "function",
        "args": {
          "filter": {
            "name": "filter",
            "type": "InfinityPipeFilter or nil",
            "doc": "The new filter, or nil to clear the filter."
          }
        }
      },
      "get_heat_setting": {
        "name": "get_heat_setting",
        "type": "function",
        "doc": "Gets the heat setting for this heat interface.",
        "short": "Gets the heat setting for this heat interface.",
        "member": "get_heat_setting()  HeatSetting"
      },
      "set_heat_setting": {
        "name": "set_heat_setting",
        "doc": "Sets the heat setting for this heat interface.",
        "short": "Sets the heat setting for this heat interface.",
        "member": "set_heat_setting(filter)",
        "type": "function",
        "args": {
          "filter": {
            "name": "filter",
            "type": "HeatSetting",
            "doc": "The new setting."
          }
        }
      },
      "get_control_behavior": {
        "name": "get_control_behavior",
        "type": "function",
        "doc": "Gets the control behavior of the entity (if any). Returns: The control behavior or nil.",
        "short": "Gets the control behavior of the entity (if any).",
        "member": "get_control_behavior()  LuaControlBehavior?",
        "returns": "LuaControlBehavior?"
      },
      "get_or_create_control_behavior": {
        "name": "get_or_create_control_behavior",
        "type": "function",
        "doc": "Gets (and or creates if needed) the control behavior of the entity. Returns: The control behavior or nil.",
        "short": "Gets (and or creates if needed) the control behavior of the entity.",
        "member": "get_or_create_control_behavior()  LuaControlBehavior?",
        "returns": "LuaControlBehavior?"
      },
      "get_circuit_network": {
        "name": "get_circuit_network",
        "type": "function",
        "doc": "Wire color of the network connected to this entity. Returns: The circuit network or nil.",
        "member": "get_circuit_network(wire, circuit_connector?)  LuaCircuitNetwork?",
        "returns": "LuaCircuitNetwork?",
        "args": {
          "wire": {
            "name": "wire",
            "type": "defines.wire_type",
            "doc": "Wire color of the network connected to this entity."
          },
          "circuit_connector": {
            "name": "circuit_connector",
            "type": "defines.circuit_connector_id?",
            "doc": "The connector to get circuit network for. Must be specified for entities with more than one circuit network connector."
          }
        }
      },
      "get_merged_signal": {
        "name": "get_merged_signal",
        "type": "function",
        "doc": "Read a single signal from the combined circuit networks. Returns: The current value of the signal.",
        "short": "Read a single signal from the combined circuit networks.",
        "member": "get_merged_signal(signal, circuit_connector?)  int",
        "returns": "int",
        "args": {
          "signal": {
            "name": "signal",
            "type": "SignalID",
            "doc": "The signal to read."
          },
          "circuit_connector": {
            "name": "circuit_connector",
            "type": "defines.circuit_connector_id?",
            "doc": "The connector to get signals for. Must be specified for entities with more than one circuit network connector."
          }
        }
      },
      "get_merged_signals": {
        "name": "get_merged_signals",
        "type": "function",
        "doc": "The merged circuit network signals or nil if there are no signals. Returns: The sum of signals on both the red and green networks, or nil if it doesn't have a circuit connector.",
        "short": "The merged circuit network signals or nil if there are no signals.",
        "member": "get_merged_signals(circuit_connector?)  array[Signal]?",
        "returns": "array[Signal]?",
        "args": {
          "circuit_connector": {
            "name": "circuit_connector",
            "type": "defines.circuit_connector_id?",
            "doc": "The connector to get signals for. Must be specified for entities with more than one circuit network connector."
          }
        }
      },
      "supports_backer_name": {
        "name": "supports_backer_name",
        "type": "function",
        "doc": "Whether this entity supports a backer name.",
        "short": "Whether this entity supports a backer name.",
        "member": "supports_backer_name()  boolean"
      },
      "copy_settings": {
        "name": "copy_settings",
        "type": "function",
        "doc": "Copies settings from the given entity onto this entity. Returns: Any items removed from this entity as a result of copying the settings.",
        "short": "Copies settings from the given entity onto this entity.",
        "member": "copy_settings(entity, by_player?)  dictionary[string uint]",
        "returns": "dictionary[string uint]",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": ""
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If provided, the copying is done 'as' this player and on_entity_settings_pasted is triggered."
          }
        }
      },
      "get_logistic_point": {
        "name": "get_logistic_point",
        "type": "function",
        "doc": "Gets all the LuaLogisticPoints that this entity owns. Optionally returns only the point specified by the index parameter.",
        "short": "Gets all the LuaLogisticPoints that this entity owns. [...]",
        "member": "get_logistic_point(index?)  LuaLogisticPoint or dictionary[defines.logistic_member_index LuaLogisticPoint]?",
        "args": {
          "index": {
            "name": "index",
            "type": "defines.logistic_member_index?",
            "doc": "If provided, only returns the LuaLogisticPoint specified by this index."
          }
        }
      },
      "play_note": {
        "name": "play_note",
        "type": "function",
        "doc": "Plays a note with the given instrument and note. Returns: Whether the request is valid. The sound may or may not be played depending on polyphony settings.",
        "short": "Plays a note with the given instrument and note.",
        "member": "play_note(instrument, note)  boolean",
        "returns": "boolean",
        "args": {
          "instrument": {
            "name": "instrument",
            "type": "uint",
            "doc": ""
          },
          "note": {
            "name": "note",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "connect_rolling_stock": {
        "name": "connect_rolling_stock",
        "type": "function",
        "doc": "Connects the rolling stock in the given direction. Returns: Whether any connection was made",
        "short": "Connects the rolling stock in the given direction.",
        "member": "connect_rolling_stock(direction)  boolean",
        "returns": "boolean",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.rail_direction",
            "doc": ""
          }
        }
      },
      "disconnect_rolling_stock": {
        "name": "disconnect_rolling_stock",
        "type": "function",
        "doc": "Tries to disconnect this rolling stock in the given direction. Returns: If anything was disconnected",
        "short": "Tries to disconnect this rolling stock in the given direction.",
        "member": "disconnect_rolling_stock(direction)  boolean",
        "returns": "boolean",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.rail_direction",
            "doc": ""
          }
        }
      },
      "update_connections": {
        "name": "update_connections",
        "doc": "Reconnect loader, beacon, cliff and mining drill connections to entities that might have been teleported out or in by the script. The game doesn't do this automatically as we don't want to loose performance by checking this in normal games.",
        "short": "Reconnect loader, beacon, cliff and mining drill connections to entities that might have been teleported out or in by the script. [...]",
        "member": "update_connections()",
        "type": "function"
      },
      "get_recipe": {
        "name": "get_recipe",
        "type": "function",
        "doc": "Current recipe being assembled by this machine, if any.",
        "short": "Current recipe being assembled by this machine, if any.",
        "member": "get_recipe()  LuaRecipe?"
      },
      "set_recipe": {
        "name": "set_recipe",
        "type": "function",
        "doc": "Sets the given recipe in this assembly machine. Returns: Any items removed from this entity as a result of setting the recipe.",
        "short": "Sets the given recipe in this assembly machine.",
        "member": "set_recipe(recipe)  dictionary[string uint]",
        "returns": "dictionary[string uint]",
        "args": {
          "recipe": {
            "name": "recipe",
            "type": "string or LuaRecipe or nil",
            "doc": "The new recipe. Writing nil clears the recipe, if any."
          }
        }
      },
      "rotate": {
        "name": "rotate",
        "type": "boolean",
        "doc": "Rotates this entity as if the player rotated it. Returns: Count of spilled items indexed by their prototype names if spill_items was true.",
        "short": "Rotates this entity as if the player rotated it.",
        "member": "rotate{reverse?=, by_player?=, spill_items?=, enable_looted?=, force?=}  boolean, dictionary[string uint]?",
        "returns": "dictionary[string uint]?",
        "args": {
          "reverse": {
            "name": "reverse",
            "type": "boolean?",
            "doc": "If true, rotate the entity in the counter-clockwise direction."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If not specified, the on_player_rotated_entity event will not be fired."
          },
          "spill_items": {
            "name": "spill_items",
            "type": "boolean?",
            "doc": "If the player is not given should extra items be spilled or returned as a second return value from this."
          },
          "enable_looted": {
            "name": "enable_looted",
            "type": "boolean?",
            "doc": "When true, each spilled item will be flagged with the LuaEntity::to_be_looted flag."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "When provided the spilled items will be marked for deconstruction by this force."
          },
          "on_player_rotated_entity?": {
            "name": "on_player_rotated_entity?",
            "doc": "Raised if the by_player argument was given and the rotation was successful."
          }
        }
      },
      "get_driver": {
        "name": "get_driver",
        "type": "function",
        "doc": "Gets the driver of this vehicle if any. Returns: nil if the vehicle contains no driver. To check if there's a passenger see LuaEntity::get_passenger.",
        "short": "Gets the driver of this vehicle if any.",
        "member": "get_driver()  LuaEntity or LuaPlayer?",
        "returns": "LuaEntity or LuaPlayer?"
      },
      "set_driver": {
        "name": "set_driver",
        "doc": "Sets the driver of this vehicle.",
        "short": "Sets the driver of this vehicle.",
        "member": "set_driver(driver?)",
        "type": "function",
        "args": {
          "driver": {
            "name": "driver",
            "type": "LuaEntity or PlayerIdentification?",
            "doc": "The new driver. Writing nil ejects the current driver, if any."
          },
          "on_player_driving_changed_state?": {
            "name": "on_player_driving_changed_state?",
            "doc": ""
          }
        }
      },
      "get_passenger": {
        "name": "get_passenger",
        "type": "function",
        "doc": "Gets the passenger of this car or spidertron if any. Returns: nil if the vehicle contains no passenger. To check if there's a driver see LuaEntity::get_driver.",
        "short": "Gets the passenger of this car or spidertron if any.",
        "member": "get_passenger()  LuaEntity or LuaPlayer?",
        "returns": "LuaEntity or LuaPlayer?"
      },
      "set_passenger": {
        "name": "set_passenger",
        "doc": "Sets the passenger of this car or spidertron.",
        "short": "Sets the passenger of this car or spidertron.",
        "member": "set_passenger(passenger?)",
        "type": "function",
        "args": {
          "passenger": {
            "name": "passenger",
            "type": "LuaEntity or PlayerIdentification?",
            "doc": "The new passenger. Writing nil ejects the current passenger, if any."
          },
          "on_player_driving_changed_state?": {
            "name": "on_player_driving_changed_state?",
            "doc": ""
          }
        }
      },
      "is_connected_to_electric_network": {
        "name": "is_connected_to_electric_network",
        "type": "function",
        "doc": "Returns true if this entity produces or consumes electricity and is connected to an electric network that has at least one entity that can produce power.",
        "short": "Returns true if this entity produces or consumes electricity and is connected to an electric network that has at least one entity that can produce power.",
        "member": "is_connected_to_electric_network()  boolean"
      },
      "get_train_stop_trains": {
        "name": "get_train_stop_trains",
        "type": "function",
        "doc": "The trains scheduled to stop at this train stop.",
        "short": "The trains scheduled to stop at this train stop.",
        "member": "get_train_stop_trains()  array[LuaTrain]"
      },
      "get_stopped_train": {
        "name": "get_stopped_train",
        "type": "function",
        "doc": "The train currently stopped at this train stop, if any.",
        "short": "The train currently stopped at this train stop, if any.",
        "member": "get_stopped_train()  LuaTrain?"
      },
      "clone": {
        "name": "clone",
        "type": "LuaEntity",
        "doc": "Clones this entity. Returns: The cloned entity or nil if this entity can't be cloned/can't be cloned to the given location.",
        "short": "Clones this entity.",
        "member": "clone{position=, surface?=, force?=, create_build_effect_smoke?=}  LuaEntity?",
        "returns": "LuaEntity?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The destination position"
          },
          "surface": {
            "name": "surface",
            "type": "LuaSurface?",
            "doc": "The destination surface"
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": ""
          },
          "create_build_effect_smoke": {
            "name": "create_build_effect_smoke",
            "type": "boolean?",
            "doc": "If false, the building effect smoke will not be shown around the new entity."
          },
          "on_entity_cloned?": {
            "name": "on_entity_cloned?",
            "doc": "Raised if the entity was successfully cloned."
          }
        }
      },
      "get_fluid_count": {
        "name": "get_fluid_count",
        "type": "function",
        "doc": "Get the amount of all or some fluid in this entity.",
        "short": "Get the amount of all or some fluid in this entity.",
        "member": "get_fluid_count(fluid?)  double",
        "args": {
          "fluid": {
            "name": "fluid",
            "type": "string?",
            "doc": "Prototype name of the fluid to count. If not specified, count all fluids."
          }
        }
      },
      "get_fluid_contents": {
        "name": "get_fluid_contents",
        "type": "function",
        "doc": "Get amounts of all fluids in this entity. Returns: The amounts, indexed by fluid names.",
        "short": "Get amounts of all fluids in this entity.",
        "member": "get_fluid_contents()  dictionary[string double]",
        "returns": "dictionary[string double]"
      },
      "remove_fluid": {
        "name": "remove_fluid",
        "type": "double",
        "doc": "Remove fluid from this entity. Returns: Amount of fluid actually removed.",
        "short": "Remove fluid from this entity.",
        "member": "remove_fluid{name=, amount=, minimum_temperature?=, maximum_temperature?=, temperature?=}  double",
        "returns": "double",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Fluid prototype name."
          },
          "amount": {
            "name": "amount",
            "type": "double",
            "doc": "Amount to remove"
          },
          "minimum_temperature": {
            "name": "minimum_temperature",
            "type": "double?",
            "doc": ""
          },
          "maximum_temperature": {
            "name": "maximum_temperature",
            "type": "double?",
            "doc": ""
          },
          "temperature": {
            "name": "temperature",
            "type": "double?",
            "doc": ""
          }
        }
      },
      "insert_fluid": {
        "name": "insert_fluid",
        "type": "function",
        "doc": "Insert fluid into this entity. Fluidbox is chosen automatically. Returns: Amount of fluid actually inserted.",
        "short": "Insert fluid into this entity. [...]",
        "member": "insert_fluid(fluid)  double",
        "returns": "double",
        "args": {
          "fluid": {
            "name": "fluid",
            "type": "Fluid",
            "doc": "Fluid to insert."
          }
        }
      },
      "clear_fluid_inside": {
        "name": "clear_fluid_inside",
        "doc": "Remove all fluids from this entity.",
        "short": "Remove all fluids from this entity.",
        "member": "clear_fluid_inside()",
        "type": "function"
      },
      "get_beam_source": {
        "name": "get_beam_source",
        "type": "function",
        "doc": "Get the source of this beam.",
        "short": "Get the source of this beam.",
        "member": "get_beam_source()  BeamTarget?"
      },
      "set_beam_source": {
        "name": "set_beam_source",
        "doc": "Set the source of this beam.",
        "short": "Set the source of this beam.",
        "member": "set_beam_source(source)",
        "type": "function",
        "args": {
          "source": {
            "name": "source",
            "type": "LuaEntity or MapPosition",
            "doc": ""
          }
        }
      },
      "get_beam_target": {
        "name": "get_beam_target",
        "type": "function",
        "doc": "Get the target of this beam.",
        "short": "Get the target of this beam.",
        "member": "get_beam_target()  BeamTarget?"
      },
      "set_beam_target": {
        "name": "set_beam_target",
        "doc": "Set the target of this beam.",
        "short": "Set the target of this beam.",
        "member": "set_beam_target(target)",
        "type": "function",
        "args": {
          "target": {
            "name": "target",
            "type": "LuaEntity or MapPosition",
            "doc": ""
          }
        }
      },
      "get_radius": {
        "name": "get_radius",
        "type": "function",
        "doc": "The radius of this entity.",
        "short": "The radius of this entity.",
        "member": "get_radius()  double"
      },
      "get_health_ratio": {
        "name": "get_health_ratio",
        "type": "function",
        "doc": "The health ratio of this entity between 1 and 0 (for full health and no health respectively). Returns: nil if this entity doesn't have health.",
        "short": "The health ratio of this entity between 1 and 0 (for full health and no health respectively).",
        "member": "get_health_ratio()  float?",
        "returns": "float?"
      },
      "create_build_effect_smoke": {
        "name": "create_build_effect_smoke",
        "doc": "Creates the same smoke that is created when you place a building by hand. You can play the building sound to go with it by using LuaSurface::play_sound, eg: entity.surface.play_sound{path=\"entity-build/\"..entity.prototype.name, position=entity.position}",
        "short": "Creates the same smoke that is created when you place a building by hand. [...]",
        "member": "create_build_effect_smoke()",
        "type": "function"
      },
      "release_from_spawner": {
        "name": "release_from_spawner",
        "doc": "Release the unit from the spawner which spawned it. This allows the spawner to continue spawning additional units.",
        "short": "Release the unit from the spawner which spawned it. [...]",
        "member": "release_from_spawner()",
        "type": "function"
      },
      "toggle_equipment_movement_bonus": {
        "name": "toggle_equipment_movement_bonus",
        "doc": "Toggle this entity's equipment movement bonus. Does nothing if the entity does not have an equipment grid.",
        "short": "Toggle this entity's equipment movement bonus. [...]",
        "member": "toggle_equipment_movement_bonus()",
        "type": "function"
      },
      "can_shoot": {
        "name": "can_shoot",
        "type": "function",
        "doc": "Whether this character can shoot the given entity or position.",
        "short": "Whether this character can shoot the given entity or position.",
        "member": "can_shoot(target, position)  boolean",
        "args": {
          "target": {
            "name": "target",
            "type": "LuaEntity",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          }
        }
      },
      "start_fading_out": {
        "name": "start_fading_out",
        "doc": "Only works if the entity is a speech-bubble, with an \"effect\" defined in its wrapper_flow_style. Starts animating the opacity of the speech bubble towards zero, and destroys the entity when it hits zero.",
        "short": "Only works if the entity is a speech-bubble, with an \"effect\" defined in its wrapper_flow_style. [...]",
        "member": "start_fading_out()",
        "type": "function"
      },
      "get_upgrade_target": {
        "name": "get_upgrade_target",
        "type": "function",
        "doc": "Returns the new entity prototype. Returns: nil if this entity is not marked for upgrade.",
        "short": "Returns the new entity prototype.",
        "member": "get_upgrade_target()  LuaEntityPrototype?",
        "returns": "LuaEntityPrototype?"
      },
      "get_upgrade_direction": {
        "name": "get_upgrade_direction",
        "type": "function",
        "doc": "Returns the new entity direction after upgrading. Returns: nil if this entity is not marked for upgrade.",
        "short": "Returns the new entity direction after upgrading.",
        "member": "get_upgrade_direction()  defines.direction?",
        "returns": "defines.direction?"
      },
      "get_damage_to_be_taken": {
        "name": "get_damage_to_be_taken",
        "type": "function",
        "doc": "Returns the amount of damage to be taken by this entity. Returns: nil if this entity does not have health.",
        "short": "Returns the amount of damage to be taken by this entity.",
        "member": "get_damage_to_be_taken()  float?",
        "returns": "float?"
      },
      "deplete": {
        "name": "deplete",
        "doc": "Depletes and destroys this resource entity.",
        "short": "Depletes and destroys this resource entity.",
        "member": "deplete()",
        "type": "function",
        "args": {
          "on_resource_depleted": {
            "name": "on_resource_depleted",
            "doc": ""
          }
        }
      },
      "mine": {
        "name": "mine",
        "type": "boolean",
        "doc": "Mines this entity. Returns: Whether mining succeeded.",
        "short": "Mines this entity.",
        "member": "mine{inventory?=, force?=, raise_destroyed?=, ignore_minable?=}  boolean",
        "returns": "boolean",
        "args": {
          "inventory": {
            "name": "inventory",
            "type": "LuaInventory?",
            "doc": "If provided the item(s) will be transferred into this inventory. If provided, this must be an inventory created with LuaGameScript::create_inventory or be a basic inventory owned by some entity."
          },
          "force": {
            "name": "force",
            "type": "boolean?",
            "doc": "If true, when the item(s) don't fit into the given inventory the entity is force mined. If false, the mining operation fails when there isn't enough room to transfer all of the items into the inventory. Defaults to false. This is ignored and acts as true if no inventory is provided."
          },
          "raise_destroyed": {
            "name": "raise_destroyed",
            "type": "boolean?",
            "doc": "If true, script_raised_destroy will be raised. Defaults to true."
          },
          "ignore_minable": {
            "name": "ignore_minable",
            "type": "boolean?",
            "doc": "If true, the minable state of the entity is ignored. Defaults to false. If false, an entity that isn't minable (set as not-minable in the prototype or isn't minable for other reasons) will fail to be mined."
          },
          "script_raised_destroy?": {
            "name": "script_raised_destroy?",
            "doc": "Raised if the raise_destroyed flag was set and the entity was successfully mined."
          }
        }
      },
      "spawn_decorations": {
        "name": "spawn_decorations",
        "doc": "Triggers spawn_decoration actions defined in the entity prototype or does nothing if entity is not \"turret\" or \"unit-spawner\".",
        "short": "Triggers spawn_decoration actions defined in the entity prototype or does nothing if entity is not \"turret\" or \"unit-spawner\".",
        "member": "spawn_decorations()",
        "type": "function"
      },
      "can_wires_reach": {
        "name": "can_wires_reach",
        "type": "function",
        "doc": "Can wires reach between these entities.",
        "short": "Can wires reach between these entities.",
        "member": "can_wires_reach(entity)  boolean",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": ""
          }
        }
      },
      "get_connected_rolling_stock": {
        "name": "get_connected_rolling_stock",
        "type": "function",
        "doc": "Gets rolling stock connected to the given end of this stock. Returns: The rail direction of the connected rolling stock if any.",
        "short": "Gets rolling stock connected to the given end of this stock.",
        "member": "get_connected_rolling_stock(direction)  LuaEntity?, defines.rail_direction?",
        "returns": "defines.rail_direction?",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.rail_direction",
            "doc": ""
          }
        }
      },
      "is_registered_for_construction": {
        "name": "is_registered_for_construction",
        "type": "function",
        "doc": "Is this entity or tile ghost or item request proxy registered for construction? If false, it means a construction robot has been dispatched to build the entity, or it is not an entity that can be constructed.",
        "short": "Is this entity or tile ghost or item request proxy registered for construction? [...]",
        "member": "is_registered_for_construction()  boolean"
      },
      "is_registered_for_deconstruction": {
        "name": "is_registered_for_deconstruction",
        "type": "function",
        "doc": "Is this entity registered for deconstruction with this force? If false, it means a construction robot has been dispatched to deconstruct it, or it is not marked for deconstruction. The complexity is effectively O(1) - it depends on the number of objects targeting this entity which should be small enough.",
        "short": "Is this entity registered for deconstruction with this force? [...]",
        "member": "is_registered_for_deconstruction(force)  boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force construction manager to check."
          }
        }
      },
      "is_registered_for_upgrade": {
        "name": "is_registered_for_upgrade",
        "type": "function",
        "doc": "Is this entity registered for upgrade? If false, it means a construction robot has been dispatched to upgrade it, or it is not marked for upgrade. This is worst-case O(N) complexity where N is the current number of things in the upgrade queue.",
        "short": "Is this entity registered for upgrade? [...]",
        "member": "is_registered_for_upgrade()  boolean"
      },
      "is_registered_for_repair": {
        "name": "is_registered_for_repair",
        "type": "function",
        "doc": "Is this entity registered for repair? If false, it means a construction robot has been dispatched to upgrade it, or it is not damaged. This is worst-case O(N) complexity where N is the current number of things in the repair queue.",
        "short": "Is this entity registered for repair? [...]",
        "member": "is_registered_for_repair()  boolean"
      },
      "add_autopilot_destination": {
        "name": "add_autopilot_destination",
        "doc": "Adds the given position to this spidertron's autopilot's queue of destinations.",
        "short": "Adds the given position to this spidertron's autopilot's queue of destinations.",
        "member": "add_autopilot_destination(position)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position the spidertron should move to."
          }
        }
      },
      "connect_linked_belts": {
        "name": "connect_linked_belts",
        "doc": "Connects current linked belt with another one.",
        "short": "Connects current linked belt with another one. [...]",
        "member": "connect_linked_belts(neighbour)",
        "type": "function",
        "args": {
          "neighbour": {
            "name": "neighbour",
            "type": "LuaEntity",
            "doc": "Another linked belt or entity ghost containing linked belt to connect or nil to disconnect"
          }
        }
      },
      "disconnect_linked_belts": {
        "name": "disconnect_linked_belts",
        "doc": "Disconnects linked belt from its neighbour.",
        "short": "Disconnects linked belt from its neighbour.",
        "member": "disconnect_linked_belts()",
        "type": "function"
      },
      "get_spider_legs": {
        "name": "get_spider_legs",
        "type": "function",
        "doc": "Gets legs of given SpiderVehicle.",
        "short": "Gets legs of given SpiderVehicle.",
        "member": "get_spider_legs()  array[LuaEntity]"
      },
      "stop_spider": {
        "name": "stop_spider",
        "doc": "Sets the speed of the given SpiderVehicle to zero. Notably does not clear its autopilot_destination, which it will continue moving towards if set.",
        "short": "Sets the speed of the given SpiderVehicle to zero. [...]",
        "member": "stop_spider()",
        "type": "function"
      },
      "get_beacons": {
        "name": "get_beacons",
        "type": "function",
        "doc": "Returns a table with all beacons affecting this effect receiver. Can only be used when the entity has an effect receiver (AssemblingMachine, Furnace, Lab, MiningDrills)",
        "short": "Returns a table with all beacons affecting this effect receiver. [...]",
        "member": "get_beacons()  array[LuaEntity]?"
      },
      "get_beacon_effect_receivers": {
        "name": "get_beacon_effect_receivers",
        "type": "function",
        "doc": "Returns a table with all entities affected by this beacon",
        "short": "Returns a table with all entities affected by this beacon",
        "member": "get_beacon_effect_receivers()  array[LuaEntity]"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the entity prototype. E.g. \"inserter\" or \"filter-inserter\".",
        "short": "Name of the entity prototype. [...]",
        "member": "name  ::string Read"
      },
      "ghost_name": {
        "name": "ghost_name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the entity or tile contained in this ghost",
        "short": "Name of the entity or tile contained in this ghost",
        "member": "ghost_name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of the entity.",
        "short": "Localised name of the entity.",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "ghost_localised_name": {
        "name": "ghost_localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of the entity or tile contained in this ghost.",
        "short": "Localised name of the entity or tile contained in this ghost.",
        "member": "ghost_localised_name  ::LocalisedString Read"
      },
      "ghost_localised_description": {
        "name": "ghost_localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "ghost_localised_description  ::LocalisedString Read"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "The entity prototype type of this entity.",
        "short": "The entity prototype type of this entity.",
        "member": "type  ::string Read"
      },
      "ghost_type": {
        "name": "ghost_type",
        "type": "string",
        "mode": "[R]",
        "doc": "The prototype type of the entity or tile contained in this ghost.",
        "short": "The prototype type of the entity or tile contained in this ghost.",
        "member": "ghost_type  ::string Read"
      },
      "active": {
        "name": "active",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Deactivating an entity will stop all its operations (car will stop moving, inserters will stop working, fish will stop moving etc).",
        "short": "Deactivating an entity will stop all its operations (car will stop moving, inserters will stop working, fish will stop moving etc).",
        "member": "active  ::boolean Read/Write"
      },
      "destructible": {
        "name": "destructible",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If set to false, this entity can't be damaged and won't be attacked automatically. It can however still be mined.",
        "short": "If set to false, this entity can't be damaged and won't be attacked automatically. [...]",
        "member": "destructible  ::boolean Read/Write"
      },
      "minable": {
        "name": "minable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Not minable entities can still be destroyed.",
        "member": "minable  ::boolean Read/Write"
      },
      "rotatable": {
        "name": "rotatable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "When entity is not to be rotatable (inserter, transport belt etc), it can't be rotated by player using the R key.",
        "short": "When entity is not to be rotatable (inserter, transport belt etc), it can't be rotated by player using the R key.",
        "member": "rotatable  ::boolean Read/Write"
      },
      "operable": {
        "name": "operable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Player can't open gui of this entity and he can't quick insert/input stuff in to the entity when it is not operable.",
        "short": "Player can't open gui of this entity and he can't quick insert/input stuff in to the entity when it is not operable.",
        "member": "operable  ::boolean Read/Write"
      },
      "health": {
        "name": "health",
        "type": "float",
        "mode": "[RW]",
        "doc": "The current health of the entity, if any. Health is automatically clamped to be between 0 and max health (inclusive). Entities with a health of 0 can not be attacked.",
        "short": "The current health of the entity, if any. [...]",
        "member": "health  ::float? Read/Write"
      },
      "direction": {
        "name": "direction",
        "type": "defines.direction",
        "mode": "[RW]",
        "doc": "The current direction this entity is facing.",
        "short": "The current direction this entity is facing.",
        "member": "direction  ::defines.direction Read/Write"
      },
      "supports_direction": {
        "name": "supports_direction",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether the entity has direction. When it is false for this entity, it will always return north direction when asked for.",
        "short": "Whether the entity has direction. [...]",
        "member": "supports_direction  ::boolean Read"
      },
      "orientation": {
        "name": "orientation",
        "type": "RealOrientation",
        "mode": "[RW]",
        "doc": "The smooth orientation of this entity.",
        "short": "The smooth orientation of this entity.",
        "member": "orientation  ::RealOrientation Read/Write"
      },
      "cliff_orientation": {
        "name": "cliff_orientation",
        "type": "CliffOrientation",
        "mode": "[R]",
        "doc": "The orientation of this cliff.",
        "short": "The orientation of this cliff.",
        "member": "cliff_orientation  ::CliffOrientation Read"
      },
      "relative_turret_orientation": {
        "name": "relative_turret_orientation",
        "type": "RealOrientation",
        "mode": "[RW]",
        "doc": "The relative orientation of the vehicle turret, artillery turret, artillery wagon. nil if this entity isn't a vehicle with a vehicle turret or artillery turret/wagon.",
        "short": "The relative orientation of the vehicle turret, artillery turret, artillery wagon. [...]",
        "member": "relative_turret_orientation  ::RealOrientation? Read/Write"
      },
      "torso_orientation": {
        "name": "torso_orientation",
        "type": "RealOrientation",
        "mode": "[RW]",
        "doc": "The torso orientation of this spider vehicle.",
        "short": "The torso orientation of this spider vehicle.",
        "member": "torso_orientation  ::RealOrientation Read/Write"
      },
      "amount": {
        "name": "amount",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Count of resource units contained.",
        "short": "Count of resource units contained.",
        "member": "amount  ::uint Read/Write"
      },
      "initial_amount": {
        "name": "initial_amount",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Count of initial resource units contained. nil if this is not an infinite resource.",
        "short": "Count of initial resource units contained. [...]",
        "member": "initial_amount  ::uint? Read/Write"
      },
      "effectivity_modifier": {
        "name": "effectivity_modifier",
        "type": "float",
        "mode": "[RW]",
        "doc": "Multiplies the acceleration the vehicle can create for one unit of energy. Defaults to 1.",
        "short": "Multiplies the acceleration the vehicle can create for one unit of energy. [...]",
        "member": "effectivity_modifier  ::float Read/Write"
      },
      "consumption_modifier": {
        "name": "consumption_modifier",
        "type": "float",
        "mode": "[RW]",
        "doc": "Multiplies the energy consumption.",
        "short": "Multiplies the energy consumption.",
        "member": "consumption_modifier  ::float Read/Write"
      },
      "friction_modifier": {
        "name": "friction_modifier",
        "type": "float",
        "mode": "[RW]",
        "doc": "Multiplies the car friction rate.",
        "short": "Multiplies the car friction rate.",
        "member": "friction_modifier  ::float Read/Write"
      },
      "driver_is_gunner": {
        "name": "driver_is_gunner",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the driver of this car or spidertron is the gunner. If false, the passenger is the gunner. nil if this is neither a car or a spidertron.",
        "short": "Whether the driver of this car or spidertron is the gunner. [...]",
        "member": "driver_is_gunner  ::boolean? Read/Write"
      },
      "vehicle_automatic_targeting_parameters": {
        "name": "vehicle_automatic_targeting_parameters",
        "type": "VehicleAutomaticTargetingParameters",
        "mode": "[RW]",
        "doc": "Read when this spidertron auto-targets enemies",
        "short": "Read when this spidertron auto-targets enemies",
        "member": "vehicle_automatic_targeting_parameters  ::VehicleAutomaticTargetingParameters Read/Write"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[RW]",
        "doc": "The current speed if this is a car, rolling stock, projectile or spidertron, or the maximum speed if this is a unit. The speed is in tiles per tick. nil if this is not a car, rolling stock, unit, projectile or spidertron.",
        "short": "The current speed if this is a car, rolling stock, projectile or spidertron, or the maximum speed if this is a unit. [...]",
        "member": "speed  ::float? Read/Write"
      },
      "effective_speed": {
        "name": "effective_speed",
        "type": "float",
        "mode": "[R]",
        "doc": "The current speed of this unit in tiles per tick, taking into account any walking speed modifier given by the tile the unit is standing on. nil if this is not a unit.",
        "short": "The current speed of this unit in tiles per tick, taking into account any walking speed modifier given by the tile the unit is standing on. [...]",
        "member": "effective_speed  ::float? Read"
      },
      "stack": {
        "name": "stack",
        "type": "LuaItemStack",
        "mode": "[R]",
        "member": "stack  ::LuaItemStack Read"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The entity prototype of this entity.",
        "short": "The entity prototype of this entity.",
        "member": "prototype  ::LuaEntityPrototype Read"
      },
      "ghost_prototype": {
        "name": "ghost_prototype",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The prototype of the entity or tile contained in this ghost.",
        "short": "The prototype of the entity or tile contained in this ghost.",
        "member": "ghost_prototype  ::LuaEntityPrototype or LuaTilePrototype Read"
      },
      "drop_position": {
        "name": "drop_position",
        "type": "MapPosition",
        "mode": "[RW]",
        "doc": "Position where the entity puts its stuff.",
        "short": "Position where the entity puts its stuff.",
        "member": "drop_position  ::MapPosition Read/Write"
      },
      "pickup_position": {
        "name": "pickup_position",
        "type": "MapPosition",
        "mode": "[RW]",
        "doc": "Where the inserter will pick up items from.",
        "short": "Where the inserter will pick up items from.",
        "member": "pickup_position  ::MapPosition Read/Write"
      },
      "drop_target": {
        "name": "drop_target",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The entity this entity is putting its items to. If there are multiple possible entities at the drop-off point, writing to this attribute allows a mod to choose which one to drop off items to. The entity needs to collide with the tile box under the drop-off position. nil if there is no entity to put items to, or if this is not an entity that puts items somewhere.",
        "short": "The entity this entity is putting its items to. [...]",
        "member": "drop_target  ::LuaEntity? Read/Write"
      },
      "pickup_target": {
        "name": "pickup_target",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The entity this inserter will attempt to pick up items from. If there are multiple possible entities at the pick-up point, writing to this attribute allows a mod to choose which one to pick up items from. The entity needs to collide with the tile box under the pick-up position. nil if there is no entity to pull items from.",
        "short": "The entity this inserter will attempt to pick up items from. [...]",
        "member": "pickup_target  ::LuaEntity? Read/Write"
      },
      "selected_gun_index": {
        "name": "selected_gun_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Index of the currently selected weapon slot of this character, car, or spidertron. nil if this entity doesn't have guns.",
        "short": "Index of the currently selected weapon slot of this character, car, or spidertron. [...]",
        "member": "selected_gun_index  ::uint? Read/Write"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[RW]",
        "doc": "Energy stored in the entity (heat in furnace, energy stored in electrical devices etc.). always 0 for entities that don't have the concept of energy stored inside.",
        "short": "Energy stored in the entity (heat in furnace, energy stored in electrical devices etc.). [...]",
        "member": "energy  ::double Read/Write"
      },
      "temperature": {
        "name": "temperature",
        "type": "double",
        "mode": "[RW]",
        "doc": "The temperature of this entity's heat energy source. nil if this entity does not use a heat energy source.",
        "short": "The temperature of this entity's heat energy source. [...]",
        "member": "temperature  ::double? Read/Write"
      },
      "previous_recipe": {
        "name": "previous_recipe",
        "type": "LuaRecipe",
        "mode": "[R]",
        "doc": "The previous recipe this furnace was using, if any.",
        "short": "The previous recipe this furnace was using, if any.",
        "member": "previous_recipe  ::LuaRecipe? Read"
      },
      "held_stack": {
        "name": "held_stack",
        "type": "LuaItemStack",
        "mode": "[R]",
        "doc": "The item stack currently held in an inserter's hand.",
        "short": "The item stack currently held in an inserter's hand.",
        "member": "held_stack  ::LuaItemStack Read"
      },
      "held_stack_position": {
        "name": "held_stack_position",
        "type": "MapPosition",
        "mode": "[R]",
        "doc": "Current position of the inserter's \"hand\".",
        "short": "Current position of the inserter's \"hand\".",
        "member": "held_stack_position  ::MapPosition Read"
      },
      "train": {
        "name": "train",
        "type": "LuaTrain",
        "mode": "[R]",
        "doc": "The train this rolling stock belongs to, if any. nil if this is not a rolling stock.",
        "short": "The train this rolling stock belongs to, if any. [...]",
        "member": "train  ::LuaTrain? Read"
      },
      "neighbours": {
        "name": "neighbours",
        "type": "string",
        "mode": "[R]",
        "doc": "A list of neighbours for certain types of entities. Applies to electric poles, power switches, underground belts, walls, gates, reactors, cliffs, and pipe-connectable entities.",
        "short": "A list of neighbours for certain types of entities. [...]",
        "member": "neighbours  ::dictionary[string array[LuaEntity]] or array[array[LuaEntity]] or LuaEntity Read"
      },
      "belt_neighbours": {
        "name": "belt_neighbours",
        "mode": "[R]",
        "doc": "The belt connectable neighbours of this belt connectable entity. Only entities that input to or are outputs of this entity. Does not contain the other end of an underground belt, see LuaEntity::neighbours for that.",
        "short": "The belt connectable neighbours of this belt connectable entity. [...]",
        "member": "belt_neighbours  ::table Read",
        "args": {
          "inputs": {
            "name": "inputs",
            "type": "array[LuaEntity]",
            "doc": "Array of transport belt connectable entities."
          },
          "outputs": {
            "name": "outputs",
            "type": "array[LuaEntity]",
            "doc": "Array of transport belt connectable entities."
          }
        }
      },
      "fluidbox": {
        "name": "fluidbox",
        "type": "LuaFluidBox",
        "mode": "[RW]",
        "doc": "Fluidboxes of this entity.",
        "short": "Fluidboxes of this entity.",
        "member": "fluidbox  ::LuaFluidBox Read/Write"
      },
      "backer_name": {
        "name": "backer_name",
        "type": "string",
        "mode": "[RW]",
        "doc": "The backer name assigned to this entity. Entities that support backer names are labs, locomotives, radars, roboports, and train stops. nil if this entity doesn't support backer names.",
        "short": "The backer name assigned to this entity. [...]",
        "member": "backer_name  ::string? Read/Write",
        "args": {
          "on_entity_renamed": {
            "name": "on_entity_renamed",
            "doc": ""
          }
        }
      },
      "entity_label": {
        "name": "entity_label",
        "type": "string",
        "mode": "[RW]",
        "doc": "The label on this spider-vehicle entity, if any. nil if this is not a spider-vehicle.",
        "short": "The label on this spider-vehicle entity, if any. [...]",
        "member": "entity_label  ::string? Read/Write",
        "args": {
          "on_entity_renamed": {
            "name": "on_entity_renamed",
            "doc": ""
          }
        }
      },
      "time_to_live": {
        "name": "time_to_live",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The ticks left before a ghost, combat robot, highlight box, smoke with trigger or sticker is destroyed.",
        "short": "The ticks left before a ghost, combat robot, highlight box, smoke with trigger or sticker is destroyed. [...]",
        "member": "time_to_live  ::uint Read/Write"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[RW]",
        "doc": "The color of this character, rolling stock, train stop, car, spider-vehicle, flying text, corpse or simple-entity-with-owner. nil if this entity doesn't use custom colors.",
        "short": "The color of this character, rolling stock, train stop, car, spider-vehicle, flying text, corpse or simple-entity-with-owner. [...]",
        "member": "color  ::Color? Read/Write"
      },
      "text": {
        "name": "text",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The text of this flying-text entity.",
        "short": "The text of this flying-text entity.",
        "member": "text  ::LocalisedString Read/Write"
      },
      "signal_state": {
        "name": "signal_state",
        "type": "defines.signal_state",
        "mode": "[R]",
        "doc": "The state of this rail signal.",
        "short": "The state of this rail signal.",
        "member": "signal_state  ::defines.signal_state Read"
      },
      "chain_signal_state": {
        "name": "chain_signal_state",
        "type": "defines.chain_signal_state",
        "mode": "[R]",
        "doc": "The state of this chain signal.",
        "short": "The state of this chain signal.",
        "member": "chain_signal_state  ::defines.chain_signal_state Read"
      },
      "to_be_looted": {
        "name": "to_be_looted",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Will this entity be picked up automatically when the player walks over it?",
        "short": "Will this entity be picked up automatically when the player walks over it?",
        "member": "to_be_looted  ::boolean Read/Write"
      },
      "crafting_speed": {
        "name": "crafting_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The current crafting speed, including speed bonuses from modules and beacons.",
        "short": "The current crafting speed, including speed bonuses from modules and beacons.",
        "member": "crafting_speed  ::double Read"
      },
      "crafting_progress": {
        "name": "crafting_progress",
        "type": "float",
        "mode": "[RW]",
        "doc": "The current crafting progress, as a number in range [0, 1].",
        "short": "The current crafting progress, as a number in range [0, 1].",
        "member": "crafting_progress  ::float Read/Write"
      },
      "bonus_progress": {
        "name": "bonus_progress",
        "type": "double",
        "mode": "[RW]",
        "doc": "The current productivity bonus progress, as a number in range [0, 1].",
        "short": "The current productivity bonus progress, as a number in range [0, 1].",
        "member": "bonus_progress  ::double Read/Write"
      },
      "productivity_bonus": {
        "name": "productivity_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "The productivity bonus of this entity.",
        "short": "The productivity bonus of this entity.",
        "member": "productivity_bonus  ::double Read"
      },
      "pollution_bonus": {
        "name": "pollution_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "The pollution bonus of this entity.",
        "short": "The pollution bonus of this entity.",
        "member": "pollution_bonus  ::double Read"
      },
      "speed_bonus": {
        "name": "speed_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "The speed bonus of this entity.",
        "short": "The speed bonus of this entity.",
        "member": "speed_bonus  ::double Read"
      },
      "consumption_bonus": {
        "name": "consumption_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "The consumption bonus of this entity.",
        "short": "The consumption bonus of this entity.",
        "member": "consumption_bonus  ::double Read"
      },
      "belt_to_ground_type": {
        "name": "belt_to_ground_type",
        "mode": "[R]",
        "doc": "Whether this underground belt goes into or out of the ground.",
        "short": "Whether this underground belt goes into or out of the ground.",
        "member": "belt_to_ground_type  ::\"input\" or \"output\" Read"
      },
      "loader_type": {
        "name": "loader_type",
        "mode": "[RW]",
        "doc": "Whether this loader gets items from or puts item into a container.",
        "short": "Whether this loader gets items from or puts item into a container.",
        "member": "loader_type  ::\"input\" or \"output\" Read/Write"
      },
      "rocket_parts": {
        "name": "rocket_parts",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Number of rocket parts in the silo.",
        "short": "Number of rocket parts in the silo.",
        "member": "rocket_parts  ::uint Read/Write"
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[RW]",
        "doc": "The logistic network this entity is a part of, or nil if this entity is not a part of any logistic network.",
        "short": "The logistic network this entity is a part of, or nil if this entity is not a part of any logistic network.",
        "member": "logistic_network  ::LuaLogisticNetwork Read/Write"
      },
      "logistic_cell": {
        "name": "logistic_cell",
        "type": "LuaLogisticCell",
        "mode": "[R]",
        "doc": "The logistic cell this entity is a part of. Will be nil if this entity is not a part of any logistic cell.",
        "short": "The logistic cell this entity is a part of. [...]",
        "member": "logistic_cell  ::LuaLogisticCell Read"
      },
      "item_requests": {
        "name": "item_requests",
        "type": "string",
        "mode": "[RW]",
        "doc": "Items this ghost will request when revived or items this item request proxy is requesting. Result is a dictionary mapping each item prototype name to the required count.",
        "short": "Items this ghost will request when revived or items this item request proxy is requesting. [...]",
        "member": "item_requests  ::dictionary[string uint] Read/Write"
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The player connected to this character, if any.",
        "short": "The player connected to this character, if any.",
        "member": "player  ::LuaPlayer? Read"
      },
      "unit_group": {
        "name": "unit_group",
        "type": "LuaUnitGroup",
        "mode": "[R]",
        "doc": "The unit group this unit is a member of, if any.",
        "short": "The unit group this unit is a member of, if any.",
        "member": "unit_group  ::LuaUnitGroup? Read"
      },
      "damage_dealt": {
        "name": "damage_dealt",
        "type": "double",
        "mode": "[RW]",
        "doc": "The damage dealt by this turret, artillery turret, or artillery wagon.",
        "short": "The damage dealt by this turret, artillery turret, or artillery wagon.",
        "member": "damage_dealt  ::double Read/Write"
      },
      "kills": {
        "name": "kills",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The number of units killed by this turret, artillery turret, or artillery wagon.",
        "short": "The number of units killed by this turret, artillery turret, or artillery wagon.",
        "member": "kills  ::uint Read/Write"
      },
      "last_user": {
        "name": "last_user",
        "type": "LuaPlayer",
        "mode": "[RW]",
        "doc": "The last player that changed any setting on this entity. This includes building the entity, changing its color, or configuring its circuit network. nil if the last user is not part of the save anymore.",
        "short": "The last player that changed any setting on this entity. [...]",
        "member": "last_user  ::LuaPlayer or PlayerIdentification? Read/Write"
      },
      "electric_buffer_size": {
        "name": "electric_buffer_size",
        "type": "double",
        "mode": "[RW]",
        "doc": "The buffer size for the electric energy source. nil if the entity doesn't have an electric energy source.",
        "short": "The buffer size for the electric energy source. [...]",
        "member": "electric_buffer_size  ::double? Read/Write"
      },
      "electric_input_flow_limit": {
        "name": "electric_input_flow_limit",
        "type": "double",
        "mode": "[R]",
        "doc": "The input flow limit for the electric energy source. nil if the entity doesn't have an electric energy source.",
        "short": "The input flow limit for the electric energy source. [...]",
        "member": "electric_input_flow_limit  ::double? Read"
      },
      "electric_output_flow_limit": {
        "name": "electric_output_flow_limit",
        "type": "double",
        "mode": "[R]",
        "doc": "The output flow limit for the electric energy source. nil if the entity doesn't have an electric energy source.",
        "short": "The output flow limit for the electric energy source. [...]",
        "member": "electric_output_flow_limit  ::double? Read"
      },
      "electric_drain": {
        "name": "electric_drain",
        "type": "double",
        "mode": "[R]",
        "doc": "The electric drain for the electric energy source. nil if the entity doesn't have an electric energy source.",
        "short": "The electric drain for the electric energy source. [...]",
        "member": "electric_drain  ::double? Read"
      },
      "electric_emissions": {
        "name": "electric_emissions",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions for the electric energy source. nil if the entity doesn't have an electric energy source.",
        "short": "The emissions for the electric energy source. [...]",
        "member": "electric_emissions  ::double? Read"
      },
      "unit_number": {
        "name": "unit_number",
        "type": "uint",
        "mode": "[R]",
        "doc": "A unique number identifying this entity for the lifetime of the save. These are allocated sequentially, and not re-used (until overflow).",
        "short": "A unique number identifying this entity for the lifetime of the save. [...]",
        "member": "unit_number  ::uint? Read"
      },
      "ghost_unit_number": {
        "name": "ghost_unit_number",
        "type": "uint",
        "mode": "[R]",
        "doc": "The unit_number of the entity contained in this ghost. It is the same as the unit number of the EntityWithOwnerPrototype that was destroyed to create this ghost. If it was created by other means, or if the inner entity does not support unit numbers, this property is nil.",
        "short": "The unit_number of the entity contained in this ghost. [...]",
        "member": "ghost_unit_number  ::uint? Read"
      },
      "mining_progress": {
        "name": "mining_progress",
        "type": "double",
        "mode": "[RW]",
        "doc": "The mining progress for this mining drill. Is a number in range [0, mining_target.prototype.mineable_properties.mining_time]. nil if this isn't a mining drill.",
        "short": "The mining progress for this mining drill. [...]",
        "member": "mining_progress  ::double? Read/Write"
      },
      "bonus_mining_progress": {
        "name": "bonus_mining_progress",
        "type": "double",
        "mode": "[RW]",
        "doc": "The bonus mining progress for this mining drill. Read yields a number in range [0, mining_target.prototype.mineable_properties.mining_time]. nil if this isn't a mining drill.",
        "short": "The bonus mining progress for this mining drill. [...]",
        "member": "bonus_mining_progress  ::double? Read/Write"
      },
      "power_production": {
        "name": "power_production",
        "type": "double",
        "mode": "[RW]",
        "doc": "The power production specific to the ElectricEnergyInterface entity type.",
        "short": "The power production specific to the ElectricEnergyInterface entity type.",
        "member": "power_production  ::double Read/Write"
      },
      "power_usage": {
        "name": "power_usage",
        "type": "double",
        "mode": "[RW]",
        "doc": "The power usage specific to the ElectricEnergyInterface entity type.",
        "short": "The power usage specific to the ElectricEnergyInterface entity type.",
        "member": "power_usage  ::double Read/Write"
      },
      "bounding_box": {
        "name": "bounding_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "LuaEntityPrototype::collision_box around entity's given position and respecting the current entity orientation.",
        "short": "LuaEntityPrototype::collision_box around entity's given position and respecting the current entity orientation.",
        "member": "bounding_box  ::BoundingBox Read"
      },
      "secondary_bounding_box": {
        "name": "secondary_bounding_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The secondary bounding box of this entity or nil if it doesn't have one. This only exists for curved rails, and is automatically determined by the game.",
        "short": "The secondary bounding box of this entity or nil if it doesn't have one. [...]",
        "member": "secondary_bounding_box  ::BoundingBox? Read"
      },
      "selection_box": {
        "name": "selection_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "LuaEntityPrototype::selection_box around entity's given position and respecting the current entity orientation.",
        "short": "LuaEntityPrototype::selection_box around entity's given position and respecting the current entity orientation.",
        "member": "selection_box  ::BoundingBox Read"
      },
      "secondary_selection_box": {
        "name": "secondary_selection_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The secondary selection box of this entity or nil if it doesn't have one. This only exists for curved rails, and is automatically determined by the game.",
        "short": "The secondary selection box of this entity or nil if it doesn't have one. [...]",
        "member": "secondary_selection_box  ::BoundingBox? Read"
      },
      "mining_target": {
        "name": "mining_target",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The mining target, if any.",
        "short": "The mining target, if any.",
        "member": "mining_target  ::LuaEntity? Read"
      },
      "circuit_connected_entities": {
        "name": "circuit_connected_entities",
        "mode": "[R]",
        "doc": "Entities that are directly connected to this entity via the circuit network. nil if this entity can't be connected to the circuit network.",
        "short": "Entities that are directly connected to this entity via the circuit network. [...]",
        "member": "circuit_connected_entities  ::table? Read",
        "args": {
          "red": {
            "name": "red",
            "type": "array[LuaEntity]",
            "doc": "Entities connected via the red wire."
          },
          "green": {
            "name": "green",
            "type": "array[LuaEntity]",
            "doc": "Entities connected via the green wire."
          }
        }
      },
      "circuit_connection_definitions": {
        "name": "circuit_connection_definitions",
        "type": "CircuitConnectionDefinition",
        "mode": "[R]",
        "doc": "The connection definition for entities that are directly connected to this entity via the circuit network. nil if this entity can't be connected to the circuit network.",
        "short": "The connection definition for entities that are directly connected to this entity via the circuit network. [...]",
        "member": "circuit_connection_definitions  ::array[CircuitConnectionDefinition]? Read"
      },
      "copper_connection_definitions": {
        "name": "copper_connection_definitions",
        "type": "CopperConnectionDefinition",
        "mode": "[R]",
        "doc": "The connection definition for entities that are directly connected to this entity via copper cables.",
        "short": "The connection definition for entities that are directly connected to this entity via copper cables.",
        "member": "copper_connection_definitions  ::array[CopperConnectionDefinition] Read"
      },
      "request_slot_count": {
        "name": "request_slot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The index of the configured request with the highest index for this entity. This means 0 if no requests are set and e.g. 20 if the 20th request slot is configured.",
        "short": "The index of the configured request with the highest index for this entity. [...]",
        "member": "request_slot_count  ::uint Read"
      },
      "filter_slot_count": {
        "name": "filter_slot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of filter slots this inserter, loader, or logistic storage container has. 0 if not one of those entities.",
        "short": "The number of filter slots this inserter, loader, or logistic storage container has. [...]",
        "member": "filter_slot_count  ::uint Read"
      },
      "loader_container": {
        "name": "loader_container",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The container entity this loader is pointing at/pulling from depending on the LuaEntity::loader_type, if any.",
        "short": "The container entity this loader is pointing at/pulling from depending on the LuaEntity::loader_type, if any.",
        "member": "loader_container  ::LuaEntity? Read"
      },
      "grid": {
        "name": "grid",
        "type": "LuaEquipmentGrid",
        "mode": "[R]",
        "doc": "This entity's equipment grid, if any.",
        "short": "This entity's equipment grid, if any.",
        "member": "grid  ::LuaEquipmentGrid? Read"
      },
      "graphics_variation": {
        "name": "graphics_variation",
        "type": "uint8",
        "mode": "[RW]",
        "doc": "The graphics variation for this entity. nil if this entity doesn't use graphics variations.",
        "short": "The graphics variation for this entity. [...]",
        "member": "graphics_variation  ::uint8? Read/Write"
      },
      "tree_color_index": {
        "name": "tree_color_index",
        "type": "uint8",
        "mode": "[RW]",
        "doc": "Index of the tree color.",
        "short": "Index of the tree color.",
        "member": "tree_color_index  ::uint8 Read/Write"
      },
      "tree_color_index_max": {
        "name": "tree_color_index_max",
        "type": "uint8",
        "mode": "[R]",
        "doc": "Maximum index of the tree colors.",
        "short": "Maximum index of the tree colors.",
        "member": "tree_color_index_max  ::uint8 Read"
      },
      "tree_stage_index": {
        "name": "tree_stage_index",
        "type": "uint8",
        "mode": "[RW]",
        "doc": "Index of the tree stage.",
        "short": "Index of the tree stage.",
        "member": "tree_stage_index  ::uint8 Read/Write"
      },
      "tree_stage_index_max": {
        "name": "tree_stage_index_max",
        "type": "uint8",
        "mode": "[R]",
        "doc": "Maximum index of the tree stages.",
        "short": "Maximum index of the tree stages.",
        "member": "tree_stage_index_max  ::uint8 Read"
      },
      "tree_gray_stage_index": {
        "name": "tree_gray_stage_index",
        "type": "uint8",
        "mode": "[RW]",
        "doc": "Index of the tree gray stage",
        "short": "Index of the tree gray stage",
        "member": "tree_gray_stage_index  ::uint8 Read/Write"
      },
      "tree_gray_stage_index_max": {
        "name": "tree_gray_stage_index_max",
        "type": "uint8",
        "mode": "[R]",
        "doc": "Maximum index of the tree gray stages.",
        "short": "Maximum index of the tree gray stages.",
        "member": "tree_gray_stage_index_max  ::uint8 Read"
      },
      "burner": {
        "name": "burner",
        "type": "LuaBurner",
        "mode": "[R]",
        "doc": "The burner energy source for this entity, if any.",
        "short": "The burner energy source for this entity, if any.",
        "member": "burner  ::LuaBurner? Read"
      },
      "shooting_target": {
        "name": "shooting_target",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The shooting target for this turret, if any. Can't be set to nil via script.",
        "short": "The shooting target for this turret, if any. [...]",
        "member": "shooting_target  ::LuaEntity? Read/Write"
      },
      "proxy_target": {
        "name": "proxy_target",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The target entity for this item-request-proxy, if any.",
        "short": "The target entity for this item-request-proxy, if any.",
        "member": "proxy_target  ::LuaEntity? Read"
      },
      "stickers": {
        "name": "stickers",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The sticker entities attached to this entity, if any.",
        "short": "The sticker entities attached to this entity, if any.",
        "member": "stickers  ::array[LuaEntity]? Read"
      },
      "sticked_to": {
        "name": "sticked_to",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The entity this sticker is sticked to.",
        "short": "The entity this sticker is sticked to.",
        "member": "sticked_to  ::LuaEntity Read"
      },
      "sticker_vehicle_modifiers": {
        "name": "sticker_vehicle_modifiers",
        "mode": "[R]",
        "doc": "The vehicle modifiers applied to this entity through the attached stickers.",
        "short": "The vehicle modifiers applied to this entity through the attached stickers.",
        "member": "sticker_vehicle_modifiers  ::table? Read",
        "args": {
          "speed_modifier": {
            "name": "speed_modifier",
            "type": "double",
            "doc": ""
          },
          "friction_modifier": {
            "name": "friction_modifier",
            "type": "double",
            "doc": ""
          }
        }
      },
      "parameters": {
        "name": "parameters",
        "type": "ProgrammableSpeakerParameters",
        "mode": "[RW]",
        "member": "parameters  ::ProgrammableSpeakerParameters Read/Write"
      },
      "alert_parameters": {
        "name": "alert_parameters",
        "type": "ProgrammableSpeakerAlertParameters",
        "mode": "[RW]",
        "member": "alert_parameters  ::ProgrammableSpeakerAlertParameters Read/Write"
      },
      "electric_network_statistics": {
        "name": "electric_network_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[R]",
        "doc": "The electric network statistics for this electric pole.",
        "short": "The electric network statistics for this electric pole.",
        "member": "electric_network_statistics  ::LuaFlowStatistics Read"
      },
      "inserter_target_pickup_count": {
        "name": "inserter_target_pickup_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Returns the current target pickup count of the inserter.",
        "short": "Returns the current target pickup count of the inserter.",
        "member": "inserter_target_pickup_count  ::uint Read"
      },
      "inserter_stack_size_override": {
        "name": "inserter_stack_size_override",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Sets the stack size limit on this inserter. If the stack size is > than the force stack size limit the value is ignored.",
        "short": "Sets the stack size limit on this inserter. [...]",
        "member": "inserter_stack_size_override  ::uint Read/Write"
      },
      "products_finished": {
        "name": "products_finished",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The number of products this machine finished crafting in its lifetime.",
        "short": "The number of products this machine finished crafting in its lifetime.",
        "member": "products_finished  ::uint Read/Write"
      },
      "spawner": {
        "name": "spawner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The spawner associated with this unit entity, if any.",
        "short": "The spawner associated with this unit entity, if any.",
        "member": "spawner  ::LuaEntity? Read"
      },
      "spawning_cooldown": {
        "name": "spawning_cooldown",
        "type": "double",
        "mode": "[R]",
        "member": "spawning_cooldown  ::double Read"
      },
      "absorbed_pollution": {
        "name": "absorbed_pollution",
        "type": "double",
        "mode": "[R]",
        "member": "absorbed_pollution  ::double Read"
      },
      "spawn_shift": {
        "name": "spawn_shift",
        "type": "double",
        "mode": "[R]",
        "member": "spawn_shift  ::double Read"
      },
      "units": {
        "name": "units",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The units associated with this spawner entity.",
        "short": "The units associated with this spawner entity.",
        "member": "units  ::array[LuaEntity] Read"
      },
      "power_switch_state": {
        "name": "power_switch_state",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "The state of this power switch.",
        "short": "The state of this power switch.",
        "member": "power_switch_state  ::boolean Read/Write"
      },
      "effects": {
        "name": "effects",
        "type": "ModuleEffects",
        "mode": "[R]",
        "doc": "The effects being applied to this entity, if any. For beacons, this is the effect the beacon is broadcasting.",
        "short": "The effects being applied to this entity, if any. [...]",
        "member": "effects  ::ModuleEffects? Read"
      },
      "beacons_count": {
        "name": "beacons_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of beacons affecting this effect receiver. Can only be used when the entity has an effect receiver (AssemblingMachine, Furnace, Lab, MiningDrills)",
        "short": "Number of beacons affecting this effect receiver. [...]",
        "member": "beacons_count  ::uint? Read"
      },
      "infinity_container_filters": {
        "name": "infinity_container_filters",
        "type": "InfinityInventoryFilter",
        "mode": "[RW]",
        "doc": "The filters for this infinity container.",
        "short": "The filters for this infinity container.",
        "member": "infinity_container_filters  ::array[InfinityInventoryFilter] Read/Write"
      },
      "remove_unfiltered_items": {
        "name": "remove_unfiltered_items",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether items not included in this infinity container filters should be removed from the container.",
        "short": "Whether items not included in this infinity container filters should be removed from the container.",
        "member": "remove_unfiltered_items  ::boolean Read/Write"
      },
      "character_corpse_player_index": {
        "name": "character_corpse_player_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The player index associated with this character corpse.",
        "short": "The player index associated with this character corpse.",
        "member": "character_corpse_player_index  ::uint Read/Write"
      },
      "character_corpse_tick_of_death": {
        "name": "character_corpse_tick_of_death",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The tick this character corpse died at.",
        "short": "The tick this character corpse died at.",
        "member": "character_corpse_tick_of_death  ::uint Read/Write"
      },
      "character_corpse_death_cause": {
        "name": "character_corpse_death_cause",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The reason this character corpse character died. \"\" if there is no reason.",
        "short": "The reason this character corpse character died. [...]",
        "member": "character_corpse_death_cause  ::LocalisedString Read/Write"
      },
      "associated_player": {
        "name": "associated_player",
        "type": "LuaPlayer",
        "mode": "[RW]",
        "doc": "The player this character is associated with, if any. Set to nil to clear.",
        "short": "The player this character is associated with, if any. [...]",
        "member": "associated_player  ::LuaPlayer or PlayerIdentification? Read/Write"
      },
      "tick_of_last_attack": {
        "name": "tick_of_last_attack",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The last tick this character entity was attacked.",
        "short": "The last tick this character entity was attacked.",
        "member": "tick_of_last_attack  ::uint Read/Write"
      },
      "tick_of_last_damage": {
        "name": "tick_of_last_damage",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The last tick this character entity was damaged.",
        "short": "The last tick this character entity was damaged.",
        "member": "tick_of_last_damage  ::uint Read/Write"
      },
      "splitter_filter": {
        "name": "splitter_filter",
        "type": "LuaItemPrototype",
        "mode": "[RW]",
        "doc": "The filter for this splitter, if any is set.",
        "short": "The filter for this splitter, if any is set.",
        "member": "splitter_filter  ::LuaItemPrototype? Read/Write"
      },
      "inserter_filter_mode": {
        "name": "inserter_filter_mode",
        "mode": "[RW]",
        "doc": "The filter mode for this filter inserter. nil if this inserter doesn't use filters.",
        "short": "The filter mode for this filter inserter. [...]",
        "member": "inserter_filter_mode  ::\"whitelist\" or \"blacklist\"? Read/Write"
      },
      "splitter_input_priority": {
        "name": "splitter_input_priority",
        "mode": "[RW]",
        "doc": "The input priority for this splitter.",
        "short": "The input priority for this splitter.",
        "member": "splitter_input_priority  ::\"left\" or \"none\" or \"right\" Read/Write"
      },
      "splitter_output_priority": {
        "name": "splitter_output_priority",
        "mode": "[RW]",
        "doc": "The output priority for this splitter.",
        "short": "The output priority for this splitter.",
        "member": "splitter_output_priority  ::\"left\" or \"none\" or \"right\" Read/Write"
      },
      "armed": {
        "name": "armed",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this land mine is armed.",
        "short": "Whether this land mine is armed.",
        "member": "armed  ::boolean Read"
      },
      "recipe_locked": {
        "name": "recipe_locked",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "When locked; the recipe in this assembling machine can't be changed by the player.",
        "short": "When locked; the recipe in this assembling machine can't be changed by the player.",
        "member": "recipe_locked  ::boolean Read/Write"
      },
      "connected_rail": {
        "name": "connected_rail",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The rail entity this train stop is connected to, if any.",
        "short": "The rail entity this train stop is connected to, if any.",
        "member": "connected_rail  ::LuaEntity? Read"
      },
      "connected_rail_direction": {
        "name": "connected_rail_direction",
        "type": "defines.rail_direction",
        "mode": "[R]",
        "doc": "Rail direction to which this train stop is binding. This returns a value even when no rails are present.",
        "short": "Rail direction to which this train stop is binding. [...]",
        "member": "connected_rail_direction  ::defines.rail_direction Read"
      },
      "trains_in_block": {
        "name": "trains_in_block",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of trains in this rail block for this rail entity.",
        "short": "The number of trains in this rail block for this rail entity.",
        "member": "trains_in_block  ::uint Read"
      },
      "timeout": {
        "name": "timeout",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The timeout that's left on this landmine in ticks. It describes the time between the landmine being placed and it being armed.",
        "short": "The timeout that's left on this landmine in ticks. [...]",
        "member": "timeout  ::uint Read/Write"
      },
      "neighbour_bonus": {
        "name": "neighbour_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "The current total neighbour bonus of this reactor.",
        "short": "The current total neighbour bonus of this reactor.",
        "member": "neighbour_bonus  ::double Read"
      },
      "ai_settings": {
        "name": "ai_settings",
        "type": "LuaAISettings",
        "mode": "[R]",
        "doc": "The ai settings of this unit.",
        "short": "The ai settings of this unit.",
        "member": "ai_settings  ::LuaAISettings Read"
      },
      "highlight_box_type": {
        "name": "highlight_box_type",
        "type": "CursorBoxRenderType",
        "mode": "[RW]",
        "doc": "The hightlight box type of this highlight box entity.",
        "short": "The hightlight box type of this highlight box entity.",
        "member": "highlight_box_type  ::CursorBoxRenderType Read/Write"
      },
      "highlight_box_blink_interval": {
        "name": "highlight_box_blink_interval",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The blink interval of this highlight box entity. 0 indicates no blink.",
        "short": "The blink interval of this highlight box entity. [...]",
        "member": "highlight_box_blink_interval  ::uint Read/Write"
      },
      "status": {
        "name": "status",
        "type": "defines.entity_status",
        "mode": "[R]",
        "doc": "The status of this entity, if any.",
        "short": "The status of this entity, if any.",
        "member": "status  ::defines.entity_status? Read"
      },
      "enable_logistics_while_moving": {
        "name": "enable_logistics_while_moving",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether equipment grid logistics are enabled while this vehicle is moving.",
        "short": "Whether equipment grid logistics are enabled while this vehicle is moving.",
        "member": "enable_logistics_while_moving  ::boolean Read/Write"
      },
      "render_player": {
        "name": "render_player",
        "type": "LuaPlayer",
        "mode": "[RW]",
        "doc": "The player that this simple-entity-with-owner, simple-entity-with-force, flying-text, or highlight-box is visible to. nil when this entity is rendered for all players.",
        "short": "The player that this simple-entity-with-owner, simple-entity-with-force, flying-text, or highlight-box is visible to. [...]",
        "member": "render_player  ::LuaPlayer or PlayerIdentification? Read/Write"
      },
      "render_to_forces": {
        "name": "render_to_forces",
        "type": "ForceIdentification",
        "mode": "[RW]",
        "doc": "The forces that this simple-entity-with-owner, simple-entity-with-force, or flying-text is visible to. nil or an empty array when this entity is rendered for all forces.",
        "short": "The forces that this simple-entity-with-owner, simple-entity-with-force, or flying-text is visible to. [...]",
        "member": "render_to_forces  ::array[ForceIdentification]? Read/Write"
      },
      "pump_rail_target": {
        "name": "pump_rail_target",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The rail target of this pump, if any.",
        "short": "The rail target of this pump, if any.",
        "member": "pump_rail_target  ::LuaEntity? Read"
      },
      "moving": {
        "name": "moving",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Returns true if this unit is moving.",
        "short": "Returns true if this unit is moving.",
        "member": "moving  ::boolean Read"
      },
      "electric_network_id": {
        "name": "electric_network_id",
        "type": "uint",
        "mode": "[R]",
        "doc": "Returns the id of the electric network that this entity is connected to, if any.",
        "short": "Returns the id of the electric network that this entity is connected to, if any.",
        "member": "electric_network_id  ::uint? Read"
      },
      "allow_dispatching_robots": {
        "name": "allow_dispatching_robots",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this character's personal roboports are allowed to dispatch robots.",
        "short": "Whether this character's personal roboports are allowed to dispatch robots.",
        "member": "allow_dispatching_robots  ::boolean Read/Write"
      },
      "auto_launch": {
        "name": "auto_launch",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this rocket silo automatically launches the rocket when cargo is inserted.",
        "short": "Whether this rocket silo automatically launches the rocket when cargo is inserted.",
        "member": "auto_launch  ::boolean Read/Write"
      },
      "energy_generated_last_tick": {
        "name": "energy_generated_last_tick",
        "type": "double",
        "mode": "[R]",
        "doc": "How much energy this generator generated in the last tick.",
        "short": "How much energy this generator generated in the last tick.",
        "member": "energy_generated_last_tick  ::double Read"
      },
      "storage_filter": {
        "name": "storage_filter",
        "type": "LuaItemPrototype",
        "mode": "[RW]",
        "doc": "The storage filter for this logistic storage container.",
        "short": "The storage filter for this logistic storage container.",
        "member": "storage_filter  ::LuaItemPrototype? Read/Write"
      },
      "request_from_buffers": {
        "name": "request_from_buffers",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this requester chest is set to also request from buffer chests.",
        "short": "Whether this requester chest is set to also request from buffer chests.",
        "member": "request_from_buffers  ::boolean Read/Write"
      },
      "corpse_expires": {
        "name": "corpse_expires",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this corpse will ever fade away.",
        "short": "Whether this corpse will ever fade away.",
        "member": "corpse_expires  ::boolean Read/Write"
      },
      "corpse_immune_to_entity_placement": {
        "name": "corpse_immune_to_entity_placement",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If true, corpse won't be destroyed when entities are placed over it. If false, whether corpse will be removed or not depends on value of CorpsePrototype::remove_on_entity_placement.",
        "short": "If true, corpse won't be destroyed when entities are placed over it. [...]",
        "member": "corpse_immune_to_entity_placement  ::boolean Read/Write"
      },
      "tags": {
        "name": "tags",
        "type": "Tags",
        "mode": "[RW]",
        "doc": "The tags associated with this entity ghost. nil if this is not an entity ghost.",
        "short": "The tags associated with this entity ghost. [...]",
        "member": "tags  ::Tags? Read/Write"
      },
      "command": {
        "name": "command",
        "type": "Command",
        "mode": "[R]",
        "doc": "The command given to this unit, if any.",
        "short": "The command given to this unit, if any.",
        "member": "command  ::Command? Read"
      },
      "distraction_command": {
        "name": "distraction_command",
        "type": "Command",
        "mode": "[R]",
        "doc": "The distraction command given to this unit, if any.",
        "short": "The distraction command given to this unit, if any.",
        "member": "distraction_command  ::Command? Read"
      },
      "time_to_next_effect": {
        "name": "time_to_next_effect",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The ticks until the next trigger effect of this smoke-with-trigger.",
        "short": "The ticks until the next trigger effect of this smoke-with-trigger.",
        "member": "time_to_next_effect  ::uint Read/Write"
      },
      "autopilot_destination": {
        "name": "autopilot_destination",
        "type": "MapPosition",
        "mode": "[RW]",
        "doc": "Destination of this spidertron's autopilot, if any. Writing nil clears all destinations.",
        "short": "Destination of this spidertron's autopilot, if any. [...]",
        "member": "autopilot_destination  ::MapPosition? Read/Write"
      },
      "autopilot_destinations": {
        "name": "autopilot_destinations",
        "type": "MapPosition",
        "mode": "[R]",
        "doc": "The queued destination positions of spidertron's autopilot.",
        "short": "The queued destination positions of spidertron's autopilot.",
        "member": "autopilot_destinations  ::array[MapPosition] Read"
      },
      "trains_count": {
        "name": "trains_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Amount of trains related to this particular train stop. Includes train stopped at this train stop (until it finds a path to next target) and trains having this train stop as goal or waypoint.",
        "short": "Amount of trains related to this particular train stop. [...]",
        "member": "trains_count  ::uint Read"
      },
      "trains_limit": {
        "name": "trains_limit",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Amount of trains above which no new trains will be sent to this train stop. Writing nil will disable the limit (will set a maximum possible value).",
        "short": "Amount of trains above which no new trains will be sent to this train stop. [...]",
        "member": "trains_limit  ::uint Read/Write"
      },
      "is_entity_with_force": {
        "name": "is_entity_with_force",
        "type": "boolean",
        "mode": "[R]",
        "doc": "(deprecated by 1.1.51) If this entity is a MilitaryTarget. Returns same value as LuaEntity::is_military_target",
        "short": "(deprecated by 1.1.51) If this entity is a MilitaryTarget. [...]",
        "member": "is_entity_with_force  ::boolean Read"
      },
      "is_military_target": {
        "name": "is_military_target",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this entity is a MilitaryTarget. Can be written to if LuaEntityPrototype::allow_run_time_change_of_is_military_target returns true.",
        "short": "Whether this entity is a MilitaryTarget. [...]",
        "member": "is_military_target  ::boolean Read/Write"
      },
      "is_entity_with_owner": {
        "name": "is_entity_with_owner",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this entity is EntityWithOwner",
        "short": "If this entity is EntityWithOwner",
        "member": "is_entity_with_owner  ::boolean Read"
      },
      "is_entity_with_health": {
        "name": "is_entity_with_health",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this entity is EntityWithHealth",
        "short": "If this entity is EntityWithHealth",
        "member": "is_entity_with_health  ::boolean Read"
      },
      "combat_robot_owner": {
        "name": "combat_robot_owner",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The owner of this combat robot, if any.",
        "short": "The owner of this combat robot, if any.",
        "member": "combat_robot_owner  ::LuaEntity? Read/Write"
      },
      "link_id": {
        "name": "link_id",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The link ID this linked container is using.",
        "short": "The link ID this linked container is using.",
        "member": "link_id  ::uint Read/Write"
      },
      "follow_target": {
        "name": "follow_target",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The follow target of this spidertron, if any.",
        "short": "The follow target of this spidertron, if any.",
        "member": "follow_target  ::LuaEntity? Read/Write"
      },
      "follow_offset": {
        "name": "follow_offset",
        "type": "Vector",
        "mode": "[RW]",
        "doc": "The follow offset of this spidertron, if any entity is being followed. This is randomized each time the follow entity is set.",
        "short": "The follow offset of this spidertron, if any entity is being followed. [...]",
        "member": "follow_offset  ::Vector? Read/Write"
      },
      "linked_belt_type": {
        "name": "linked_belt_type",
        "mode": "[RW]",
        "doc": "Type of linked belt. Changing type will also flip direction so the belt is out of the same side.",
        "short": "Type of linked belt. [...]",
        "member": "linked_belt_type  ::\"input\" or \"output\" Read/Write"
      },
      "linked_belt_neighbour": {
        "name": "linked_belt_neighbour",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "Neighbour to which this linked belt is connected to, if any.",
        "short": "Neighbour to which this linked belt is connected to, if any.",
        "member": "linked_belt_neighbour  ::LuaEntity? Read"
      },
      "radar_scan_progress": {
        "name": "radar_scan_progress",
        "type": "float",
        "mode": "[R]",
        "doc": "The current radar scan progress, as a number in range [0, 1].",
        "short": "The current radar scan progress, as a number in range [0, 1].",
        "member": "radar_scan_progress  ::float Read"
      },
      "rocket_silo_status": {
        "name": "rocket_silo_status",
        "type": "defines.rocket_silo_status",
        "mode": "[R]",
        "doc": "The status of this rocket silo entity.",
        "short": "The status of this rocket silo entity.",
        "member": "rocket_silo_status  ::defines.rocket_silo_status Read"
      },
      "tile_width": {
        "name": "tile_width",
        "type": "uint",
        "mode": "[R]",
        "doc": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension). Uses the current direction of the entity.",
        "short": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension). [...]",
        "member": "tile_width  ::uint Read"
      },
      "tile_height": {
        "name": "tile_height",
        "type": "uint",
        "mode": "[R]",
        "doc": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension). Uses the current direction of the entity.",
        "short": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension). [...]",
        "member": "tile_height  ::uint Read"
      },
      "is_headed_to_trains_front": {
        "name": "is_headed_to_trains_front",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the rolling stock is facing train's front.",
        "short": "If the rolling stock is facing train's front.",
        "member": "is_headed_to_trains_front  ::boolean Read"
      },
      "draw_data": {
        "name": "draw_data",
        "type": "RollingStockDrawData",
        "mode": "[R]",
        "doc": "Gives a draw data of the given entity if it supports such data.",
        "short": "Gives a draw data of the given entity if it supports such data.",
        "member": "draw_data  ::RollingStockDrawData Read"
      },
      "belt_shape": {
        "name": "belt_shape",
        "mode": "[R]",
        "doc": "Gives what is the current shape of a transport-belt.",
        "short": "Gives what is the current shape of a transport-belt.",
        "member": "belt_shape  ::\"straight\" or \"left\" or \"right\" Read"
      },
      "gps_tag": {
        "name": "gps_tag",
        "type": "string",
        "mode": "[R]",
        "doc": "Returns a rich text string containing this entity's position and surface name as a gps tag. Printing it will ping the location of the entity.",
        "short": "Returns a rich text string containing this entity's position and surface name as a gps tag. [...]",
        "member": "gps_tag  ::string Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEntityPrototype": {
    "name": "LuaEntityPrototype",
    "type": "LuaEntityPrototype",
    "inherits": [],
    "properties": {
      "has_flag": {
        "name": "has_flag",
        "type": "function",
        "doc": "Test whether this entity prototype has a certain flag set. Returns: true if this prototype has the given flag set.",
        "short": "Test whether this entity prototype has a certain flag set.",
        "member": "has_flag(flag)  boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "name": "flag",
            "type": "EntityPrototypeFlag",
            "doc": "The flag to test."
          }
        }
      },
      "get_inventory_size": {
        "name": "get_inventory_size",
        "type": "function",
        "doc": "Gets the base size of the given inventory on this entity or nil if the given inventory doesn't exist.",
        "short": "Gets the base size of the given inventory on this entity or nil if the given inventory doesn't exist.",
        "member": "get_inventory_size(index)  uint?",
        "args": {
          "index": {
            "name": "index",
            "type": "defines.inventory",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "Type of this prototype.",
        "short": "Type of this prototype.",
        "member": "type  ::string Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "max_health": {
        "name": "max_health",
        "type": "float",
        "mode": "[R]",
        "doc": "Max health of this entity. Will be 0 if this is not an entity with health.",
        "short": "Max health of this entity. [...]",
        "member": "max_health  ::float Read"
      },
      "infinite_resource": {
        "name": "infinite_resource",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this resource is infinite.",
        "short": "Whether this resource is infinite.",
        "member": "infinite_resource  ::boolean? Read"
      },
      "minimum_resource_amount": {
        "name": "minimum_resource_amount",
        "type": "uint",
        "mode": "[R]",
        "doc": "Minimum amount of this resource.",
        "short": "Minimum amount of this resource.",
        "member": "minimum_resource_amount  ::uint? Read"
      },
      "normal_resource_amount": {
        "name": "normal_resource_amount",
        "type": "uint",
        "mode": "[R]",
        "doc": "The normal amount for this resource.",
        "short": "The normal amount for this resource.",
        "member": "normal_resource_amount  ::uint? Read"
      },
      "infinite_depletion_resource_amount": {
        "name": "infinite_depletion_resource_amount",
        "type": "uint",
        "mode": "[R]",
        "doc": "Every time this infinite resource 'ticks' down, it is reduced by this amount. Meaningless if this isn't an infinite resource.",
        "short": "Every time this infinite resource 'ticks' down, it is reduced by this amount. [...]",
        "member": "infinite_depletion_resource_amount  ::uint? Read"
      },
      "resource_category": {
        "name": "resource_category",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the category of this resource.",
        "short": "Name of the category of this resource.",
        "member": "resource_category  ::string? Read"
      },
      "mineable_properties": {
        "name": "mineable_properties",
        "mode": "[R]",
        "doc": "Whether this entity is minable and what can be obtained by mining it.",
        "short": "Whether this entity is minable and what can be obtained by mining it.",
        "member": "mineable_properties  ::table Read",
        "args": {
          "minable": {
            "name": "minable",
            "type": "boolean",
            "doc": "Is this entity mineable at all?"
          },
          "mining_time": {
            "name": "mining_time",
            "type": "double",
            "doc": "Energy required to mine an entity."
          },
          "mining_particle": {
            "name": "mining_particle",
            "type": "string?",
            "doc": "Prototype name of the particle produced when mining this entity. Will only be present if this entity produces any particle during mining."
          },
          "products": {
            "name": "products",
            "type": "array[Product]?",
            "doc": "Products obtained by mining this entity."
          },
          "fluid_amount": {
            "name": "fluid_amount",
            "type": "double?",
            "doc": "The required fluid amount if any."
          },
          "required_fluid": {
            "name": "required_fluid",
            "type": "string?",
            "doc": "The prototype name of the required fluid if any."
          },
          "mining_trigger": {
            "name": "mining_trigger",
            "type": "array[TriggerItem]?",
            "doc": "The mining trigger if any."
          }
        }
      },
      "items_to_place_this": {
        "name": "items_to_place_this",
        "type": "ItemStackDefinition",
        "mode": "[R]",
        "doc": "Items that when placed will produce this entity, if any. Construction bots will choose the first item in the list to build this entity.",
        "short": "Items that when placed will produce this entity, if any. [...]",
        "member": "items_to_place_this  ::array[ItemStackDefinition]? Read"
      },
      "collision_box": {
        "name": "collision_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box used for collision checking.",
        "short": "The bounding box used for collision checking.",
        "member": "collision_box  ::BoundingBox Read"
      },
      "secondary_collision_box": {
        "name": "secondary_collision_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The secondary bounding box used for collision checking, if any. This is only used in rails and rail remnants.",
        "short": "The secondary bounding box used for collision checking, if any. [...]",
        "member": "secondary_collision_box  ::BoundingBox? Read"
      },
      "map_generator_bounding_box": {
        "name": "map_generator_bounding_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box used for map generator collision checking.",
        "short": "The bounding box used for map generator collision checking.",
        "member": "map_generator_bounding_box  ::BoundingBox Read"
      },
      "selection_box": {
        "name": "selection_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box used for drawing selection.",
        "short": "The bounding box used for drawing selection.",
        "member": "selection_box  ::BoundingBox Read"
      },
      "drawing_box": {
        "name": "drawing_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box used for drawing the entity icon.",
        "short": "The bounding box used for drawing the entity icon.",
        "member": "drawing_box  ::BoundingBox Read"
      },
      "sticker_box": {
        "name": "sticker_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box used to attach sticker type entities.",
        "short": "The bounding box used to attach sticker type entities.",
        "member": "sticker_box  ::BoundingBox Read"
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "CollisionMask",
        "mode": "[R]",
        "doc": "The collision masks this entity uses",
        "short": "The collision masks this entity uses",
        "member": "collision_mask  ::CollisionMask Read"
      },
      "collision_mask_with_flags": {
        "name": "collision_mask_with_flags",
        "type": "CollisionMaskWithFlags",
        "mode": "[R]",
        "member": "collision_mask_with_flags  ::CollisionMaskWithFlags Read"
      },
      "default_collision_mask_with_flags": {
        "name": "default_collision_mask_with_flags",
        "type": "CollisionMaskWithFlags",
        "mode": "[R]",
        "doc": "The hardcoded default collision mask (with flags) for this entity prototype type.",
        "short": "The hardcoded default collision mask (with flags) for this entity prototype type.",
        "member": "default_collision_mask_with_flags  ::CollisionMaskWithFlags Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Group of this entity.",
        "short": "Group of this entity.",
        "member": "group  ::LuaGroup Read"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Subgroup of this entity.",
        "short": "Subgroup of this entity.",
        "member": "subgroup  ::LuaGroup Read"
      },
      "healing_per_tick": {
        "name": "healing_per_tick",
        "type": "float",
        "mode": "[R]",
        "doc": "Amount this entity can heal per tick, if any.",
        "short": "Amount this entity can heal per tick, if any.",
        "member": "healing_per_tick  ::float? Read"
      },
      "emissions_per_second": {
        "name": "emissions_per_second",
        "type": "double",
        "mode": "[R]",
        "doc": "Amount of pollution emissions per second this entity will create.",
        "short": "Amount of pollution emissions per second this entity will create.",
        "member": "emissions_per_second  ::double Read"
      },
      "corpses": {
        "name": "corpses",
        "type": "string",
        "mode": "[R]",
        "doc": "Corpses used when this entity is destroyed. It is a dictionary indexed by the corpse's prototype name.",
        "short": "Corpses used when this entity is destroyed. [...]",
        "member": "corpses  ::dictionary[string LuaEntityPrototype]? Read"
      },
      "selectable_in_game": {
        "name": "selectable_in_game",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this entity selectable?",
        "short": "Is this entity selectable?",
        "member": "selectable_in_game  ::boolean Read"
      },
      "selection_priority": {
        "name": "selection_priority",
        "type": "uint",
        "mode": "[R]",
        "doc": "The selection priority of this entity - a value between 0 and 255",
        "short": "The selection priority of this entity - a value between 0 and 255",
        "member": "selection_priority  ::uint Read"
      },
      "weight": {
        "name": "weight",
        "type": "double",
        "mode": "[R]",
        "doc": "The weight of this vehicle prototype.",
        "short": "The weight of this vehicle prototype.",
        "member": "weight  ::double? Read"
      },
      "resistances": {
        "name": "resistances",
        "type": "string",
        "mode": "[R]",
        "doc": "List of resistances towards each damage type. It is a dictionary indexed by damage type names (see data/base/prototypes/damage-type.lua).",
        "short": "List of resistances towards each damage type. [...]",
        "member": "resistances  ::dictionary[string Resistance]? Read"
      },
      "fast_replaceable_group": {
        "name": "fast_replaceable_group",
        "type": "string",
        "mode": "[R]",
        "doc": "The group of mutually fast-replaceable entities, if any.",
        "short": "The group of mutually fast-replaceable entities, if any.",
        "member": "fast_replaceable_group  ::string? Read"
      },
      "next_upgrade": {
        "name": "next_upgrade",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The next upgrade for this entity, if any.",
        "short": "The next upgrade for this entity, if any.",
        "member": "next_upgrade  ::LuaEntityPrototype? Read"
      },
      "loot": {
        "name": "loot",
        "type": "Loot",
        "mode": "[R]",
        "doc": "Loot that will be dropped when this entity is killed, if any.",
        "short": "Loot that will be dropped when this entity is killed, if any.",
        "member": "loot  ::array[Loot]? Read"
      },
      "repair_speed_modifier": {
        "name": "repair_speed_modifier",
        "type": "uint",
        "mode": "[R]",
        "doc": "Repair-speed modifier for this entity, if any. Actual repair speed will be tool_repair_speed * entity_repair_speed_modifier.",
        "short": "Repair-speed modifier for this entity, if any. [...]",
        "member": "repair_speed_modifier  ::uint? Read"
      },
      "turret_range": {
        "name": "turret_range",
        "type": "uint",
        "mode": "[R]",
        "doc": "The range of this turret.",
        "short": "The range of this turret.",
        "member": "turret_range  ::uint? Read"
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[R]",
        "doc": "Autoplace specification for this entity prototype, if any.",
        "short": "Autoplace specification for this entity prototype, if any.",
        "member": "autoplace_specification  ::AutoplaceSpecification? Read"
      },
      "belt_speed": {
        "name": "belt_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The speed of this transport belt.",
        "short": "The speed of this transport belt.",
        "member": "belt_speed  ::double? Read"
      },
      "result_units": {
        "name": "result_units",
        "type": "UnitSpawnDefinition",
        "mode": "[R]",
        "doc": "The result units and spawn points with weight and evolution factor for a biter spawner entity.",
        "short": "The result units and spawn points with weight and evolution factor for a biter spawner entity.",
        "member": "result_units  ::array[UnitSpawnDefinition]? Read"
      },
      "attack_result": {
        "name": "attack_result",
        "type": "TriggerItem",
        "mode": "[R]",
        "doc": "The attack result of this entity, if any.",
        "short": "The attack result of this entity, if any.",
        "member": "attack_result  ::array[TriggerItem]? Read"
      },
      "final_attack_result": {
        "name": "final_attack_result",
        "type": "TriggerItem",
        "mode": "[R]",
        "doc": "The final attack result for this projectile.",
        "short": "The final attack result for this projectile.",
        "member": "final_attack_result  ::array[TriggerItem]? Read"
      },
      "attack_parameters": {
        "name": "attack_parameters",
        "type": "AttackParameters",
        "mode": "[R]",
        "doc": "The attack parameters for this entity, if any.",
        "short": "The attack parameters for this entity, if any.",
        "member": "attack_parameters  ::AttackParameters? Read"
      },
      "spawn_cooldown": {
        "name": "spawn_cooldown",
        "mode": "[R]",
        "doc": "The spawning cooldown for this enemy spawner prototype.",
        "short": "The spawning cooldown for this enemy spawner prototype.",
        "member": "spawn_cooldown  ::table? Read",
        "args": {
          "min": {
            "name": "min",
            "type": "double",
            "doc": ""
          },
          "max": {
            "name": "max",
            "type": "double",
            "doc": ""
          }
        }
      },
      "mining_drill_radius": {
        "name": "mining_drill_radius",
        "type": "double",
        "mode": "[R]",
        "doc": "The mining radius of this mining drill prototype.",
        "short": "The mining radius of this mining drill prototype.",
        "member": "mining_drill_radius  ::double? Read"
      },
      "mining_speed": {
        "name": "mining_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The mining speed of this mining drill/character prototype.",
        "short": "The mining speed of this mining drill/character prototype.",
        "member": "mining_speed  ::double? Read"
      },
      "logistic_mode": {
        "name": "logistic_mode",
        "mode": "[R]",
        "doc": "The logistic mode of this logistic container.",
        "short": "The logistic mode of this logistic container.",
        "member": "logistic_mode  ::\"requester\" or \"active-provider\" or \"passive-provider\" or \"buffer\" or \"storage\" or \"none\"? Read"
      },
      "max_underground_distance": {
        "name": "max_underground_distance",
        "type": "uint8",
        "mode": "[R]",
        "doc": "The max underground distance for underground belts and underground pipes.",
        "short": "The max underground distance for underground belts and underground pipes.",
        "member": "max_underground_distance  ::uint8? Read"
      },
      "flags": {
        "name": "flags",
        "type": "EntityPrototypeFlags",
        "mode": "[R]",
        "doc": "The flags for this entity prototype.",
        "short": "The flags for this entity prototype.",
        "member": "flags  ::EntityPrototypeFlags Read"
      },
      "remains_when_mined": {
        "name": "remains_when_mined",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The remains left behind when this entity is mined.",
        "short": "The remains left behind when this entity is mined.",
        "member": "remains_when_mined  ::array[LuaEntityPrototype] Read"
      },
      "additional_pastable_entities": {
        "name": "additional_pastable_entities",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "Entities this entity can be pasted onto in addition to the normal allowed ones.",
        "short": "Entities this entity can be pasted onto in addition to the normal allowed ones.",
        "member": "additional_pastable_entities  ::array[LuaEntityPrototype] Read"
      },
      "allow_copy_paste": {
        "name": "allow_copy_paste",
        "type": "boolean",
        "mode": "[R]",
        "doc": "When false copy-paste is not allowed for this entity.",
        "short": "When false copy-paste is not allowed for this entity.",
        "member": "allow_copy_paste  ::boolean Read"
      },
      "shooting_cursor_size": {
        "name": "shooting_cursor_size",
        "type": "float",
        "mode": "[R]",
        "doc": "The cursor size used when shooting at this entity.",
        "short": "The cursor size used when shooting at this entity.",
        "member": "shooting_cursor_size  ::float Read"
      },
      "created_smoke": {
        "name": "created_smoke",
        "mode": "[R]",
        "doc": "The smoke trigger run when this entity is built, if any.",
        "short": "The smoke trigger run when this entity is built, if any.",
        "member": "created_smoke  ::table? Read",
        "args": {
          "smoke_name": {
            "name": "smoke_name",
            "type": "string",
            "doc": ""
          },
          "offsets": {
            "name": "offsets",
            "type": "array[Vector]",
            "doc": ""
          },
          "offset_deviation": {
            "name": "offset_deviation",
            "type": "BoundingBox",
            "doc": ""
          },
          "initial_height": {
            "name": "initial_height",
            "type": "float",
            "doc": ""
          },
          "max_radius": {
            "name": "max_radius",
            "type": "float?",
            "doc": ""
          },
          "speed": {
            "name": "speed",
            "type": "Vector",
            "doc": ""
          },
          "speed_multiplier": {
            "name": "speed_multiplier",
            "type": "float",
            "doc": ""
          },
          "speed_multiplier_deviation": {
            "name": "speed_multiplier_deviation",
            "type": "float",
            "doc": ""
          },
          "starting_frame": {
            "name": "starting_frame",
            "type": "float",
            "doc": ""
          },
          "starting_frame_deviation": {
            "name": "starting_frame_deviation",
            "type": "float",
            "doc": ""
          },
          "starting_frame_speed": {
            "name": "starting_frame_speed",
            "type": "float",
            "doc": ""
          },
          "starting_frame_speed_deviation": {
            "name": "starting_frame_speed_deviation",
            "type": "float",
            "doc": ""
          },
          "speed_from_center": {
            "name": "speed_from_center",
            "type": "float",
            "doc": ""
          },
          "speed_from_center_deviation": {
            "name": "speed_from_center_deviation",
            "type": "float",
            "doc": ""
          }
        }
      },
      "created_effect": {
        "name": "created_effect",
        "type": "TriggerItem",
        "mode": "[R]",
        "doc": "The trigger to run when this entity is created, if any.",
        "short": "The trigger to run when this entity is created, if any.",
        "member": "created_effect  ::array[TriggerItem]? Read"
      },
      "map_color": {
        "name": "map_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The map color used when charting this entity if a friendly or enemy color isn't defined, if any.",
        "short": "The map color used when charting this entity if a friendly or enemy color isn't defined, if any.",
        "member": "map_color  ::Color? Read"
      },
      "friendly_map_color": {
        "name": "friendly_map_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The friendly map color used when charting this entity.",
        "short": "The friendly map color used when charting this entity.",
        "member": "friendly_map_color  ::Color Read"
      },
      "enemy_map_color": {
        "name": "enemy_map_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The enemy map color used when charting this entity.",
        "short": "The enemy map color used when charting this entity.",
        "member": "enemy_map_color  ::Color Read"
      },
      "build_base_evolution_requirement": {
        "name": "build_base_evolution_requirement",
        "type": "double",
        "mode": "[R]",
        "doc": "The evolution requirement to build this entity as a base when expanding enemy bases.",
        "short": "The evolution requirement to build this entity as a base when expanding enemy bases.",
        "member": "build_base_evolution_requirement  ::double Read"
      },
      "instruments": {
        "name": "instruments",
        "type": "ProgrammableSpeakerInstrument",
        "mode": "[R]",
        "doc": "The instruments for this programmable speaker.",
        "short": "The instruments for this programmable speaker.",
        "member": "instruments  ::array[ProgrammableSpeakerInstrument]? Read"
      },
      "max_polyphony": {
        "name": "max_polyphony",
        "type": "uint",
        "mode": "[R]",
        "doc": "The maximum polyphony for this programmable speaker.",
        "short": "The maximum polyphony for this programmable speaker.",
        "member": "max_polyphony  ::uint? Read"
      },
      "module_inventory_size": {
        "name": "module_inventory_size",
        "type": "uint",
        "mode": "[R]",
        "doc": "The module inventory size. nil if this entity doesn't support modules.",
        "short": "The module inventory size. [...]",
        "member": "module_inventory_size  ::uint? Read"
      },
      "ingredient_count": {
        "name": "ingredient_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The max number of ingredients this crafting machine prototype supports.",
        "short": "The max number of ingredients this crafting machine prototype supports.",
        "member": "ingredient_count  ::uint? Read"
      },
      "crafting_speed": {
        "name": "crafting_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The crafting speed.",
        "short": "The crafting speed.",
        "member": "crafting_speed  ::double? Read"
      },
      "crafting_categories": {
        "name": "crafting_categories",
        "type": "string",
        "mode": "[R]",
        "doc": "The crafting categories this entity prototype supports.",
        "short": "The crafting categories this entity prototype supports.",
        "member": "crafting_categories  ::dictionary[string boolean]? Read"
      },
      "resource_categories": {
        "name": "resource_categories",
        "type": "string",
        "mode": "[R]",
        "doc": "The resource categories this character or mining drill supports.",
        "short": "The resource categories this character or mining drill supports.",
        "member": "resource_categories  ::dictionary[string boolean]? Read"
      },
      "supply_area_distance": {
        "name": "supply_area_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The supply area of this electric pole or beacon prototype.",
        "short": "The supply area of this electric pole or beacon prototype.",
        "member": "supply_area_distance  ::double? Read"
      },
      "max_wire_distance": {
        "name": "max_wire_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum wire distance for this entity. 0 if the entity doesn't support wires.",
        "short": "The maximum wire distance for this entity. [...]",
        "member": "max_wire_distance  ::double Read"
      },
      "max_circuit_wire_distance": {
        "name": "max_circuit_wire_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum circuit wire distance for this entity. 0 if the entity doesn't support circuit wires.",
        "short": "The maximum circuit wire distance for this entity. [...]",
        "member": "max_circuit_wire_distance  ::double Read"
      },
      "energy_usage": {
        "name": "energy_usage",
        "type": "double",
        "mode": "[R]",
        "doc": "The direct energy usage of this entity, if any.",
        "short": "The direct energy usage of this entity, if any.",
        "member": "energy_usage  ::double? Read"
      },
      "max_energy_usage": {
        "name": "max_energy_usage",
        "type": "double",
        "mode": "[R]",
        "doc": "The theoretical maximum energy usage for this entity.",
        "short": "The theoretical maximum energy usage for this entity.",
        "member": "max_energy_usage  ::double Read"
      },
      "max_energy_production": {
        "name": "max_energy_production",
        "type": "double",
        "mode": "[R]",
        "doc": "The theoretical maximum energy production for this this entity.",
        "short": "The theoretical maximum energy production for this this entity.",
        "member": "max_energy_production  ::double Read"
      },
      "effectivity": {
        "name": "effectivity",
        "type": "double",
        "mode": "[R]",
        "doc": "The effectivity of this car prototype, generator prototype.",
        "short": "The effectivity of this car prototype, generator prototype.",
        "member": "effectivity  ::double? Read"
      },
      "consumption": {
        "name": "consumption",
        "type": "double",
        "mode": "[R]",
        "doc": "The energy consumption of this car prototype.",
        "short": "The energy consumption of this car prototype.",
        "member": "consumption  ::double? Read"
      },
      "friction_force": {
        "name": "friction_force",
        "type": "double",
        "mode": "[R]",
        "doc": "The friction of this vehicle prototype.",
        "short": "The friction of this vehicle prototype.",
        "member": "friction_force  ::double? Read"
      },
      "braking_force": {
        "name": "braking_force",
        "type": "double",
        "mode": "[R]",
        "doc": "The braking force of this vehicle prototype.",
        "short": "The braking force of this vehicle prototype.",
        "member": "braking_force  ::double? Read"
      },
      "air_resistance": {
        "name": "air_resistance",
        "type": "double",
        "mode": "[R]",
        "doc": "The air resistance of this rolling stock prototype.",
        "short": "The air resistance of this rolling stock prototype.",
        "member": "air_resistance  ::double? Read"
      },
      "tank_driving": {
        "name": "tank_driving",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this car prototype uses tank controls to drive.",
        "short": "If this car prototype uses tank controls to drive.",
        "member": "tank_driving  ::boolean? Read"
      },
      "rotation_speed": {
        "name": "rotation_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The rotation speed of this car prototype.",
        "short": "The rotation speed of this car prototype.",
        "member": "rotation_speed  ::double? Read"
      },
      "turret_rotation_speed": {
        "name": "turret_rotation_speed",
        "type": "float",
        "mode": "[R]",
        "doc": "The turret rotation speed of this car prototype.",
        "short": "The turret rotation speed of this car prototype.",
        "member": "turret_rotation_speed  ::float? Read"
      },
      "guns": {
        "name": "guns",
        "type": "string",
        "mode": "[R]",
        "doc": "A mapping of the gun name to the gun prototype this prototype uses. nil if this entity prototype doesn't use guns.",
        "short": "A mapping of the gun name to the gun prototype this prototype uses. [...]",
        "member": "guns  ::dictionary[string LuaItemPrototype]? Read"
      },
      "indexed_guns": {
        "name": "indexed_guns",
        "type": "LuaItemPrototype",
        "mode": "[R]",
        "doc": "A vector of the gun prototypes of this car, spider vehicle, artillery wagon, or turret.",
        "short": "A vector of the gun prototypes of this car, spider vehicle, artillery wagon, or turret.",
        "member": "indexed_guns  ::array[LuaItemPrototype]? Read"
      },
      "speed": {
        "name": "speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The default speed of this flying robot, rolling stock or unit. For rolling stocks, this is their max_speed.",
        "short": "The default speed of this flying robot, rolling stock or unit. [...]",
        "member": "speed  ::double? Read"
      },
      "speed_multiplier_when_out_of_energy": {
        "name": "speed_multiplier_when_out_of_energy",
        "type": "float",
        "mode": "[R]",
        "doc": "The speed multiplier when this flying robot is out of energy.",
        "short": "The speed multiplier when this flying robot is out of energy.",
        "member": "speed_multiplier_when_out_of_energy  ::float? Read"
      },
      "max_payload_size": {
        "name": "max_payload_size",
        "type": "uint",
        "mode": "[R]",
        "doc": "The max payload size of this logistics or construction robot.",
        "short": "The max payload size of this logistics or construction robot.",
        "member": "max_payload_size  ::uint? Read"
      },
      "draw_cargo": {
        "name": "draw_cargo",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this logistics or construction robot renders its cargo when flying.",
        "short": "Whether this logistics or construction robot renders its cargo when flying.",
        "member": "draw_cargo  ::boolean? Read"
      },
      "energy_per_move": {
        "name": "energy_per_move",
        "type": "double",
        "mode": "[R]",
        "doc": "The energy consumed per tile moved for this flying robot.",
        "short": "The energy consumed per tile moved for this flying robot.",
        "member": "energy_per_move  ::double? Read"
      },
      "energy_per_tick": {
        "name": "energy_per_tick",
        "type": "double",
        "mode": "[R]",
        "doc": "The energy consumed per tick for this flying robot.",
        "short": "The energy consumed per tick for this flying robot.",
        "member": "energy_per_tick  ::double? Read"
      },
      "max_energy": {
        "name": "max_energy",
        "type": "double",
        "mode": "[R]",
        "doc": "The max energy for this flying robot.",
        "short": "The max energy for this flying robot.",
        "member": "max_energy  ::double? Read"
      },
      "min_to_charge": {
        "name": "min_to_charge",
        "type": "float",
        "mode": "[R]",
        "doc": "The minimum energy for this flying robot before it tries to recharge.",
        "short": "The minimum energy for this flying robot before it tries to recharge.",
        "member": "min_to_charge  ::float? Read"
      },
      "max_to_charge": {
        "name": "max_to_charge",
        "type": "float",
        "mode": "[R]",
        "doc": "The maximum energy for this flying robot above which it won't try to recharge when stationing.",
        "short": "The maximum energy for this flying robot above which it won't try to recharge when stationing.",
        "member": "max_to_charge  ::float? Read"
      },
      "burner_prototype": {
        "name": "burner_prototype",
        "type": "LuaBurnerPrototype",
        "mode": "[R]",
        "doc": "The burner energy source prototype this entity uses, if any.",
        "short": "The burner energy source prototype this entity uses, if any.",
        "member": "burner_prototype  ::LuaBurnerPrototype? Read"
      },
      "electric_energy_source_prototype": {
        "name": "electric_energy_source_prototype",
        "type": "LuaElectricEnergySourcePrototype",
        "mode": "[R]",
        "doc": "The electric energy source prototype this entity uses, if any.",
        "short": "The electric energy source prototype this entity uses, if any.",
        "member": "electric_energy_source_prototype  ::LuaElectricEnergySourcePrototype? Read"
      },
      "heat_energy_source_prototype": {
        "name": "heat_energy_source_prototype",
        "type": "LuaHeatEnergySourcePrototype",
        "mode": "[R]",
        "doc": "The heat energy source prototype this entity uses, if any.",
        "short": "The heat energy source prototype this entity uses, if any.",
        "member": "heat_energy_source_prototype  ::LuaHeatEnergySourcePrototype? Read"
      },
      "fluid_energy_source_prototype": {
        "name": "fluid_energy_source_prototype",
        "type": "LuaFluidEnergySourcePrototype",
        "mode": "[R]",
        "doc": "The fluid energy source prototype this entity uses, if any.",
        "short": "The fluid energy source prototype this entity uses, if any.",
        "member": "fluid_energy_source_prototype  ::LuaFluidEnergySourcePrototype? Read"
      },
      "void_energy_source_prototype": {
        "name": "void_energy_source_prototype",
        "type": "LuaVoidEnergySourcePrototype",
        "mode": "[R]",
        "doc": "The void energy source prototype this entity uses, if any.",
        "short": "The void energy source prototype this entity uses, if any.",
        "member": "void_energy_source_prototype  ::LuaVoidEnergySourcePrototype? Read"
      },
      "heat_buffer_prototype": {
        "name": "heat_buffer_prototype",
        "type": "LuaHeatBufferPrototype",
        "mode": "[R]",
        "doc": "The heat buffer prototype this entity uses, if any.",
        "short": "The heat buffer prototype this entity uses, if any.",
        "member": "heat_buffer_prototype  ::LuaHeatBufferPrototype? Read"
      },
      "building_grid_bit_shift": {
        "name": "building_grid_bit_shift",
        "type": "uint",
        "mode": "[R]",
        "doc": "The log2 of grid size of the building",
        "short": "The log2 of grid size of the building",
        "member": "building_grid_bit_shift  ::uint Read"
      },
      "fluid_usage_per_tick": {
        "name": "fluid_usage_per_tick",
        "type": "double",
        "mode": "[R]",
        "doc": "The fluid usage of this generator prototype.",
        "short": "The fluid usage of this generator prototype.",
        "member": "fluid_usage_per_tick  ::double? Read"
      },
      "maximum_temperature": {
        "name": "maximum_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum fluid temperature of this generator prototype.",
        "short": "The maximum fluid temperature of this generator prototype.",
        "member": "maximum_temperature  ::double? Read"
      },
      "burns_fluid": {
        "name": "burns_fluid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this generator prototype burns fluid.",
        "short": "Whether this generator prototype burns fluid.",
        "member": "burns_fluid  ::boolean? Read"
      },
      "scale_fluid_usage": {
        "name": "scale_fluid_usage",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this generator prototype scales fluid usage.",
        "short": "Whether this generator prototype scales fluid usage.",
        "member": "scale_fluid_usage  ::boolean? Read"
      },
      "destroy_non_fuel_fluid": {
        "name": "destroy_non_fuel_fluid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this generator prototype destroys non-fuel fluids.",
        "short": "Whether this generator prototype destroys non-fuel fluids.",
        "member": "destroy_non_fuel_fluid  ::boolean? Read"
      },
      "max_power_output": {
        "name": "max_power_output",
        "type": "double",
        "mode": "[R]",
        "doc": "The default maximum power output of this generator prototype.",
        "short": "The default maximum power output of this generator prototype.",
        "member": "max_power_output  ::double? Read"
      },
      "target_temperature": {
        "name": "target_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "The target temperature of this boiler prototype.",
        "short": "The target temperature of this boiler prototype.",
        "member": "target_temperature  ::double? Read"
      },
      "boiler_mode": {
        "name": "boiler_mode",
        "mode": "[R]",
        "doc": "The boiler operation mode of this boiler prototype.",
        "short": "The boiler operation mode of this boiler prototype.",
        "member": "boiler_mode  ::\"heat-water-inside\" or \"output-to-separate-pipe\"? Read"
      },
      "fluid": {
        "name": "fluid",
        "type": "LuaFluidPrototype",
        "mode": "[R]",
        "doc": "The fluid this offshore pump produces.",
        "short": "The fluid this offshore pump produces.",
        "member": "fluid  ::LuaFluidPrototype? Read"
      },
      "fluid_capacity": {
        "name": "fluid_capacity",
        "type": "double",
        "mode": "[R]",
        "doc": "The fluid capacity of this entity or 0 if this entity doesn't support fluids.",
        "short": "The fluid capacity of this entity or 0 if this entity doesn't support fluids.",
        "member": "fluid_capacity  ::double Read"
      },
      "pumping_speed": {
        "name": "pumping_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The pumping speed of this offshore or normal pump.",
        "short": "The pumping speed of this offshore or normal pump.",
        "member": "pumping_speed  ::double? Read"
      },
      "stack": {
        "name": "stack",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this inserter is a stack-type.",
        "short": "Whether this inserter is a stack-type.",
        "member": "stack  ::boolean? Read"
      },
      "allow_custom_vectors": {
        "name": "allow_custom_vectors",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this inserter allows custom pickup and drop vectors.",
        "short": "Whether this inserter allows custom pickup and drop vectors.",
        "member": "allow_custom_vectors  ::boolean? Read"
      },
      "allow_burner_leech": {
        "name": "allow_burner_leech",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this inserter allows burner leeching.",
        "short": "Whether this inserter allows burner leeching.",
        "member": "allow_burner_leech  ::boolean? Read"
      },
      "inserter_extension_speed": {
        "name": "inserter_extension_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The extension speed of this inserter.",
        "short": "The extension speed of this inserter.",
        "member": "inserter_extension_speed  ::double? Read"
      },
      "inserter_rotation_speed": {
        "name": "inserter_rotation_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The rotation speed of this inserter.",
        "short": "The rotation speed of this inserter.",
        "member": "inserter_rotation_speed  ::double? Read"
      },
      "inserter_pickup_position": {
        "name": "inserter_pickup_position",
        "type": "Vector",
        "mode": "[R]",
        "doc": "The pickup position for this inserter.",
        "short": "The pickup position for this inserter.",
        "member": "inserter_pickup_position  ::Vector? Read"
      },
      "inserter_drop_position": {
        "name": "inserter_drop_position",
        "type": "Vector",
        "mode": "[R]",
        "doc": "The drop position for this inserter.",
        "short": "The drop position for this inserter.",
        "member": "inserter_drop_position  ::Vector? Read"
      },
      "inserter_chases_belt_items": {
        "name": "inserter_chases_belt_items",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True if this inserter chases items on belts for pickup.",
        "short": "True if this inserter chases items on belts for pickup.",
        "member": "inserter_chases_belt_items  ::boolean? Read"
      },
      "count_as_rock_for_filtered_deconstruction": {
        "name": "count_as_rock_for_filtered_deconstruction",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this simple-entity is counted as a rock for the deconstruction planner \"trees and rocks only\" filter.",
        "short": "If this simple-entity is counted as a rock for the deconstruction planner \"trees and rocks only\" filter.",
        "member": "count_as_rock_for_filtered_deconstruction  ::boolean? Read"
      },
      "filter_count": {
        "name": "filter_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The filter count of this inserter, loader, or logistic chest. For logistic containers, nil means no limit.",
        "short": "The filter count of this inserter, loader, or logistic chest. [...]",
        "member": "filter_count  ::uint? Read"
      },
      "time_to_live": {
        "name": "time_to_live",
        "type": "uint",
        "mode": "[R]",
        "doc": "The time to live for this prototype or 0 if prototype doesn't have time_to_live or time_before_removed.",
        "short": "The time to live for this prototype or 0 if prototype doesn't have time_to_live or time_before_removed.",
        "member": "time_to_live  ::uint Read"
      },
      "distribution_effectivity": {
        "name": "distribution_effectivity",
        "type": "double",
        "mode": "[R]",
        "doc": "The distribution effectivity for this beacon prototype.",
        "short": "The distribution effectivity for this beacon prototype.",
        "member": "distribution_effectivity  ::double? Read"
      },
      "explosion_beam": {
        "name": "explosion_beam",
        "type": "double",
        "mode": "[R]",
        "doc": "Whether this explosion has a beam.",
        "short": "Whether this explosion has a beam.",
        "member": "explosion_beam  ::double? Read"
      },
      "explosion_rotate": {
        "name": "explosion_rotate",
        "type": "double",
        "mode": "[R]",
        "doc": "Whether this explosion rotates.",
        "short": "Whether this explosion rotates.",
        "member": "explosion_rotate  ::double? Read"
      },
      "tree_color_count": {
        "name": "tree_color_count",
        "type": "uint8",
        "mode": "[R]",
        "doc": "If it is a tree, return the number of colors it supports.",
        "short": "If it is a tree, return the number of colors it supports.",
        "member": "tree_color_count  ::uint8? Read"
      },
      "alert_when_damaged": {
        "name": "alert_when_damaged",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this entity raises an alert when damaged.",
        "short": "Whether this entity raises an alert when damaged.",
        "member": "alert_when_damaged  ::boolean? Read"
      },
      "alert_when_attacking": {
        "name": "alert_when_attacking",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this turret raises an alert when attacking",
        "short": "Whether this turret raises an alert when attacking",
        "member": "alert_when_attacking  ::boolean? Read"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The color of the prototype, if any.",
        "short": "The color of the prototype, if any.",
        "member": "color  ::Color? Read"
      },
      "collision_mask_collides_with_self": {
        "name": "collision_mask_collides_with_self",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Does this prototype collision mask collide with itself?",
        "short": "Does this prototype collision mask collide with itself?",
        "member": "collision_mask_collides_with_self  ::boolean Read"
      },
      "collision_mask_collides_with_tiles_only": {
        "name": "collision_mask_collides_with_tiles_only",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Does this prototype collision mask collide with tiles only?",
        "short": "Does this prototype collision mask collide with tiles only?",
        "member": "collision_mask_collides_with_tiles_only  ::boolean Read"
      },
      "collision_mask_considers_tile_transitions": {
        "name": "collision_mask_considers_tile_transitions",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Does this prototype collision mask consider tile transitions?",
        "short": "Does this prototype collision mask consider tile transitions?",
        "member": "collision_mask_considers_tile_transitions  ::boolean Read"
      },
      "allowed_effects": {
        "name": "allowed_effects",
        "type": "string",
        "mode": "[R]",
        "doc": "The allowed module effects for this entity, if any.",
        "short": "The allowed module effects for this entity, if any.",
        "member": "allowed_effects  ::dictionary[string boolean]? Read"
      },
      "rocket_parts_required": {
        "name": "rocket_parts_required",
        "type": "uint",
        "mode": "[R]",
        "doc": "The rocket parts required for this rocket silo prototype.",
        "short": "The rocket parts required for this rocket silo prototype.",
        "member": "rocket_parts_required  ::uint? Read"
      },
      "rocket_rising_delay": {
        "name": "rocket_rising_delay",
        "type": "uint8",
        "mode": "[R]",
        "doc": "The rocket rising delay for this rocket silo prototype.",
        "short": "The rocket rising delay for this rocket silo prototype.",
        "member": "rocket_rising_delay  ::uint8? Read"
      },
      "launch_wait_time": {
        "name": "launch_wait_time",
        "type": "uint8",
        "mode": "[R]",
        "doc": "The rocket launch delay for this rocket silo prototype.",
        "short": "The rocket launch delay for this rocket silo prototype.",
        "member": "launch_wait_time  ::uint8? Read"
      },
      "light_blinking_speed": {
        "name": "light_blinking_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The light blinking speed for this rocket silo prototype.",
        "short": "The light blinking speed for this rocket silo prototype.",
        "member": "light_blinking_speed  ::double? Read"
      },
      "door_opening_speed": {
        "name": "door_opening_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The door opening speed for this rocket silo prototype.",
        "short": "The door opening speed for this rocket silo prototype.",
        "member": "door_opening_speed  ::double? Read"
      },
      "rising_speed": {
        "name": "rising_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The rising speed for this rocket silo rocket prototype.",
        "short": "The rising speed for this rocket silo rocket prototype.",
        "member": "rising_speed  ::double? Read"
      },
      "engine_starting_speed": {
        "name": "engine_starting_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The engine starting speed for this rocket silo rocket prototype.",
        "short": "The engine starting speed for this rocket silo rocket prototype.",
        "member": "engine_starting_speed  ::double? Read"
      },
      "flying_speed": {
        "name": "flying_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The flying speed for this rocket silo rocket prototype.",
        "short": "The flying speed for this rocket silo rocket prototype.",
        "member": "flying_speed  ::double? Read"
      },
      "flying_acceleration": {
        "name": "flying_acceleration",
        "type": "double",
        "mode": "[R]",
        "doc": "The flying acceleration for this rocket silo rocket prototype.",
        "short": "The flying acceleration for this rocket silo rocket prototype.",
        "member": "flying_acceleration  ::double? Read"
      },
      "fixed_recipe": {
        "name": "fixed_recipe",
        "type": "string",
        "mode": "[R]",
        "doc": "The fixed recipe name for this assembling machine prototype, if any.",
        "short": "The fixed recipe name for this assembling machine prototype, if any.",
        "member": "fixed_recipe  ::string? Read"
      },
      "construction_radius": {
        "name": "construction_radius",
        "type": "double",
        "mode": "[R]",
        "doc": "The construction radius for this roboport prototype.",
        "short": "The construction radius for this roboport prototype.",
        "member": "construction_radius  ::double? Read"
      },
      "logistic_radius": {
        "name": "logistic_radius",
        "type": "double",
        "mode": "[R]",
        "doc": "The logistic radius for this roboport prototype.",
        "short": "The logistic radius for this roboport prototype.",
        "member": "logistic_radius  ::double? Read"
      },
      "energy_per_hit_point": {
        "name": "energy_per_hit_point",
        "type": "double",
        "mode": "[R]",
        "doc": "The energy used per hitpoint taken for this vehicle during collisions.",
        "short": "The energy used per hitpoint taken for this vehicle during collisions.",
        "member": "energy_per_hit_point  ::double? Read"
      },
      "create_ghost_on_death": {
        "name": "create_ghost_on_death",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this prototype will attempt to create a ghost of itself on death.",
        "short": "If this prototype will attempt to create a ghost of itself on death.",
        "member": "create_ghost_on_death  ::boolean Read"
      },
      "ammo_category": {
        "name": "ammo_category",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the ammo category of this land mine.",
        "short": "Name of the ammo category of this land mine.",
        "member": "ammo_category  ::string? Read"
      },
      "timeout": {
        "name": "timeout",
        "type": "uint",
        "mode": "[R]",
        "doc": "The time it takes this land mine to arm.",
        "short": "The time it takes this land mine to arm.",
        "member": "timeout  ::uint? Read"
      },
      "trigger_collision_mask": {
        "name": "trigger_collision_mask",
        "type": "CollisionMaskWithFlags",
        "mode": "[R]",
        "doc": "The collision mask entities must collide with to make this landmine blow up.",
        "short": "The collision mask entities must collide with to make this landmine blow up.",
        "member": "trigger_collision_mask  ::CollisionMaskWithFlags? Read"
      },
      "fluidbox_prototypes": {
        "name": "fluidbox_prototypes",
        "type": "LuaFluidBoxPrototype",
        "mode": "[R]",
        "doc": "The fluidbox prototypes for this entity.",
        "short": "The fluidbox prototypes for this entity.",
        "member": "fluidbox_prototypes  ::array[LuaFluidBoxPrototype] Read"
      },
      "neighbour_bonus": {
        "name": "neighbour_bonus",
        "type": "double",
        "mode": "[R]",
        "member": "neighbour_bonus  ::double? Read"
      },
      "container_distance": {
        "name": "container_distance",
        "type": "double",
        "mode": "[R]",
        "member": "container_distance  ::double? Read"
      },
      "belt_distance": {
        "name": "belt_distance",
        "type": "double",
        "mode": "[R]",
        "member": "belt_distance  ::double? Read"
      },
      "belt_length": {
        "name": "belt_length",
        "type": "double",
        "mode": "[R]",
        "member": "belt_length  ::double? Read"
      },
      "is_building": {
        "name": "is_building",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Everything in the following list is considered a building.",
        "short": "Everything in the following list is considered a building. [...]",
        "member": "is_building  ::boolean Read"
      },
      "automated_ammo_count": {
        "name": "automated_ammo_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The amount of ammo that inserters automatically insert into this ammo-turret or artillery-turret.",
        "short": "The amount of ammo that inserters automatically insert into this ammo-turret or artillery-turret.",
        "member": "automated_ammo_count  ::uint? Read"
      },
      "max_speed": {
        "name": "max_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The max speed of this projectile or flying robot prototype.",
        "short": "The max speed of this projectile or flying robot prototype.",
        "member": "max_speed  ::double? Read"
      },
      "darkness_for_all_lamps_on": {
        "name": "darkness_for_all_lamps_on",
        "type": "float",
        "mode": "[R]",
        "doc": "Value between 0 and 1 darkness where all lamps of this lamp prototype are on.",
        "short": "Value between 0 and 1 darkness where all lamps of this lamp prototype are on.",
        "member": "darkness_for_all_lamps_on  ::float? Read"
      },
      "darkness_for_all_lamps_off": {
        "name": "darkness_for_all_lamps_off",
        "type": "float",
        "mode": "[R]",
        "doc": "Value between 0 and 1 darkness where all lamps of this lamp prototype are off.",
        "short": "Value between 0 and 1 darkness where all lamps of this lamp prototype are off.",
        "member": "darkness_for_all_lamps_off  ::float? Read"
      },
      "always_on": {
        "name": "always_on",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether the lamp is always on (except when out of power or turned off by the circuit network).",
        "short": "Whether the lamp is always on (except when out of power or turned off by the circuit network).",
        "member": "always_on  ::boolean? Read"
      },
      "min_darkness_to_spawn": {
        "name": "min_darkness_to_spawn",
        "type": "float",
        "mode": "[R]",
        "doc": "The minimum darkness at which this unit spawner can spawn entities.",
        "short": "The minimum darkness at which this unit spawner can spawn entities.",
        "member": "min_darkness_to_spawn  ::float? Read"
      },
      "max_darkness_to_spawn": {
        "name": "max_darkness_to_spawn",
        "type": "float",
        "mode": "[R]",
        "doc": "The maximum darkness at which this unit spawner can spawn entities.",
        "short": "The maximum darkness at which this unit spawner can spawn entities.",
        "member": "max_darkness_to_spawn  ::float? Read"
      },
      "call_for_help_radius": {
        "name": "call_for_help_radius",
        "type": "double",
        "mode": "[R]",
        "member": "call_for_help_radius  ::double? Read"
      },
      "max_count_of_owned_units": {
        "name": "max_count_of_owned_units",
        "type": "double",
        "mode": "[R]",
        "doc": "Count of enemies this spawner can sustain.",
        "short": "Count of enemies this spawner can sustain.",
        "member": "max_count_of_owned_units  ::double? Read"
      },
      "max_friends_around_to_spawn": {
        "name": "max_friends_around_to_spawn",
        "type": "double",
        "mode": "[R]",
        "doc": "How many friendly units are required within the spawning_radius of this spawner for it to stop producing more units.",
        "short": "How many friendly units are required within the spawning_radius of this spawner for it to stop producing more units.",
        "member": "max_friends_around_to_spawn  ::double? Read"
      },
      "spawning_radius": {
        "name": "spawning_radius",
        "type": "double",
        "mode": "[R]",
        "doc": "How far from the spawner can the units be spawned.",
        "short": "How far from the spawner can the units be spawned.",
        "member": "spawning_radius  ::double? Read"
      },
      "spawning_spacing": {
        "name": "spawning_spacing",
        "type": "double",
        "mode": "[R]",
        "doc": "What spaces should be between the spawned units.",
        "short": "What spaces should be between the spawned units.",
        "member": "spawning_spacing  ::double? Read"
      },
      "radius": {
        "name": "radius",
        "type": "double",
        "mode": "[R]",
        "doc": "The radius of this entity prototype.",
        "short": "The radius of this entity prototype.",
        "member": "radius  ::double Read"
      },
      "cliff_explosive_prototype": {
        "name": "cliff_explosive_prototype",
        "type": "string",
        "mode": "[R]",
        "doc": "The item prototype name used to destroy this cliff.",
        "short": "The item prototype name used to destroy this cliff.",
        "member": "cliff_explosive_prototype  ::string? Read"
      },
      "rocket_entity_prototype": {
        "name": "rocket_entity_prototype",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The rocket entity prototype associated with this rocket silo prototype.",
        "short": "The rocket entity prototype associated with this rocket silo prototype.",
        "member": "rocket_entity_prototype  ::LuaEntityPrototype? Read"
      },
      "has_belt_immunity": {
        "name": "has_belt_immunity",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this unit, car, or character prototype has belt immunity.",
        "short": "Whether this unit, car, or character prototype has belt immunity.",
        "member": "has_belt_immunity  ::boolean? Read"
      },
      "vision_distance": {
        "name": "vision_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The vision distance of this unit prototype.",
        "short": "The vision distance of this unit prototype.",
        "member": "vision_distance  ::double? Read"
      },
      "pollution_to_join_attack": {
        "name": "pollution_to_join_attack",
        "type": "float",
        "mode": "[R]",
        "doc": "The amount of pollution that has to be absorbed by the unit's spawner before the unit will leave the spawner and attack the source of the pollution.",
        "short": "The amount of pollution that has to be absorbed by the unit's spawner before the unit will leave the spawner and attack the source of the pollution.",
        "member": "pollution_to_join_attack  ::float? Read"
      },
      "min_pursue_time": {
        "name": "min_pursue_time",
        "type": "uint",
        "mode": "[R]",
        "doc": "The minimum pursue time of this unit prototype.",
        "short": "The minimum pursue time of this unit prototype.",
        "member": "min_pursue_time  ::uint? Read"
      },
      "max_pursue_distance": {
        "name": "max_pursue_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum pursue distance of this unit prototype.",
        "short": "The maximum pursue distance of this unit prototype.",
        "member": "max_pursue_distance  ::double? Read"
      },
      "radar_range": {
        "name": "radar_range",
        "type": "uint",
        "mode": "[R]",
        "doc": "The radar range of this unit prototype.",
        "short": "The radar range of this unit prototype.",
        "member": "radar_range  ::uint? Read"
      },
      "move_while_shooting": {
        "name": "move_while_shooting",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this unit prototype can move while shooting.",
        "short": "Whether this unit prototype can move while shooting.",
        "member": "move_while_shooting  ::boolean? Read"
      },
      "can_open_gates": {
        "name": "can_open_gates",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this unit prototype can open gates.",
        "short": "Whether this unit prototype can open gates.",
        "member": "can_open_gates  ::boolean? Read"
      },
      "affected_by_tiles": {
        "name": "affected_by_tiles",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this unit prototype is affected by tile walking speed modifiers.",
        "short": "Whether this unit prototype is affected by tile walking speed modifiers.",
        "member": "affected_by_tiles  ::boolean? Read"
      },
      "distraction_cooldown": {
        "name": "distraction_cooldown",
        "type": "uint",
        "mode": "[R]",
        "doc": "The distraction cooldown of this unit prototype.",
        "short": "The distraction cooldown of this unit prototype.",
        "member": "distraction_cooldown  ::uint? Read"
      },
      "spawning_time_modifier": {
        "name": "spawning_time_modifier",
        "type": "double",
        "mode": "[R]",
        "doc": "The spawning time modifier of this unit prototype.",
        "short": "The spawning time modifier of this unit prototype.",
        "member": "spawning_time_modifier  ::double? Read"
      },
      "alert_icon_shift": {
        "name": "alert_icon_shift",
        "type": "Vector",
        "mode": "[R]",
        "doc": "The alert icon shift of this entity prototype.",
        "short": "The alert icon shift of this entity prototype.",
        "member": "alert_icon_shift  ::Vector Read"
      },
      "alert_icon_scale": {
        "name": "alert_icon_scale",
        "type": "float",
        "mode": "[R]",
        "doc": "The alert icon scale of this entity prototype.",
        "short": "The alert icon scale of this entity prototype.",
        "member": "alert_icon_scale  ::float Read"
      },
      "lab_inputs": {
        "name": "lab_inputs",
        "type": "string",
        "mode": "[R]",
        "doc": "The item prototype names that are the inputs of this lab prototype.",
        "short": "The item prototype names that are the inputs of this lab prototype.",
        "member": "lab_inputs  ::array[string]? Read"
      },
      "researching_speed": {
        "name": "researching_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The base researching speed of this lab prototype.",
        "short": "The base researching speed of this lab prototype.",
        "member": "researching_speed  ::double? Read"
      },
      "item_slot_count": {
        "name": "item_slot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The item slot count of this constant combinator prototype.",
        "short": "The item slot count of this constant combinator prototype.",
        "member": "item_slot_count  ::uint? Read"
      },
      "base_productivity": {
        "name": "base_productivity",
        "type": "double",
        "mode": "[R]",
        "doc": "The base productivity of this crafting machine, lab, or mining drill.",
        "short": "The base productivity of this crafting machine, lab, or mining drill.",
        "member": "base_productivity  ::double? Read"
      },
      "allow_access_to_all_forces": {
        "name": "allow_access_to_all_forces",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this market allows access to all forces or just friendly ones.",
        "short": "Whether this market allows access to all forces or just friendly ones.",
        "member": "allow_access_to_all_forces  ::boolean? Read"
      },
      "supports_direction": {
        "name": "supports_direction",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this entity prototype could possibly ever be rotated.",
        "short": "Whether this entity prototype could possibly ever be rotated.",
        "member": "supports_direction  ::boolean Read"
      },
      "terrain_friction_modifier": {
        "name": "terrain_friction_modifier",
        "type": "float",
        "mode": "[R]",
        "doc": "The terrain friction modifier for this vehicle.",
        "short": "The terrain friction modifier for this vehicle.",
        "member": "terrain_friction_modifier  ::float? Read"
      },
      "allow_passengers": {
        "name": "allow_passengers",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this vehicle allows passengers.",
        "short": "Whether this vehicle allows passengers.",
        "member": "allow_passengers  ::boolean? Read"
      },
      "max_distance_of_sector_revealed": {
        "name": "max_distance_of_sector_revealed",
        "type": "uint",
        "mode": "[R]",
        "doc": "The radius of the area this radar can chart, in chunks.",
        "short": "The radius of the area this radar can chart, in chunks.",
        "member": "max_distance_of_sector_revealed  ::uint? Read"
      },
      "max_distance_of_nearby_sector_revealed": {
        "name": "max_distance_of_nearby_sector_revealed",
        "type": "uint",
        "mode": "[R]",
        "doc": "The radius of the area constantly revealed by this radar, in chunks.",
        "short": "The radius of the area constantly revealed by this radar, in chunks.",
        "member": "max_distance_of_nearby_sector_revealed  ::uint? Read"
      },
      "adjacent_tile_collision_box": {
        "name": "adjacent_tile_collision_box",
        "type": "BoundingBox",
        "mode": "[R]",
        "doc": "The bounding box that specifies which tiles adjacent to the offshore pump should be checked.",
        "short": "The bounding box that specifies which tiles adjacent to the offshore pump should be checked.",
        "member": "adjacent_tile_collision_box  ::BoundingBox? Read"
      },
      "adjacent_tile_collision_mask": {
        "name": "adjacent_tile_collision_mask",
        "type": "CollisionMask",
        "mode": "[R]",
        "doc": "Tiles adjacent to the offshore pump must not collide with this collision mask.",
        "short": "Tiles adjacent to the offshore pump must not collide with this collision mask.",
        "member": "adjacent_tile_collision_mask  ::CollisionMask? Read"
      },
      "adjacent_tile_collision_test": {
        "name": "adjacent_tile_collision_test",
        "type": "CollisionMask",
        "mode": "[R]",
        "doc": "If this mask is not empty, tiles adjacent to the offshore pump must not collide with this collision mask.",
        "short": "If this mask is not empty, tiles adjacent to the offshore pump must not collide with this collision mask.",
        "member": "adjacent_tile_collision_test  ::CollisionMask? Read"
      },
      "center_collision_mask": {
        "name": "center_collision_mask",
        "type": "CollisionMask",
        "mode": "[R]",
        "doc": "The collision mask used only for collision test with tile directly at offshore pump position.",
        "short": "The collision mask used only for collision test with tile directly at offshore pump position.",
        "member": "center_collision_mask  ::CollisionMask? Read"
      },
      "grid_prototype": {
        "name": "grid_prototype",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[R]",
        "doc": "The equipment grid prototype for this entity, if any.",
        "short": "The equipment grid prototype for this entity, if any.",
        "member": "grid_prototype  ::LuaEquipmentGridPrototype? Read"
      },
      "remove_decoratives": {
        "name": "remove_decoratives",
        "type": "string",
        "mode": "[R]",
        "doc": "Whether this entity should remove decoratives that collide with it when this entity is built. Possible values are \"automatic\", \"true\" and \"false\".",
        "short": "Whether this entity should remove decoratives that collide with it when this entity is built. [...]",
        "member": "remove_decoratives  ::string Read"
      },
      "related_underground_belt": {
        "name": "related_underground_belt",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "member": "related_underground_belt  ::LuaEntityPrototype? Read"
      },
      "inserter_stack_size_bonus": {
        "name": "inserter_stack_size_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "The built-in stack size bonus of this inserter prototype.",
        "short": "The built-in stack size bonus of this inserter prototype.",
        "member": "inserter_stack_size_bonus  ::double? Read"
      },
      "protected_from_tile_building": {
        "name": "protected_from_tile_building",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True if this entity prototype should be included during tile collision checks with LuaTilePrototype::check_collision_with_entities enabled.",
        "short": "True if this entity prototype should be included during tile collision checks with LuaTilePrototype::check_collision_with_entities enabled.",
        "member": "protected_from_tile_building  ::boolean Read"
      },
      "is_entity_with_owner": {
        "name": "is_entity_with_owner",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True if this is entity-with-owner",
        "short": "True if this is entity-with-owner",
        "member": "is_entity_with_owner  ::boolean Read"
      },
      "is_military_target": {
        "name": "is_military_target",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True if this entity-with-owner is military target",
        "short": "True if this entity-with-owner is military target",
        "member": "is_military_target  ::boolean? Read"
      },
      "allow_run_time_change_of_is_military_target": {
        "name": "allow_run_time_change_of_is_military_target",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True if this entity-with-owner's is_military_target can be changed run-time (on the entity, not on the prototype itself)",
        "short": "True if this entity-with-owner's is_military_target can be changed run-time (on the entity, not on the prototype itself)",
        "member": "allow_run_time_change_of_is_military_target  ::boolean? Read"
      },
      "logistic_parameters": {
        "name": "logistic_parameters",
        "mode": "[R]",
        "doc": "The logistic parameters for this roboport.",
        "short": "The logistic parameters for this roboport.",
        "member": "logistic_parameters  ::table? Read",
        "args": {
          "spawn_and_station_height": {
            "name": "spawn_and_station_height",
            "type": "float",
            "doc": ""
          },
          "spawn_and_station_shadow_height_offset": {
            "name": "spawn_and_station_shadow_height_offset",
            "type": "float",
            "doc": ""
          },
          "charge_approach_distance": {
            "name": "charge_approach_distance",
            "type": "float",
            "doc": ""
          },
          "logistic_radius": {
            "name": "logistic_radius",
            "type": "float",
            "doc": ""
          },
          "construction_radius": {
            "name": "construction_radius",
            "type": "float",
            "doc": ""
          },
          "charging_station_count": {
            "name": "charging_station_count",
            "type": "uint",
            "doc": ""
          },
          "charging_distance": {
            "name": "charging_distance",
            "type": "float",
            "doc": ""
          },
          "charging_station_shift": {
            "name": "charging_station_shift",
            "type": "Vector",
            "doc": ""
          },
          "charging_energy": {
            "name": "charging_energy",
            "type": "double",
            "doc": ""
          },
          "charging_threshold_distance": {
            "name": "charging_threshold_distance",
            "type": "float",
            "doc": ""
          },
          "robot_vertical_acceleration": {
            "name": "robot_vertical_acceleration",
            "type": "float",
            "doc": ""
          },
          "stationing_offset": {
            "name": "stationing_offset",
            "type": "Vector",
            "doc": ""
          },
          "robot_limit": {
            "name": "robot_limit",
            "type": "uint",
            "doc": ""
          },
          "logistics_connection_distance": {
            "name": "logistics_connection_distance",
            "type": "float",
            "doc": ""
          },
          "robots_shrink_when_entering_and_exiting": {
            "name": "robots_shrink_when_entering_and_exiting",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "height": {
        "name": "height",
        "type": "double",
        "mode": "[R]",
        "doc": "The height of this spider vehicle prototype.",
        "short": "The height of this spider vehicle prototype.",
        "member": "height  ::double? Read"
      },
      "torso_rotation_speed": {
        "name": "torso_rotation_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The torso rotation speed of this spider vehicle prototype.",
        "short": "The torso rotation speed of this spider vehicle prototype.",
        "member": "torso_rotation_speed  ::double? Read"
      },
      "torso_bob_speed": {
        "name": "torso_bob_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The torso bob speed of this spider vehicle prototype.",
        "short": "The torso bob speed of this spider vehicle prototype.",
        "member": "torso_bob_speed  ::double? Read"
      },
      "automatic_weapon_cycling": {
        "name": "automatic_weapon_cycling",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this spider vehicle prototype automatically cycles weapons.",
        "short": "Whether this spider vehicle prototype automatically cycles weapons.",
        "member": "automatic_weapon_cycling  ::boolean? Read"
      },
      "chain_shooting_cooldown_modifier": {
        "name": "chain_shooting_cooldown_modifier",
        "type": "double",
        "mode": "[R]",
        "doc": "The chain shooting cooldown modifier of this spider vehicle prototype.",
        "short": "The chain shooting cooldown modifier of this spider vehicle prototype.",
        "member": "chain_shooting_cooldown_modifier  ::double? Read"
      },
      "chunk_exploration_radius": {
        "name": "chunk_exploration_radius",
        "type": "double",
        "mode": "[R]",
        "doc": "The chunk exploration radius of this spider vehicle prototype.",
        "short": "The chunk exploration radius of this spider vehicle prototype.",
        "member": "chunk_exploration_radius  ::double? Read"
      },
      "animation_speed_coefficient": {
        "name": "animation_speed_coefficient",
        "type": "double",
        "mode": "[R]",
        "doc": "The animation speed coefficient of this belt connectable prototype.",
        "short": "The animation speed coefficient of this belt connectable prototype.",
        "member": "animation_speed_coefficient  ::double? Read"
      },
      "manual_range_modifier": {
        "name": "manual_range_modifier",
        "type": "double",
        "mode": "[R]",
        "doc": "The manual range modifier for this artillery turret or wagon prototype.",
        "short": "The manual range modifier for this artillery turret or wagon prototype.",
        "member": "manual_range_modifier  ::double? Read"
      },
      "dying_speed": {
        "name": "dying_speed",
        "type": "float",
        "mode": "[R]",
        "doc": "The dying time of this corpse prototype.",
        "short": "The dying time of this corpse prototype.",
        "member": "dying_speed  ::float? Read"
      },
      "active_energy_usage": {
        "name": "active_energy_usage",
        "type": "double",
        "mode": "[R]",
        "doc": "The active energy usage of this rocket silo or combinator prototype.",
        "short": "The active energy usage of this rocket silo or combinator prototype.",
        "member": "active_energy_usage  ::double? Read"
      },
      "lamp_energy_usage": {
        "name": "lamp_energy_usage",
        "type": "double",
        "mode": "[R]",
        "doc": "The lamp energy usage of this rocket silo prototype.",
        "short": "The lamp energy usage of this rocket silo prototype.",
        "member": "lamp_energy_usage  ::double? Read"
      },
      "use_exact_mode": {
        "name": "use_exact_mode",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this logistic container prototype uses exact mode",
        "short": "Whether this logistic container prototype uses exact mode",
        "member": "use_exact_mode  ::boolean? Read"
      },
      "tile_width": {
        "name": "tile_width",
        "type": "uint",
        "mode": "[R]",
        "doc": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension)",
        "short": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension)",
        "member": "tile_width  ::uint Read"
      },
      "tile_height": {
        "name": "tile_height",
        "type": "uint",
        "mode": "[R]",
        "doc": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension)",
        "short": "Specifies the tiling size of the entity, is used to decide, if the center should be in the center of the tile (odd tile size dimension) or on the tile border (even tile size dimension)",
        "member": "tile_height  ::uint Read"
      },
      "vertical_selection_shift": {
        "name": "vertical_selection_shift",
        "type": "double",
        "mode": "[R]",
        "doc": "Vertical selection shift used by rolling stocks. It affects selection box vertical position but is also used to shift rolling stock graphics along the rails to fine tune train's look.",
        "short": "Vertical selection shift used by rolling stocks. [...]",
        "member": "vertical_selection_shift  ::double? Read"
      },
      "spawn_decoration": {
        "name": "spawn_decoration",
        "type": "TriggerEffectItem",
        "mode": "[R]",
        "member": "spawn_decoration  ::array[TriggerEffectItem]? Read"
      },
      "spawn_decorations_on_expansion": {
        "name": "spawn_decorations_on_expansion",
        "type": "boolean",
        "mode": "[R]",
        "member": "spawn_decorations_on_expansion  ::boolean? Read"
      },
      "connection_distance": {
        "name": "connection_distance",
        "type": "double",
        "mode": "[R]",
        "member": "connection_distance  ::double? Read"
      },
      "joint_distance": {
        "name": "joint_distance",
        "type": "double",
        "mode": "[R]",
        "member": "joint_distance  ::double? Read"
      },
      "radius_visualisation_specification": {
        "name": "radius_visualisation_specification",
        "type": "RadiusVisualisationSpecification",
        "mode": "[R]",
        "member": "radius_visualisation_specification  ::RadiusVisualisationSpecification? Read"
      },
      "vector_to_place_result": {
        "name": "vector_to_place_result",
        "type": "Vector",
        "mode": "[R]",
        "member": "vector_to_place_result  ::Vector? Read"
      },
      "running_speed": {
        "name": "running_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "The current movement speed of this character, including effects from exoskeletons, tiles, stickers and shooting.",
        "short": "The current movement speed of this character, including effects from exoskeletons, tiles, stickers and shooting.",
        "member": "running_speed  ::double? Read"
      },
      "maximum_corner_sliding_distance": {
        "name": "maximum_corner_sliding_distance",
        "type": "double",
        "mode": "[R]",
        "member": "maximum_corner_sliding_distance  ::double? Read"
      },
      "build_distance": {
        "name": "build_distance",
        "type": "uint",
        "mode": "[R]",
        "member": "build_distance  ::uint? Read"
      },
      "drop_item_distance": {
        "name": "drop_item_distance",
        "type": "uint",
        "mode": "[R]",
        "member": "drop_item_distance  ::uint? Read"
      },
      "reach_distance": {
        "name": "reach_distance",
        "type": "uint",
        "mode": "[R]",
        "member": "reach_distance  ::uint? Read"
      },
      "reach_resource_distance": {
        "name": "reach_resource_distance",
        "type": "double",
        "mode": "[R]",
        "member": "reach_resource_distance  ::double? Read"
      },
      "item_pickup_distance": {
        "name": "item_pickup_distance",
        "type": "double",
        "mode": "[R]",
        "member": "item_pickup_distance  ::double? Read"
      },
      "loot_pickup_distance": {
        "name": "loot_pickup_distance",
        "type": "double",
        "mode": "[R]",
        "member": "loot_pickup_distance  ::double? Read"
      },
      "enter_vehicle_distance": {
        "name": "enter_vehicle_distance",
        "type": "double",
        "mode": "[R]",
        "member": "enter_vehicle_distance  ::double? Read"
      },
      "ticks_to_keep_gun": {
        "name": "ticks_to_keep_gun",
        "type": "uint",
        "mode": "[R]",
        "member": "ticks_to_keep_gun  ::uint? Read"
      },
      "ticks_to_keep_aiming_direction": {
        "name": "ticks_to_keep_aiming_direction",
        "type": "uint",
        "mode": "[R]",
        "member": "ticks_to_keep_aiming_direction  ::uint? Read"
      },
      "ticks_to_stay_in_combat": {
        "name": "ticks_to_stay_in_combat",
        "type": "uint",
        "mode": "[R]",
        "member": "ticks_to_stay_in_combat  ::uint? Read"
      },
      "respawn_time": {
        "name": "respawn_time",
        "type": "uint",
        "mode": "[R]",
        "member": "respawn_time  ::uint? Read"
      },
      "damage_hit_tint": {
        "name": "damage_hit_tint",
        "type": "Color",
        "mode": "[R]",
        "member": "damage_hit_tint  ::Color? Read"
      },
      "character_corpse": {
        "name": "character_corpse",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "member": "character_corpse  ::LuaEntityPrototype? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEquipment": {
    "name": "LuaEquipment",
    "type": "LuaEquipment",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this equipment.",
        "short": "Name of this equipment.",
        "member": "name  ::string Read"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "Type of this equipment.",
        "short": "Type of this equipment.",
        "member": "type  ::string Read"
      },
      "position": {
        "name": "position",
        "type": "EquipmentPosition",
        "mode": "[R]",
        "doc": "Position of this equipment in the equipment grid.",
        "short": "Position of this equipment in the equipment grid.",
        "member": "position  ::EquipmentPosition Read"
      },
      "shape": {
        "name": "shape",
        "mode": "[R]",
        "doc": "Shape of this equipment.",
        "short": "Shape of this equipment.",
        "member": "shape  ::table Read",
        "args": {
          "width": {
            "name": "width",
            "type": "uint",
            "doc": ""
          },
          "height": {
            "name": "height",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "shield": {
        "name": "shield",
        "type": "double",
        "mode": "[RW]",
        "doc": "Current shield value of the equipment.",
        "short": "Current shield value of the equipment.",
        "member": "shield  ::double Read/Write"
      },
      "max_shield": {
        "name": "max_shield",
        "type": "double",
        "mode": "[R]",
        "doc": "Maximum shield value.",
        "short": "Maximum shield value.",
        "member": "max_shield  ::double Read"
      },
      "max_solar_power": {
        "name": "max_solar_power",
        "type": "double",
        "mode": "[R]",
        "doc": "Maximum solar power generated.",
        "short": "Maximum solar power generated.",
        "member": "max_solar_power  ::double Read"
      },
      "movement_bonus": {
        "name": "movement_bonus",
        "type": "double",
        "mode": "[R]",
        "doc": "Movement speed bonus.",
        "short": "Movement speed bonus.",
        "member": "movement_bonus  ::double Read"
      },
      "generator_power": {
        "name": "generator_power",
        "type": "double",
        "mode": "[R]",
        "doc": "Energy generated per tick.",
        "short": "Energy generated per tick.",
        "member": "generator_power  ::double Read"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[RW]",
        "doc": "Current available energy.",
        "short": "Current available energy.",
        "member": "energy  ::double Read/Write"
      },
      "max_energy": {
        "name": "max_energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Maximum amount of energy that can be stored in this equipment.",
        "short": "Maximum amount of energy that can be stored in this equipment.",
        "member": "max_energy  ::double Read"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEquipmentPrototype",
        "mode": "[R]",
        "member": "prototype  ::LuaEquipmentPrototype Read"
      },
      "burner": {
        "name": "burner",
        "type": "LuaBurner",
        "mode": "[R]",
        "doc": "The burner energy source for this equipment, if any.",
        "short": "The burner energy source for this equipment, if any.",
        "member": "burner  ::LuaBurner? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEquipmentCategoryPrototype": {
    "name": "LuaEquipmentCategoryPrototype",
    "type": "LuaEquipmentCategoryPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEquipmentGrid": {
    "name": "LuaEquipmentGrid",
    "type": "LuaEquipmentGrid",
    "inherits": [],
    "properties": {
      "take": {
        "name": "take",
        "type": "SimpleItemStack",
        "doc": "Remove an equipment from the grid. Returns: The removed equipment, or nil if no equipment was removed.",
        "short": "Remove an equipment from the grid.",
        "member": "take{position?=, equipment?=, by_player?=}  SimpleItemStack?",
        "returns": "SimpleItemStack?",
        "args": {
          "position": {
            "name": "position",
            "type": "EquipmentPosition?",
            "doc": "Take the equipment that contains this position in the grid."
          },
          "equipment": {
            "name": "equipment",
            "type": "LuaEquipment?",
            "doc": "Take this exact equipment."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If provided the action is done 'as' this player and on_player_removed_equipment is triggered."
          }
        }
      },
      "take_all": {
        "name": "take_all",
        "type": "function",
        "doc": "Remove all equipment from the grid. Returns: Count of each removed equipment, indexed by their prototype names.",
        "short": "Remove all equipment from the grid.",
        "member": "take_all(by_player?)  dictionary[string uint]",
        "returns": "dictionary[string uint]",
        "args": {
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If provided, the action is done 'as' this player and on_player_removed_equipment is triggered."
          }
        }
      },
      "clear": {
        "name": "clear",
        "doc": "Clear all equipment from the grid, removing it without actually returning it.",
        "short": "Clear all equipment from the grid, removing it without actually returning it.",
        "member": "clear(by_player?)",
        "type": "function",
        "args": {
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If provided, the action is done 'as' this player and on_player_removed_equipment is triggered."
          }
        }
      },
      "put": {
        "name": "put",
        "type": "LuaEquipment",
        "doc": "Insert an equipment into the grid. Returns: The newly-added equipment, or nil if the equipment could not be added.",
        "short": "Insert an equipment into the grid.",
        "member": "put{name=, position?=, by_player?=}  LuaEquipment?",
        "returns": "LuaEquipment?",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Equipment prototype name"
          },
          "position": {
            "name": "position",
            "type": "EquipmentPosition?",
            "doc": "Grid position to put the equipment in."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If provided the action is done 'as' this player and on_player_placed_equipment is triggered."
          }
        }
      },
      "can_move": {
        "name": "can_move",
        "type": "boolean",
        "doc": "Check whether moving an equipment would succeed.",
        "short": "Check whether moving an equipment would succeed.",
        "member": "can_move{equipment=, position=}  boolean",
        "args": {
          "equipment": {
            "name": "equipment",
            "type": "LuaEquipment",
            "doc": "The equipment to move"
          },
          "position": {
            "name": "position",
            "type": "EquipmentPosition",
            "doc": "Where to put it"
          }
        }
      },
      "move": {
        "name": "move",
        "type": "boolean",
        "doc": "Move an equipment within this grid. Returns: true if the equipment was successfully moved.",
        "short": "Move an equipment within this grid.",
        "member": "move{equipment=, position=}  boolean",
        "returns": "boolean",
        "args": {
          "equipment": {
            "name": "equipment",
            "type": "LuaEquipment",
            "doc": "The equipment to move"
          },
          "position": {
            "name": "position",
            "type": "EquipmentPosition",
            "doc": "Where to put it"
          }
        }
      },
      "get": {
        "name": "get",
        "type": "function",
        "doc": "Find equipment in the Equipment Grid based off a position. Returns: The found equipment, or nil if equipment could not be found at the given position.",
        "short": "Find equipment in the Equipment Grid based off a position.",
        "member": "get(position)  LuaEquipment?",
        "returns": "LuaEquipment?",
        "args": {
          "position": {
            "name": "position",
            "type": "EquipmentPosition",
            "doc": "The position"
          }
        }
      },
      "get_contents": {
        "name": "get_contents",
        "type": "function",
        "doc": "Get counts of all equipment in this grid. Returns: The counts, indexed by equipment names.",
        "short": "Get counts of all equipment in this grid.",
        "member": "get_contents()  dictionary[string uint]",
        "returns": "dictionary[string uint]"
      },
      "find": {
        "name": "find",
        "type": "function",
        "doc": "Find equipment by name. Returns: The first found equipment, or nil if equipment could not be found.",
        "short": "Find equipment by name.",
        "member": "find(equipment)  LuaEquipment?",
        "returns": "LuaEquipment?",
        "args": {
          "equipment": {
            "name": "equipment",
            "type": "string",
            "doc": "Prototype name of the equipment to find."
          }
        }
      },
      "count": {
        "name": "count",
        "type": "function",
        "doc": "Get the number of all or some equipment in this grid.",
        "short": "Get the number of all or some equipment in this grid.",
        "member": "count(equipment?)  uint",
        "args": {
          "equipment": {
            "name": "equipment",
            "type": "string?",
            "doc": "Prototype name of the equipment to count. If not specified, count all equipment."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[R]",
        "member": "prototype  ::LuaEquipmentGridPrototype Read"
      },
      "width": {
        "name": "width",
        "type": "uint",
        "mode": "[R]",
        "doc": "Width of the equipment grid.",
        "short": "Width of the equipment grid.",
        "member": "width  ::uint Read"
      },
      "height": {
        "name": "height",
        "type": "uint",
        "mode": "[R]",
        "doc": "Height of the equipment grid.",
        "short": "Height of the equipment grid.",
        "member": "height  ::uint Read"
      },
      "equipment": {
        "name": "equipment",
        "type": "LuaEquipment",
        "mode": "[R]",
        "doc": "All the equipment in this grid.",
        "short": "All the equipment in this grid.",
        "member": "equipment  ::array[LuaEquipment] Read"
      },
      "generator_energy": {
        "name": "generator_energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Total energy per tick generated by the equipment inside this grid.",
        "short": "Total energy per tick generated by the equipment inside this grid.",
        "member": "generator_energy  ::double Read"
      },
      "max_solar_energy": {
        "name": "max_solar_energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Maximum energy per tick that can be created by any solar panels in the equipment grid. Actual generated energy varies depending on the daylight levels.",
        "short": "Maximum energy per tick that can be created by any solar panels in the equipment grid. [...]",
        "member": "max_solar_energy  ::double Read"
      },
      "available_in_batteries": {
        "name": "available_in_batteries",
        "type": "double",
        "mode": "[R]",
        "doc": "The total energy stored in all batteries in the equipment grid.",
        "short": "The total energy stored in all batteries in the equipment grid.",
        "member": "available_in_batteries  ::double Read"
      },
      "battery_capacity": {
        "name": "battery_capacity",
        "type": "double",
        "mode": "[R]",
        "doc": "Total energy storage capacity of all batteries in the equipment grid.",
        "short": "Total energy storage capacity of all batteries in the equipment grid.",
        "member": "battery_capacity  ::double Read"
      },
      "shield": {
        "name": "shield",
        "type": "float",
        "mode": "[R]",
        "doc": "The amount of shields this equipment grid has.",
        "short": "The amount of shields this equipment grid has.",
        "member": "shield  ::float Read"
      },
      "max_shield": {
        "name": "max_shield",
        "type": "float",
        "mode": "[R]",
        "doc": "The maximum amount of shields this equipment grid has.",
        "short": "The maximum amount of shields this equipment grid has.",
        "member": "max_shield  ::float Read"
      },
      "inhibit_movement_bonus": {
        "name": "inhibit_movement_bonus",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this grid's equipment movement bonus is active.",
        "short": "Whether this grid's equipment movement bonus is active.",
        "member": "inhibit_movement_bonus  ::boolean Read/Write"
      },
      "unique_id": {
        "name": "unique_id",
        "type": "uint",
        "mode": "[R]",
        "doc": "Unique identifier of this equipment grid.",
        "short": "Unique identifier of this equipment grid.",
        "member": "unique_id  ::uint Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEquipmentGridPrototype": {
    "name": "LuaEquipmentGridPrototype",
    "type": "LuaEquipmentGridPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "equipment_categories": {
        "name": "equipment_categories",
        "type": "string",
        "mode": "[R]",
        "doc": "Equipment category names for the categories that may be inserted into this equipment grid. The grid will accept any equipment that has at least one category in this list.",
        "short": "Equipment category names for the categories that may be inserted into this equipment grid. [...]",
        "member": "equipment_categories  ::array[string] Read"
      },
      "width": {
        "name": "width",
        "type": "uint",
        "mode": "[R]",
        "member": "width  ::uint Read"
      },
      "height": {
        "name": "height",
        "type": "uint",
        "mode": "[R]",
        "member": "height  ::uint Read"
      },
      "locked": {
        "name": "locked",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the player can move equipment into or out of this grid.",
        "short": "If the player can move equipment into or out of this grid.",
        "member": "locked  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaEquipmentPrototype": {
    "name": "LuaEquipmentPrototype",
    "type": "LuaEquipmentPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "Type of this equipment prototype.",
        "short": "Type of this equipment prototype.",
        "member": "type  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "shape": {
        "name": "shape",
        "mode": "[R]",
        "doc": "Shape of this equipment prototype.",
        "short": "Shape of this equipment prototype.",
        "member": "shape  ::table Read",
        "args": {
          "width": {
            "name": "width",
            "type": "uint",
            "doc": ""
          },
          "height": {
            "name": "height",
            "type": "uint",
            "doc": ""
          },
          "points": {
            "name": "points",
            "type": "array[EquipmentPoint]?",
            "doc": "Only set when the shape is \"manual\""
          }
        }
      },
      "take_result": {
        "name": "take_result",
        "type": "LuaItemPrototype",
        "mode": "[R]",
        "doc": "The result item when taking this equipment out of an equipment grid, if any.",
        "short": "The result item when taking this equipment out of an equipment grid, if any.",
        "member": "take_result  ::LuaItemPrototype? Read"
      },
      "energy_production": {
        "name": "energy_production",
        "type": "double",
        "mode": "[R]",
        "doc": "The max power generated by this equipment.",
        "short": "The max power generated by this equipment.",
        "member": "energy_production  ::double Read"
      },
      "shield": {
        "name": "shield",
        "type": "float",
        "mode": "[R]",
        "doc": "The shield value of this equipment. 0 for non-shield equipment.",
        "short": "The shield value of this equipment. [...]",
        "member": "shield  ::float Read"
      },
      "energy_per_shield": {
        "name": "energy_per_shield",
        "type": "double",
        "mode": "[R]",
        "doc": "The energy per shield point restored. 0 for non-shield equipment.",
        "short": "The energy per shield point restored. [...]",
        "member": "energy_per_shield  ::double Read"
      },
      "logistic_parameters": {
        "name": "logistic_parameters",
        "mode": "[R]",
        "doc": "The logistic parameters for this roboport equipment.",
        "short": "The logistic parameters for this roboport equipment.",
        "member": "logistic_parameters  ::table? Read",
        "args": {
          "spawn_and_station_height": {
            "name": "spawn_and_station_height",
            "type": "float",
            "doc": ""
          },
          "spawn_and_station_shadow_height_offset": {
            "name": "spawn_and_station_shadow_height_offset",
            "type": "float",
            "doc": ""
          },
          "charge_approach_distance": {
            "name": "charge_approach_distance",
            "type": "float",
            "doc": ""
          },
          "logistic_radius": {
            "name": "logistic_radius",
            "type": "float",
            "doc": ""
          },
          "construction_radius": {
            "name": "construction_radius",
            "type": "float",
            "doc": ""
          },
          "charging_station_count": {
            "name": "charging_station_count",
            "type": "uint",
            "doc": ""
          },
          "charging_distance": {
            "name": "charging_distance",
            "type": "float",
            "doc": ""
          },
          "charging_station_shift": {
            "name": "charging_station_shift",
            "type": "Vector",
            "doc": ""
          },
          "charging_energy": {
            "name": "charging_energy",
            "type": "double",
            "doc": ""
          },
          "charging_threshold_distance": {
            "name": "charging_threshold_distance",
            "type": "float",
            "doc": ""
          },
          "robot_vertical_acceleration": {
            "name": "robot_vertical_acceleration",
            "type": "float",
            "doc": ""
          },
          "stationing_offset": {
            "name": "stationing_offset",
            "type": "Vector",
            "doc": ""
          },
          "robot_limit": {
            "name": "robot_limit",
            "type": "uint",
            "doc": ""
          },
          "logistics_connection_distance": {
            "name": "logistics_connection_distance",
            "type": "float",
            "doc": ""
          },
          "robots_shrink_when_entering_and_exiting": {
            "name": "robots_shrink_when_entering_and_exiting",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "energy_consumption": {
        "name": "energy_consumption",
        "type": "double",
        "mode": "[R]",
        "member": "energy_consumption  ::double Read"
      },
      "movement_bonus": {
        "name": "movement_bonus",
        "type": "float",
        "mode": "[R]",
        "member": "movement_bonus  ::float? Read"
      },
      "energy_source": {
        "name": "energy_source",
        "type": "LuaElectricEnergySourcePrototype",
        "mode": "[R]",
        "doc": "The energy source prototype for the equipment.",
        "short": "The energy source prototype for the equipment.",
        "member": "energy_source  ::LuaElectricEnergySourcePrototype Read"
      },
      "equipment_categories": {
        "name": "equipment_categories",
        "type": "string",
        "mode": "[R]",
        "doc": "Category names for this equipment. These categories will be used to determine whether this equipment is allowed in a particular equipment grid.",
        "short": "Category names for this equipment. [...]",
        "member": "equipment_categories  ::array[string] Read"
      },
      "burner_prototype": {
        "name": "burner_prototype",
        "type": "LuaBurnerPrototype",
        "mode": "[R]",
        "doc": "The burner energy source prototype this equipment uses, if any.",
        "short": "The burner energy source prototype this equipment uses, if any.",
        "member": "burner_prototype  ::LuaBurnerPrototype? Read"
      },
      "electric_energy_source_prototype": {
        "name": "electric_energy_source_prototype",
        "type": "LuaElectricEnergySourcePrototype",
        "mode": "[R]",
        "doc": "The electric energy source prototype this equipment uses, if any.",
        "short": "The electric energy source prototype this equipment uses, if any.",
        "member": "electric_energy_source_prototype  ::LuaElectricEnergySourcePrototype? Read"
      },
      "background_color": {
        "name": "background_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The background color of this equipment prototype.",
        "short": "The background color of this equipment prototype.",
        "member": "background_color  ::Color Read"
      },
      "attack_parameters": {
        "name": "attack_parameters",
        "type": "AttackParameters",
        "mode": "[R]",
        "doc": "The equipment attack parameters.",
        "short": "The equipment attack parameters.",
        "member": "attack_parameters  ::AttackParameters? Read"
      },
      "automatic": {
        "name": "automatic",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this active defense equipment is automatic. Returns false if not active defense equipment.",
        "short": "Whether this active defense equipment is automatic. [...]",
        "member": "automatic  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaFlowStatistics": {
    "name": "LuaFlowStatistics",
    "type": "LuaFlowStatistics",
    "inherits": [],
    "properties": {
      "get_input_count": {
        "name": "get_input_count",
        "type": "function",
        "doc": "Gets the total input count for a given prototype.",
        "short": "Gets the total input count for a given prototype.",
        "member": "get_input_count(name)  uint64 or double",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The prototype name."
          }
        }
      },
      "set_input_count": {
        "name": "set_input_count",
        "doc": "Sets the total input count for a given prototype.",
        "short": "Sets the total input count for a given prototype.",
        "member": "set_input_count(name, count)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The prototype name."
          },
          "count": {
            "name": "count",
            "type": "uint64 or double",
            "doc": "The new count. The type depends on the instance of the statistics."
          }
        }
      },
      "get_output_count": {
        "name": "get_output_count",
        "type": "function",
        "doc": "Gets the total output count for a given prototype.",
        "short": "Gets the total output count for a given prototype.",
        "member": "get_output_count(name)  uint64 or double",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The prototype name."
          }
        }
      },
      "set_output_count": {
        "name": "set_output_count",
        "doc": "Sets the total output count for a given prototype.",
        "short": "Sets the total output count for a given prototype.",
        "member": "set_output_count(name, count)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The prototype name."
          },
          "count": {
            "name": "count",
            "type": "uint64 or double",
            "doc": "The new count. The type depends on the instance of the statistics."
          }
        }
      },
      "get_flow_count": {
        "name": "get_flow_count",
        "type": "double",
        "doc": "Gets the flow count value for the given time frame. If sample_index is not provided, then the value returned is the average across the provided precision time period. These are the values shown in the bottom section of the statistics GUIs.",
        "short": "Gets the flow count value for the given time frame. [...]",
        "member": "get_flow_count{name=, input=, precision_index=, sample_index?=, count?=}  double",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The prototype name."
          },
          "input": {
            "name": "input",
            "type": "boolean",
            "doc": "Read the input values or the output values"
          },
          "precision_index": {
            "name": "precision_index",
            "type": "defines.flow_precision_index",
            "doc": "The precision range to read."
          },
          "sample_index": {
            "name": "sample_index",
            "type": "uint16?",
            "doc": "The sample index to read from within the precision range. If not provided, the entire precision range is read. Must be between 1 and 300 where 1 is the most recent sample and 300 is the oldest."
          },
          "count": {
            "name": "count",
            "type": "boolean?",
            "doc": "If true, the count of items/fluids/entities is returned instead of the per-time-frame value."
          }
        }
      },
      "on_flow": {
        "name": "on_flow",
        "doc": "Adds a value to this flow statistics.",
        "short": "Adds a value to this flow statistics.",
        "member": "on_flow(name, count)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The prototype name."
          },
          "count": {
            "name": "count",
            "type": "float",
            "doc": "The count: positive or negative determines if the value goes in the input or output statistics."
          }
        }
      },
      "clear": {
        "name": "clear",
        "doc": "Reset all the statistics data to 0.",
        "short": "Reset all the statistics data to 0.",
        "member": "clear()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "input_counts": {
        "name": "input_counts",
        "type": "string",
        "mode": "[R]",
        "doc": "List of input counts indexed by prototype name. Represents the data that is shown on the left side of the GUI for the given statistics.",
        "short": "List of input counts indexed by prototype name. [...]",
        "member": "input_counts  ::dictionary[string uint64 or double] Read"
      },
      "output_counts": {
        "name": "output_counts",
        "type": "string",
        "mode": "[R]",
        "doc": "List of output counts indexed by prototype name. Represents the data that is shown on the right side of the GUI for the given statistics.",
        "short": "List of output counts indexed by prototype name. [...]",
        "member": "output_counts  ::dictionary[string uint64 or double] Read"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force these statistics belong to. nil for pollution statistics.",
        "short": "The force these statistics belong to. [...]",
        "member": "force  ::LuaForce? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaFluidBox": {
    "name": "LuaFluidBox",
    "type": "LuaFluidBox",
    "inherits": [],
    "properties": {
      "get_prototype": {
        "name": "get_prototype",
        "type": "function",
        "doc": "The prototype of this fluidbox index. If this is used on a fluidbox of a crafting machine which due to recipe was created by merging multiple prototypes, a table of prototypes that were merged will be returned instead",
        "short": "The prototype of this fluidbox index. [...]",
        "member": "get_prototype(index)  LuaFluidBoxPrototype or array[LuaFluidBoxPrototype]",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_capacity": {
        "name": "get_capacity",
        "type": "function",
        "doc": "The capacity of the given fluidbox index.",
        "short": "The capacity of the given fluidbox index.",
        "member": "get_capacity(index)  double",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_connections": {
        "name": "get_connections",
        "type": "function",
        "doc": "The fluidboxes to which the fluidbox at the given index is connected.",
        "short": "The fluidboxes to which the fluidbox at the given index is connected.",
        "member": "get_connections(index)  array[LuaFluidBox]",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_pipe_connections": {
        "name": "get_pipe_connections",
        "type": "function",
        "doc": "Get the fluid box's connections and associated data.",
        "short": "Get the fluid box's connections and associated data.",
        "member": "get_pipe_connections(index)  array[PipeConnection]",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_filter": {
        "name": "get_filter",
        "type": "function",
        "doc": "Get a fluid box filter Returns: The filter at the requested index, or nil if there isn't one.",
        "short": "Get a fluid box filter",
        "member": "get_filter(index)  FluidBoxFilter?",
        "returns": "FluidBoxFilter?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index of the filter to get."
          }
        }
      },
      "set_filter": {
        "name": "set_filter",
        "type": "function",
        "doc": "Set a fluid box filter. Returns: Whether the filter was set successfully.",
        "short": "Set a fluid box filter.",
        "member": "set_filter(index, filter)  boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index of the filter to set."
          },
          "filter": {
            "name": "filter",
            "type": "FluidBoxFilterSpec or nil",
            "doc": "The filter to set. Setting nil clears the filter."
          }
        }
      },
      "get_flow": {
        "name": "get_flow",
        "type": "function",
        "doc": "Flow through the fluidbox in the last tick. It is the larger of in-flow and out-flow.",
        "short": "Flow through the fluidbox in the last tick. [...]",
        "member": "get_flow(index)  double",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_locked_fluid": {
        "name": "get_locked_fluid",
        "type": "function",
        "doc": "Returns the fluid the fluidbox is locked onto Returns: nil if the fluidbox is not locked to any fluid.",
        "short": "Returns the fluid the fluidbox is locked onto",
        "member": "get_locked_fluid(index)  string?",
        "returns": "string?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_fluid_system_id": {
        "name": "get_fluid_system_id",
        "type": "function",
        "doc": "Gets unique fluid system identifier of selected fluid box. May return nil for fluid wagon, fluid turret's internal buffer or a fluidbox which does not belong to a fluid system",
        "short": "Gets unique fluid system identifier of selected fluid box. [...]",
        "member": "get_fluid_system_id(index)  uint?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_fluid_system_contents": {
        "name": "get_fluid_system_contents",
        "type": "function",
        "doc": "Gets counts of all fluids in the fluid system. May return nil for fluid wagon, fluid turret's internal buffer, or a fluidbox which does not belong to a fluid system. Returns: The counts, indexed by fluid name.",
        "short": "Gets counts of all fluids in the fluid system. [...]",
        "member": "get_fluid_system_contents(index)  dictionary[string uint]?",
        "returns": "dictionary[string uint]?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "flush": {
        "name": "flush",
        "type": "function",
        "doc": "Flushes all fluid from this fluidbox and its fluid system. Returns: The removed fluid.",
        "short": "Flushes all fluid from this fluidbox and its fluid system.",
        "member": "flush(index, fluid?)  dictionary[string float]",
        "returns": "dictionary[string float]",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          },
          "fluid": {
            "name": "fluid",
            "type": "FluidIdentification?",
            "doc": "If provided, only this fluid is flushed."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The entity that owns this fluidbox.",
        "short": "The entity that owns this fluidbox.",
        "member": "owner  ::LuaEntity Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "# (length)": {
        "name": "# (length)",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of fluid boxes."
      },
      "[] (index)": {
        "name": "[] (index)",
        "type": "Fluid",
        "mode": "[R]",
        "doc": "Access, set or clear a fluid box. [...]"
      }
    }
  },
  "LuaFluidBoxPrototype": {
    "name": "LuaFluidBoxPrototype",
    "type": "LuaFluidBoxPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "entity": {
        "name": "entity",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The entity that this belongs to.",
        "short": "The entity that this belongs to.",
        "member": "entity  ::LuaEntityPrototype Read"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[R]",
        "doc": "The index of this fluidbox prototype in the owning entity.",
        "short": "The index of this fluidbox prototype in the owning entity.",
        "member": "index  ::uint Read"
      },
      "pipe_connections": {
        "name": "pipe_connections",
        "type": "FluidBoxConnection",
        "mode": "[R]",
        "doc": "The pipe connection points.",
        "short": "The pipe connection points.",
        "member": "pipe_connections  ::array[FluidBoxConnection] Read"
      },
      "production_type": {
        "name": "production_type",
        "mode": "[R]",
        "doc": "The production type.",
        "short": "The production type.",
        "member": "production_type  ::\"input\" or \"input-output\" or \"output\" or \"none\" Read"
      },
      "base_area": {
        "name": "base_area",
        "type": "double",
        "mode": "[R]",
        "member": "base_area  ::double Read"
      },
      "base_level": {
        "name": "base_level",
        "type": "float",
        "mode": "[R]",
        "member": "base_level  ::float Read"
      },
      "height": {
        "name": "height",
        "type": "double",
        "mode": "[R]",
        "member": "height  ::double Read"
      },
      "volume": {
        "name": "volume",
        "type": "double",
        "mode": "[R]",
        "member": "volume  ::double Read"
      },
      "filter": {
        "name": "filter",
        "type": "LuaFluidPrototype",
        "mode": "[R]",
        "doc": "The filter, if any is set.",
        "short": "The filter, if any is set.",
        "member": "filter  ::LuaFluidPrototype? Read"
      },
      "minimum_temperature": {
        "name": "minimum_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "The minimum temperature, if any is set.",
        "short": "The minimum temperature, if any is set.",
        "member": "minimum_temperature  ::double? Read"
      },
      "maximum_temperature": {
        "name": "maximum_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum temperature, if any is set.",
        "short": "The maximum temperature, if any is set.",
        "member": "maximum_temperature  ::double? Read"
      },
      "secondary_draw_orders": {
        "name": "secondary_draw_orders",
        "type": "int",
        "mode": "[R]",
        "doc": "The secondary draw orders for the 4 possible connection directions.",
        "short": "The secondary draw orders for the 4 possible connection directions.",
        "member": "secondary_draw_orders  ::array[int] Read"
      },
      "render_layer": {
        "name": "render_layer",
        "type": "string",
        "mode": "[R]",
        "doc": "The render layer.",
        "short": "The render layer.",
        "member": "render_layer  ::string Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaFluidEnergySourcePrototype": {
    "name": "LuaFluidEnergySourcePrototype",
    "type": "LuaFluidEnergySourcePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions of this energy source in pollution/Joule. Multiplying it by energy consumption in Watt gives pollution/second.",
        "short": "The emissions of this energy source in pollution/Joule. [...]",
        "member": "emissions  ::double Read"
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_network_icon  ::boolean Read"
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_power_icon  ::boolean Read"
      },
      "effectivity": {
        "name": "effectivity",
        "type": "double",
        "mode": "[R]",
        "member": "effectivity  ::double Read"
      },
      "burns_fluid": {
        "name": "burns_fluid",
        "type": "boolean",
        "mode": "[R]",
        "member": "burns_fluid  ::boolean Read"
      },
      "scale_fluid_usage": {
        "name": "scale_fluid_usage",
        "type": "boolean",
        "mode": "[R]",
        "member": "scale_fluid_usage  ::boolean Read"
      },
      "destroy_non_fuel_fluid": {
        "name": "destroy_non_fuel_fluid",
        "type": "boolean",
        "mode": "[R]",
        "member": "destroy_non_fuel_fluid  ::boolean Read"
      },
      "fluid_usage_per_tick": {
        "name": "fluid_usage_per_tick",
        "type": "double",
        "mode": "[R]",
        "member": "fluid_usage_per_tick  ::double Read"
      },
      "smoke": {
        "name": "smoke",
        "type": "SmokeSource",
        "mode": "[R]",
        "doc": "The smoke sources for this prototype, if any.",
        "short": "The smoke sources for this prototype, if any.",
        "member": "smoke  ::array[SmokeSource] Read"
      },
      "maximum_temperature": {
        "name": "maximum_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "maximum_temperature  ::double Read"
      },
      "fluid_box": {
        "name": "fluid_box",
        "type": "LuaFluidBoxPrototype",
        "mode": "[R]",
        "doc": "The fluid box for this energy source.",
        "short": "The fluid box for this energy source.",
        "member": "fluid_box  ::LuaFluidBoxPrototype Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaFluidPrototype": {
    "name": "LuaFluidPrototype",
    "type": "LuaFluidPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "default_temperature": {
        "name": "default_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "Default temperature of this fluid.",
        "short": "Default temperature of this fluid.",
        "member": "default_temperature  ::double Read"
      },
      "max_temperature": {
        "name": "max_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "Maximum temperature this fluid can reach.",
        "short": "Maximum temperature this fluid can reach.",
        "member": "max_temperature  ::double Read"
      },
      "heat_capacity": {
        "name": "heat_capacity",
        "type": "double",
        "mode": "[R]",
        "doc": "The amount of energy in Joules required to heat one unit of this fluid by 1C.",
        "short": "The amount of energy in Joules required to heat one unit of this fluid by 1C.",
        "member": "heat_capacity  ::double Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Group of this prototype.",
        "short": "Group of this prototype.",
        "member": "group  ::LuaGroup Read"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Subgroup of this prototype.",
        "short": "Subgroup of this prototype.",
        "member": "subgroup  ::LuaGroup Read"
      },
      "base_color": {
        "name": "base_color",
        "type": "Color",
        "mode": "[R]",
        "member": "base_color  ::Color Read"
      },
      "flow_color": {
        "name": "flow_color",
        "type": "Color",
        "mode": "[R]",
        "member": "flow_color  ::Color Read"
      },
      "gas_temperature": {
        "name": "gas_temperature",
        "type": "double",
        "mode": "[R]",
        "doc": "The temperature above which this fluid will be shown as gaseous inside tanks and pipes.",
        "short": "The temperature above which this fluid will be shown as gaseous inside tanks and pipes.",
        "member": "gas_temperature  ::double Read"
      },
      "emissions_multiplier": {
        "name": "emissions_multiplier",
        "type": "double",
        "mode": "[R]",
        "doc": "A multiplier on the amount of emissions produced when this fluid is burnt in a generator. A value above 1.0 increases emissions and vice versa. The multiplier can't be negative.",
        "short": "A multiplier on the amount of emissions produced when this fluid is burnt in a generator. [...]",
        "member": "emissions_multiplier  ::double Read"
      },
      "fuel_value": {
        "name": "fuel_value",
        "type": "double",
        "mode": "[R]",
        "doc": "The amount of energy in Joules one unit of this fluid will produce when burnt in a generator. A value of 0 means this fluid can't be used for energy generation. The value can't be negative.",
        "short": "The amount of energy in Joules one unit of this fluid will produce when burnt in a generator. [...]",
        "member": "fuel_value  ::double Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this fluid is hidden from the fluid and signal selectors.",
        "short": "Whether this fluid is hidden from the fluid and signal selectors.",
        "member": "hidden  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaFontPrototype": {
    "name": "LuaFontPrototype",
    "type": "LuaFontPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "from": {
        "name": "from",
        "type": "string",
        "mode": "[R]",
        "member": "from  ::string Read"
      },
      "size": {
        "name": "size",
        "type": "int",
        "mode": "[R]",
        "member": "size  ::int Read"
      },
      "spacing": {
        "name": "spacing",
        "type": "float",
        "mode": "[R]",
        "member": "spacing  ::float Read"
      },
      "border": {
        "name": "border",
        "type": "boolean",
        "mode": "[R]",
        "member": "border  ::boolean Read"
      },
      "filtered": {
        "name": "filtered",
        "type": "boolean",
        "mode": "[R]",
        "member": "filtered  ::boolean Read"
      },
      "border_color": {
        "name": "border_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The border color, if any.",
        "short": "The border color, if any.",
        "member": "border_color  ::Color? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaForce": {
    "name": "LuaForce",
    "type": "LuaForce",
    "inherits": [],
    "properties": {
      "get_entity_count": {
        "name": "get_entity_count",
        "type": "function",
        "doc": "Count entities of given type. Returns: Number of entities of given prototype belonging to this force.",
        "short": "Count entities of given type.",
        "member": "get_entity_count(name)  uint",
        "returns": "uint",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Prototype name of the entity."
          }
        }
      },
      "disable_research": {
        "name": "disable_research",
        "doc": "Disable research for this force.",
        "short": "Disable research for this force.",
        "member": "disable_research()",
        "type": "function"
      },
      "enable_research": {
        "name": "enable_research",
        "doc": "Enable research for this force.",
        "short": "Enable research for this force.",
        "member": "enable_research()",
        "type": "function"
      },
      "disable_all_prototypes": {
        "name": "disable_all_prototypes",
        "doc": "Disable all recipes and technologies. Only recipes and technologies enabled explicitly will be useable from this point.",
        "short": "Disable all recipes and technologies. [...]",
        "member": "disable_all_prototypes()",
        "type": "function"
      },
      "enable_all_prototypes": {
        "name": "enable_all_prototypes",
        "doc": "Enables all recipes and technologies. The opposite of LuaForce::disable_all_prototypes",
        "short": "Enables all recipes and technologies. [...]",
        "member": "enable_all_prototypes()",
        "type": "function"
      },
      "reset_recipes": {
        "name": "reset_recipes",
        "doc": "Load the original version of all recipes from the prototypes.",
        "short": "Load the original version of all recipes from the prototypes.",
        "member": "reset_recipes()",
        "type": "function"
      },
      "enable_all_recipes": {
        "name": "enable_all_recipes",
        "doc": "Unlock all recipes.",
        "short": "Unlock all recipes.",
        "member": "enable_all_recipes()",
        "type": "function"
      },
      "enable_all_technologies": {
        "name": "enable_all_technologies",
        "doc": "Unlock all technologies.",
        "short": "Unlock all technologies.",
        "member": "enable_all_technologies()",
        "type": "function"
      },
      "research_all_technologies": {
        "name": "research_all_technologies",
        "doc": "Research all technologies.",
        "short": "Research all technologies.",
        "member": "research_all_technologies(include_disabled_prototypes?)",
        "type": "function",
        "args": {
          "include_disabled_prototypes": {
            "name": "include_disabled_prototypes",
            "type": "boolean?",
            "doc": "Whether technologies that are explicitly disabled in the prototype should also be researched. Defaults to false."
          },
          "on_research_finished": {
            "name": "on_research_finished",
            "doc": ""
          }
        }
      },
      "reset_technologies": {
        "name": "reset_technologies",
        "doc": "Load the original versions of technologies from prototypes. Preserves research state of technologies.",
        "short": "Load the original versions of technologies from prototypes. [...]",
        "member": "reset_technologies()",
        "type": "function"
      },
      "reset": {
        "name": "reset",
        "doc": "Reset everything. All technologies are set to not researched, all modifiers are set to default values.",
        "short": "Reset everything. [...]",
        "member": "reset()",
        "type": "function",
        "args": {
          "on_force_reset": {
            "name": "on_force_reset",
            "doc": ""
          }
        }
      },
      "reset_technology_effects": {
        "name": "reset_technology_effects",
        "doc": "Reapplies all possible research effects, including unlocked recipes. Any custom changes are lost. Preserves research state of technologies.",
        "short": "Reapplies all possible research effects, including unlocked recipes. [...]",
        "member": "reset_technology_effects()",
        "type": "function",
        "args": {
          "on_technology_effects_reset": {
            "name": "on_technology_effects_reset",
            "doc": ""
          }
        }
      },
      "chart": {
        "name": "chart",
        "doc": "Chart a portion of the map. The chart for the given area is refreshed; it creates chart for any parts of the given area that haven't been charted yet.",
        "short": "Chart a portion of the map. [...]",
        "member": "chart(surface, area)",
        "type": "function",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area on the given surface to chart."
          }
        }
      },
      "clear_chart": {
        "name": "clear_chart",
        "doc": "Erases chart data for this force.",
        "short": "Erases chart data for this force.",
        "member": "clear_chart(surface?)",
        "type": "function",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "Which surface to erase chart data for or if not provided all surfaces charts are erased."
          }
        }
      },
      "rechart": {
        "name": "rechart",
        "doc": "Force a rechart of the whole chart.",
        "short": "Force a rechart of the whole chart.",
        "member": "rechart(surface?)",
        "type": "function",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "Which surface to rechart or all if not given."
          }
        }
      },
      "chart_all": {
        "name": "chart_all",
        "doc": "Chart all generated chunks.",
        "short": "Chart all generated chunks.",
        "member": "chart_all(surface?)",
        "type": "function",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "Which surface to chart or all if not given."
          }
        }
      },
      "is_chunk_charted": {
        "name": "is_chunk_charted",
        "type": "function",
        "doc": "Has a chunk been charted?",
        "short": "Has a chunk been charted?",
        "member": "is_chunk_charted(surface, position)  boolean",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "Position of the chunk."
          }
        }
      },
      "is_chunk_visible": {
        "name": "is_chunk_visible",
        "type": "function",
        "doc": "Is the given chunk currently charted and visible (not covered by fog of war) on the map.",
        "short": "Is the given chunk currently charted and visible (not covered by fog of war) on the map.",
        "member": "is_chunk_visible(surface, position)  boolean",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": ""
          }
        }
      },
      "is_chunk_requested_for_charting": {
        "name": "is_chunk_requested_for_charting",
        "type": "function",
        "doc": "Has a chunk been requested for charting?",
        "short": "Has a chunk been requested for charting?",
        "member": "is_chunk_requested_for_charting(surface, position)  boolean",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "Position of the chunk."
          }
        }
      },
      "cancel_charting": {
        "name": "cancel_charting",
        "doc": "Cancels pending chart requests for the given surface or all surfaces.",
        "short": "Cancels pending chart requests for the given surface or all surfaces.",
        "member": "cancel_charting(surface?)",
        "type": "function",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": ""
          }
        }
      },
      "get_ammo_damage_modifier": {
        "name": "get_ammo_damage_modifier",
        "type": "function",
        "doc": "Ammo category",
        "member": "get_ammo_damage_modifier(ammo)  double",
        "args": {
          "ammo": {
            "name": "ammo",
            "type": "string",
            "doc": "Ammo category"
          }
        }
      },
      "set_ammo_damage_modifier": {
        "name": "set_ammo_damage_modifier",
        "doc": "Ammo category",
        "member": "set_ammo_damage_modifier(ammo, modifier)",
        "type": "function",
        "args": {
          "ammo": {
            "name": "ammo",
            "type": "string",
            "doc": "Ammo category"
          },
          "modifier": {
            "name": "modifier",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_gun_speed_modifier": {
        "name": "get_gun_speed_modifier",
        "type": "function",
        "doc": "Ammo category",
        "member": "get_gun_speed_modifier(ammo)  double",
        "args": {
          "ammo": {
            "name": "ammo",
            "type": "string",
            "doc": "Ammo category"
          }
        }
      },
      "set_gun_speed_modifier": {
        "name": "set_gun_speed_modifier",
        "doc": "Ammo category",
        "member": "set_gun_speed_modifier(ammo, modifier)",
        "type": "function",
        "args": {
          "ammo": {
            "name": "ammo",
            "type": "string",
            "doc": "Ammo category"
          },
          "modifier": {
            "name": "modifier",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_turret_attack_modifier": {
        "name": "get_turret_attack_modifier",
        "type": "function",
        "doc": "Turret prototype name",
        "member": "get_turret_attack_modifier(turret)  double",
        "args": {
          "turret": {
            "name": "turret",
            "type": "string",
            "doc": "Turret prototype name"
          }
        }
      },
      "set_turret_attack_modifier": {
        "name": "set_turret_attack_modifier",
        "doc": "Turret prototype name",
        "member": "set_turret_attack_modifier(turret, modifier)",
        "type": "function",
        "args": {
          "turret": {
            "name": "turret",
            "type": "string",
            "doc": "Turret prototype name"
          },
          "modifier": {
            "name": "modifier",
            "type": "double",
            "doc": ""
          }
        }
      },
      "set_cease_fire": {
        "name": "set_cease_fire",
        "doc": "Add other force to this force's cease fire list. Forces on the cease fire list won't be targeted for attack.",
        "short": "Add other force to this force's cease fire list. [...]",
        "member": "set_cease_fire(other, cease_fire)",
        "type": "function",
        "args": {
          "other": {
            "name": "other",
            "type": "ForceIdentification",
            "doc": ""
          },
          "cease_fire": {
            "name": "cease_fire",
            "type": "boolean",
            "doc": ""
          },
          "on_force_cease_fire_changed": {
            "name": "on_force_cease_fire_changed",
            "doc": ""
          }
        }
      },
      "get_cease_fire": {
        "name": "get_cease_fire",
        "type": "function",
        "doc": "Is other force in this force's cease fire list?",
        "short": "Is other force in this force's cease fire list?",
        "member": "get_cease_fire(other)  boolean",
        "args": {
          "other": {
            "name": "other",
            "type": "ForceIdentification",
            "doc": ""
          }
        }
      },
      "set_friend": {
        "name": "set_friend",
        "doc": "Add other force to this force's friends list. Friends have unrestricted access to buildings and turrets won't fire at them.",
        "short": "Add other force to this force's friends list. [...]",
        "member": "set_friend(other, friend)",
        "type": "function",
        "args": {
          "other": {
            "name": "other",
            "type": "ForceIdentification",
            "doc": ""
          },
          "friend": {
            "name": "friend",
            "type": "boolean",
            "doc": ""
          },
          "on_force_friends_changed": {
            "name": "on_force_friends_changed",
            "doc": ""
          }
        }
      },
      "get_friend": {
        "name": "get_friend",
        "type": "function",
        "doc": "Is other force in this force's friends list.",
        "short": "Is other force in this force's friends list.",
        "member": "get_friend(other)  boolean",
        "args": {
          "other": {
            "name": "other",
            "type": "ForceIdentification",
            "doc": ""
          }
        }
      },
      "is_pathfinder_busy": {
        "name": "is_pathfinder_busy",
        "type": "function",
        "doc": "Is pathfinder busy? When the pathfinder is busy, it won't accept any more pathfinding requests.",
        "short": "Is pathfinder busy? [...]",
        "member": "is_pathfinder_busy()  boolean"
      },
      "kill_all_units": {
        "name": "kill_all_units",
        "doc": "Kill all units and flush the pathfinder.",
        "short": "Kill all units and flush the pathfinder.",
        "member": "kill_all_units()",
        "type": "function"
      },
      "find_logistic_network_by_position": {
        "name": "find_logistic_network_by_position",
        "type": "function",
        "doc": "Position to find a network for Returns: The found network or nil.",
        "member": "find_logistic_network_by_position(position, surface)  LuaLogisticNetwork?",
        "returns": "LuaLogisticNetwork?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Position to find a network for"
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to search on"
          }
        }
      },
      "set_spawn_position": {
        "name": "set_spawn_position",
        "doc": "The new position on the given surface.",
        "member": "set_spawn_position(position, surface)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The new position on the given surface."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to set the spawn position for."
          }
        }
      },
      "get_spawn_position": {
        "name": "get_spawn_position",
        "type": "function",
        "member": "get_spawn_position(surface)  MapPosition",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          }
        }
      },
      "unchart_chunk": {
        "name": "unchart_chunk",
        "doc": "The chunk position to unchart.",
        "member": "unchart_chunk(position, surface)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "The chunk position to unchart."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to unchart on."
          }
        }
      },
      "get_item_launched": {
        "name": "get_item_launched",
        "type": "function",
        "doc": "Gets the count of a given item launched in rockets. Returns: The count of the item that has been launched.",
        "short": "Gets the count of a given item launched in rockets.",
        "member": "get_item_launched(item)  uint",
        "returns": "uint",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "The item to get"
          }
        }
      },
      "set_item_launched": {
        "name": "set_item_launched",
        "doc": "Sets the count of a given item launched in rockets.",
        "short": "Sets the count of a given item launched in rockets.",
        "member": "set_item_launched(item, count)",
        "type": "function",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "The item to set"
          },
          "count": {
            "name": "count",
            "type": "uint",
            "doc": "The count to set"
          }
        }
      },
      "print": {
        "name": "print",
        "doc": "Print text to the chat console of all players on this force.",
        "short": "Print text to the chat console of all players on this force.",
        "member": "print(message, print_settings?)",
        "type": "function",
        "args": {
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": ""
          },
          "print_settings": {
            "name": "print_settings",
            "type": "Color or PrintSettings?",
            "doc": ""
          }
        }
      },
      "get_trains": {
        "name": "get_trains",
        "type": "function",
        "doc": "The surface to search. Not providing a surface will match trains on any surface.",
        "member": "get_trains(surface?)  array[LuaTrain]",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "The surface to search. Not providing a surface will match trains on any surface."
          }
        }
      },
      "add_chart_tag": {
        "name": "add_chart_tag",
        "type": "function",
        "doc": "Adds a custom chart tag to the given surface and returns the new tag or nil if the given position isn't valid for a chart tag.",
        "short": "Adds a custom chart tag to the given surface and returns the new tag or nil if the given position isn't valid for a chart tag.",
        "member": "add_chart_tag(surface, tag)  LuaCustomChartTag?",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Which surface to add the tag to."
          },
          "tag": {
            "name": "tag",
            "type": "ChartTagSpec",
            "doc": "The tag to add."
          },
          "on_chart_tag_added?": {
            "name": "on_chart_tag_added?",
            "doc": "Raised if the chart tag was successfully added."
          }
        }
      },
      "find_chart_tags": {
        "name": "find_chart_tags",
        "type": "function",
        "doc": "Finds all custom chart tags within the given bounding box on the given surface.",
        "short": "Finds all custom chart tags within the given bounding box on the given surface.",
        "member": "find_chart_tags(surface, area?)  array[LuaCustomChartTag]",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          }
        }
      },
      "get_saved_technology_progress": {
        "name": "get_saved_technology_progress",
        "type": "function",
        "doc": "Gets the saved progress for the given technology or nil if there is no saved progress. Returns: The progress as a percent.",
        "short": "Gets the saved progress for the given technology or nil if there is no saved progress.",
        "member": "get_saved_technology_progress(technology)  double?",
        "returns": "double?",
        "args": {
          "technology": {
            "name": "technology",
            "type": "TechnologyIdentification",
            "doc": "The technology"
          }
        }
      },
      "set_saved_technology_progress": {
        "name": "set_saved_technology_progress",
        "doc": "Sets the saved progress for the given technology. The technology must not be in progress, must not be completed, and the new progress must be < 100%.",
        "short": "Sets the saved progress for the given technology. [...]",
        "member": "set_saved_technology_progress(technology, progress)",
        "type": "function",
        "args": {
          "technology": {
            "name": "technology",
            "type": "TechnologyIdentification",
            "doc": "The technology"
          },
          "progress": {
            "name": "progress",
            "type": "double",
            "doc": "Progress as a percent. Set to nil to remove the saved progress."
          }
        }
      },
      "reset_evolution": {
        "name": "reset_evolution",
        "doc": "Resets evolution for this force to zero.",
        "short": "Resets evolution for this force to zero.",
        "member": "reset_evolution()",
        "type": "function"
      },
      "play_sound": {
        "name": "play_sound",
        "doc": "Play a sound for every player in this force.",
        "short": "Play a sound for every player in this force.",
        "member": "play_sound{path=, position?=, volume_modifier?=, override_sound_type?=}",
        "args": {
          "path": {
            "name": "path",
            "type": "SoundPath",
            "doc": "The sound to play."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Where the sound should be played. If not given, it's played at the current position of each player."
          },
          "volume_modifier": {
            "name": "volume_modifier",
            "type": "double?",
            "doc": "The volume of the sound to play. Must be between 0 and 1 inclusive."
          },
          "override_sound_type": {
            "name": "override_sound_type",
            "type": "SoundType?",
            "doc": "The volume mixer to play the sound through. Defaults to the default mixer for the given sound type."
          }
        }
      },
      "get_train_stops": {
        "name": "get_train_stops",
        "type": "LuaEntity",
        "doc": "Gets train stops matching the given filters.",
        "short": "Gets train stops matching the given filters.",
        "member": "get_train_stops{name?=, surface?=}  array[LuaEntity]",
        "args": {
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "The name(s) of the train stops. Not providing names will match any stop."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "The surface to search. Not providing a surface will match stops on any surface."
          }
        }
      },
      "get_hand_crafting_disabled_for_recipe": {
        "name": "get_hand_crafting_disabled_for_recipe",
        "type": "function",
        "doc": "Gets if the given recipe is explicitly disabled from being hand crafted.",
        "short": "Gets if the given recipe is explicitly disabled from being hand crafted.",
        "member": "get_hand_crafting_disabled_for_recipe(recipe)  boolean",
        "args": {
          "recipe": {
            "name": "recipe",
            "type": "string or LuaRecipe",
            "doc": ""
          }
        }
      },
      "set_hand_crafting_disabled_for_recipe": {
        "name": "set_hand_crafting_disabled_for_recipe",
        "doc": "Sets if the given recipe can be hand-crafted. This is used to explicitly disable hand crafting a recipe - it won't allow hand-crafting otherwise not hand-craftable recipes.",
        "short": "Sets if the given recipe can be hand-crafted. [...]",
        "member": "set_hand_crafting_disabled_for_recipe(recipe, hand_crafting_disabled)",
        "type": "function",
        "args": {
          "recipe": {
            "name": "recipe",
            "type": "string or LuaRecipe",
            "doc": ""
          },
          "hand_crafting_disabled": {
            "name": "hand_crafting_disabled",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "add_research": {
        "name": "add_research",
        "type": "function",
        "doc": "Add this technology to the back of the research queue if the queue is enabled. Otherwise, set this technology to be researched now. Returns: Whether the technology was successfully added.",
        "short": "Add this technology to the back of the research queue if the queue is enabled. [...]",
        "member": "add_research(technology)  boolean",
        "returns": "boolean",
        "args": {
          "technology": {
            "name": "technology",
            "type": "TechnologyIdentification",
            "doc": ""
          },
          "on_research_started?": {
            "name": "on_research_started?",
            "doc": "Raised if the technology was successfully added."
          }
        }
      },
      "cancel_current_research": {
        "name": "cancel_current_research",
        "doc": "Stop the research currently in progress. This will remove any dependent technologies from the research queue.",
        "short": "Stop the research currently in progress. [...]",
        "member": "cancel_current_research()",
        "type": "function"
      },
      "get_linked_inventory": {
        "name": "get_linked_inventory",
        "type": "function",
        "doc": "Gets the linked inventory for the given prototype and link ID if it exists or nil.",
        "short": "Gets the linked inventory for the given prototype and link ID if it exists or nil.",
        "member": "get_linked_inventory(prototype, link_id)  LuaInventory?",
        "args": {
          "prototype": {
            "name": "prototype",
            "type": "EntityPrototypeIdentification",
            "doc": ""
          },
          "link_id": {
            "name": "link_id",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "is_friend": {
        "name": "is_friend",
        "type": "function",
        "doc": "Is this force a friend? This differs from get_friend in that it is always true for neutral force. This is equivalent to checking the friend ForceCondition.",
        "short": "Is this force a friend? [...]",
        "member": "is_friend(other)  boolean",
        "args": {
          "other": {
            "name": "other",
            "type": "ForceIdentification",
            "doc": ""
          }
        }
      },
      "is_enemy": {
        "name": "is_enemy",
        "type": "function",
        "doc": "Is this force an enemy? This differs from get_cease_fire in that it is always false for neutral force. This is equivalent to checking the enemy ForceCondition.",
        "short": "Is this force an enemy? [...]",
        "member": "is_enemy(other)  boolean",
        "args": {
          "other": {
            "name": "other",
            "type": "ForceIdentification",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the force.",
        "short": "Name of the force.",
        "member": "name  ::string Read"
      },
      "technologies": {
        "name": "technologies",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Technologies owned by this force, indexed by name.",
        "short": "Technologies owned by this force, indexed by name.",
        "member": "technologies  ::LuaCustomTable[string LuaTechnology] Read"
      },
      "recipes": {
        "name": "recipes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Recipes available to this force, indexed by name.",
        "short": "Recipes available to this force, indexed by name.",
        "member": "recipes  ::LuaCustomTable[string LuaRecipe] Read"
      },
      "manual_mining_speed_modifier": {
        "name": "manual_mining_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "Multiplier of the manual mining speed. Default value is 0. The actual mining speed will be multiplied by 1 + manual_mining_speed_modifier.",
        "short": "Multiplier of the manual mining speed. [...]",
        "member": "manual_mining_speed_modifier  ::double Read/Write"
      },
      "manual_crafting_speed_modifier": {
        "name": "manual_crafting_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "Multiplier of the manual crafting speed. Default value is 0. The actual crafting speed will be multiplied by 1 + manual_crafting_speed_modifier.",
        "short": "Multiplier of the manual crafting speed. [...]",
        "member": "manual_crafting_speed_modifier  ::double Read/Write"
      },
      "laboratory_speed_modifier": {
        "name": "laboratory_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "member": "laboratory_speed_modifier  ::double Read/Write"
      },
      "laboratory_productivity_bonus": {
        "name": "laboratory_productivity_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "laboratory_productivity_bonus  ::double Read/Write"
      },
      "worker_robots_speed_modifier": {
        "name": "worker_robots_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "member": "worker_robots_speed_modifier  ::double Read/Write"
      },
      "worker_robots_battery_modifier": {
        "name": "worker_robots_battery_modifier",
        "type": "double",
        "mode": "[RW]",
        "member": "worker_robots_battery_modifier  ::double Read/Write"
      },
      "worker_robots_storage_bonus": {
        "name": "worker_robots_storage_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "worker_robots_storage_bonus  ::double Read/Write"
      },
      "current_research": {
        "name": "current_research",
        "type": "LuaTechnology",
        "mode": "[R]",
        "doc": "The currently ongoing technology research, if any.",
        "short": "The currently ongoing technology research, if any.",
        "member": "current_research  ::LuaTechnology? Read"
      },
      "research_progress": {
        "name": "research_progress",
        "type": "double",
        "mode": "[RW]",
        "doc": "Progress of current research, as a number in range [0, 1].",
        "short": "Progress of current research, as a number in range [0, 1].",
        "member": "research_progress  ::double Read/Write"
      },
      "previous_research": {
        "name": "previous_research",
        "type": "LuaTechnology",
        "mode": "[RW]",
        "doc": "The previous research, if any.",
        "short": "The previous research, if any.",
        "member": "previous_research  ::LuaTechnology? Read/Write"
      },
      "inserter_stack_size_bonus": {
        "name": "inserter_stack_size_bonus",
        "type": "double",
        "mode": "[RW]",
        "doc": "The inserter stack size bonus for non stack inserters",
        "short": "The inserter stack size bonus for non stack inserters",
        "member": "inserter_stack_size_bonus  ::double Read/Write"
      },
      "stack_inserter_capacity_bonus": {
        "name": "stack_inserter_capacity_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Number of items that can be transferred by stack inserters. When writing to this value, it must be >= 0 and <= 254.",
        "short": "Number of items that can be transferred by stack inserters. [...]",
        "member": "stack_inserter_capacity_bonus  ::uint Read/Write"
      },
      "character_trash_slot_count": {
        "name": "character_trash_slot_count",
        "type": "double",
        "mode": "[RW]",
        "doc": "Number of character trash slots.",
        "short": "Number of character trash slots.",
        "member": "character_trash_slot_count  ::double Read/Write"
      },
      "maximum_following_robot_count": {
        "name": "maximum_following_robot_count",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Maximum number of follower robots.",
        "short": "Maximum number of follower robots.",
        "member": "maximum_following_robot_count  ::uint Read/Write"
      },
      "following_robots_lifetime_modifier": {
        "name": "following_robots_lifetime_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "Additional lifetime for following robots.",
        "short": "Additional lifetime for following robots.",
        "member": "following_robots_lifetime_modifier  ::double Read/Write"
      },
      "ghost_time_to_live": {
        "name": "ghost_time_to_live",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The time, in ticks, before a placed ghost disappears.",
        "short": "The time, in ticks, before a placed ghost disappears.",
        "member": "ghost_time_to_live  ::uint Read/Write"
      },
      "players": {
        "name": "players",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "Players belonging to this force.",
        "short": "Players belonging to this force.",
        "member": "players  ::array[LuaPlayer] Read"
      },
      "ai_controllable": {
        "name": "ai_controllable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Enables some higher-level AI behaviour for this force. When set to true, biters belonging to this force will automatically expand into new territories, build new spawners, and form unit groups. By default, this value is true for the enemy force and false for all others.",
        "short": "Enables some higher-level AI behaviour for this force. [...]",
        "member": "ai_controllable  ::boolean Read/Write"
      },
      "logistic_networks": {
        "name": "logistic_networks",
        "type": "string",
        "mode": "[R]",
        "doc": "List of logistic networks, grouped by surface.",
        "short": "List of logistic networks, grouped by surface.",
        "member": "logistic_networks  ::dictionary[string array[LuaLogisticNetwork]] Read"
      },
      "item_production_statistics": {
        "name": "item_production_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[R]",
        "doc": "The item production statistics for this force.",
        "short": "The item production statistics for this force.",
        "member": "item_production_statistics  ::LuaFlowStatistics Read"
      },
      "fluid_production_statistics": {
        "name": "fluid_production_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[R]",
        "doc": "The fluid production statistics for this force.",
        "short": "The fluid production statistics for this force.",
        "member": "fluid_production_statistics  ::LuaFlowStatistics Read"
      },
      "kill_count_statistics": {
        "name": "kill_count_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[R]",
        "doc": "The kill counter statistics for this force.",
        "short": "The kill counter statistics for this force.",
        "member": "kill_count_statistics  ::LuaFlowStatistics Read"
      },
      "entity_build_count_statistics": {
        "name": "entity_build_count_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[R]",
        "doc": "The entity build statistics for this force (built and mined)",
        "short": "The entity build statistics for this force (built and mined)",
        "member": "entity_build_count_statistics  ::LuaFlowStatistics Read"
      },
      "character_running_speed_modifier": {
        "name": "character_running_speed_modifier",
        "type": "double",
        "mode": "[RW]",
        "doc": "Modifies the running speed of all characters in this force by the given value as a percentage. Setting the running modifier to 0.5 makes the character run 50% faster. The minimum value of -1 reduces the movement speed by 100%, resulting in a speed of 0.",
        "short": "Modifies the running speed of all characters in this force by the given value as a percentage. [...]",
        "member": "character_running_speed_modifier  ::double Read/Write"
      },
      "artillery_range_modifier": {
        "name": "artillery_range_modifier",
        "type": "double",
        "mode": "[RW]",
        "member": "artillery_range_modifier  ::double Read/Write"
      },
      "character_build_distance_bonus": {
        "name": "character_build_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "member": "character_build_distance_bonus  ::uint Read/Write"
      },
      "character_item_drop_distance_bonus": {
        "name": "character_item_drop_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "member": "character_item_drop_distance_bonus  ::uint Read/Write"
      },
      "character_reach_distance_bonus": {
        "name": "character_reach_distance_bonus",
        "type": "uint",
        "mode": "[RW]",
        "member": "character_reach_distance_bonus  ::uint Read/Write"
      },
      "character_resource_reach_distance_bonus": {
        "name": "character_resource_reach_distance_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "character_resource_reach_distance_bonus  ::double Read/Write"
      },
      "character_item_pickup_distance_bonus": {
        "name": "character_item_pickup_distance_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "character_item_pickup_distance_bonus  ::double Read/Write"
      },
      "character_loot_pickup_distance_bonus": {
        "name": "character_loot_pickup_distance_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "character_loot_pickup_distance_bonus  ::double Read/Write"
      },
      "character_inventory_slots_bonus": {
        "name": "character_inventory_slots_bonus",
        "type": "uint",
        "mode": "[RW]",
        "doc": "the number of additional inventory slots the character main inventory has.",
        "short": "the number of additional inventory slots the character main inventory has.",
        "member": "character_inventory_slots_bonus  ::uint Read/Write"
      },
      "deconstruction_time_to_live": {
        "name": "deconstruction_time_to_live",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The time, in ticks, before a deconstruction order is removed.",
        "short": "The time, in ticks, before a deconstruction order is removed.",
        "member": "deconstruction_time_to_live  ::uint Read/Write"
      },
      "character_health_bonus": {
        "name": "character_health_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "character_health_bonus  ::double Read/Write"
      },
      "max_successful_attempts_per_tick_per_construction_queue": {
        "name": "max_successful_attempts_per_tick_per_construction_queue",
        "type": "uint",
        "mode": "[RW]",
        "member": "max_successful_attempts_per_tick_per_construction_queue  ::uint Read/Write"
      },
      "max_failed_attempts_per_tick_per_construction_queue": {
        "name": "max_failed_attempts_per_tick_per_construction_queue",
        "type": "uint",
        "mode": "[RW]",
        "member": "max_failed_attempts_per_tick_per_construction_queue  ::uint Read/Write"
      },
      "zoom_to_world_enabled": {
        "name": "zoom_to_world_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Ability to use zoom-to-world on map.",
        "short": "Ability to use zoom-to-world on map.",
        "member": "zoom_to_world_enabled  ::boolean Read/Write"
      },
      "zoom_to_world_ghost_building_enabled": {
        "name": "zoom_to_world_ghost_building_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Ability to build ghosts through blueprint or direct ghost placement, or \"mine\" ghosts when using zoom-to-world.",
        "short": "Ability to build ghosts through blueprint or direct ghost placement, or \"mine\" ghosts when using zoom-to-world.",
        "member": "zoom_to_world_ghost_building_enabled  ::boolean Read/Write"
      },
      "zoom_to_world_blueprint_enabled": {
        "name": "zoom_to_world_blueprint_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Ability to create new blueprints using empty blueprint item when using zoom-to-world.",
        "short": "Ability to create new blueprints using empty blueprint item when using zoom-to-world.",
        "member": "zoom_to_world_blueprint_enabled  ::boolean Read/Write"
      },
      "zoom_to_world_deconstruction_planner_enabled": {
        "name": "zoom_to_world_deconstruction_planner_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Ability to use deconstruction planner when using zoom-to-world.",
        "short": "Ability to use deconstruction planner when using zoom-to-world.",
        "member": "zoom_to_world_deconstruction_planner_enabled  ::boolean Read/Write"
      },
      "zoom_to_world_selection_tool_enabled": {
        "name": "zoom_to_world_selection_tool_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Ability to use custom selection tools when using zoom-to-world.",
        "short": "Ability to use custom selection tools when using zoom-to-world.",
        "member": "zoom_to_world_selection_tool_enabled  ::boolean Read/Write"
      },
      "character_logistic_requests": {
        "name": "character_logistic_requests",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if character requester logistics is enabled.",
        "short": "true if character requester logistics is enabled.",
        "member": "character_logistic_requests  ::boolean Read/Write"
      },
      "rockets_launched": {
        "name": "rockets_launched",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The number of rockets launched.",
        "short": "The number of rockets launched.",
        "member": "rockets_launched  ::uint Read/Write"
      },
      "items_launched": {
        "name": "items_launched",
        "type": "string",
        "mode": "[R]",
        "doc": "All of the items that have been launched in rockets. The attribute is a dictionary mapping the item prototype names to the launched amounts.",
        "short": "All of the items that have been launched in rockets. [...]",
        "member": "items_launched  ::dictionary[string uint] Read"
      },
      "connected_players": {
        "name": "connected_players",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The connected players belonging to this force.",
        "short": "The connected players belonging to this force. [...]",
        "member": "connected_players  ::array[LuaPlayer] Read"
      },
      "mining_drill_productivity_bonus": {
        "name": "mining_drill_productivity_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "mining_drill_productivity_bonus  ::double Read/Write"
      },
      "train_braking_force_bonus": {
        "name": "train_braking_force_bonus",
        "type": "double",
        "mode": "[RW]",
        "member": "train_braking_force_bonus  ::double Read/Write"
      },
      "evolution_factor": {
        "name": "evolution_factor",
        "type": "double",
        "mode": "[RW]",
        "doc": "Evolution factor of this force.",
        "short": "Evolution factor of this force.",
        "member": "evolution_factor  ::double Read/Write"
      },
      "evolution_factor_by_pollution": {
        "name": "evolution_factor_by_pollution",
        "type": "double",
        "mode": "[RW]",
        "member": "evolution_factor_by_pollution  ::double Read/Write"
      },
      "evolution_factor_by_time": {
        "name": "evolution_factor_by_time",
        "type": "double",
        "mode": "[RW]",
        "member": "evolution_factor_by_time  ::double Read/Write"
      },
      "evolution_factor_by_killing_spawners": {
        "name": "evolution_factor_by_killing_spawners",
        "type": "double",
        "mode": "[RW]",
        "member": "evolution_factor_by_killing_spawners  ::double Read/Write"
      },
      "friendly_fire": {
        "name": "friendly_fire",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If friendly fire is enabled for this force.",
        "short": "If friendly fire is enabled for this force.",
        "member": "friendly_fire  ::boolean Read/Write"
      },
      "share_chart": {
        "name": "share_chart",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If sharing chart data is enabled for this force.",
        "short": "If sharing chart data is enabled for this force.",
        "member": "share_chart  ::boolean Read/Write"
      },
      "research_queue_enabled": {
        "name": "research_queue_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the research queue is available for this force.",
        "short": "Whether the research queue is available for this force.",
        "member": "research_queue_enabled  ::boolean Read/Write"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[R]",
        "doc": "This force's index in LuaGameScript::forces (unique ID). It is assigned when a force is created, and remains so until it is merged (ie. deleted). Indexes of merged forces can be reused.",
        "short": "This force's index in LuaGameScript::forces (unique ID). [...]",
        "member": "index  ::uint Read"
      },
      "research_queue": {
        "name": "research_queue",
        "type": "TechnologyIdentification",
        "mode": "[RW]",
        "doc": "The research queue of this force. The first technology in the array is the currently active one. Reading this attribute gives an array of LuaTechnology.",
        "short": "The research queue of this force. [...]",
        "member": "research_queue  ::array[TechnologyIdentification] Read/Write"
      },
      "research_enabled": {
        "name": "research_enabled",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether research is enabled for this force, see LuaForce::enable_research and LuaForce::disable_research",
        "short": "Whether research is enabled for this force, see LuaForce::enable_research and LuaForce::disable_research",
        "member": "research_enabled  ::boolean Read"
      },
      "custom_color": {
        "name": "custom_color",
        "type": "Color",
        "mode": "[RW]",
        "doc": "Custom color for this force. If specified, will take priority over other sources of the force color. Writing nil clears custom color. Will return nil if it was not specified or if was set to {0,0,0,0}",
        "short": "Custom color for this force. [...]",
        "member": "custom_color  ::Color? Read/Write"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[R]",
        "doc": "Effective color of this force.",
        "short": "Effective color of this force.",
        "member": "color  ::Color Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaFuelCategoryPrototype": {
    "name": "LuaFuelCategoryPrototype",
    "type": "LuaFuelCategoryPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaGameScript": {
    "name": "LuaGameScript",
    "type": "LuaGameScript",
    "inherits": [],
    "properties": {
      "set_game_state": {
        "name": "set_game_state",
        "doc": "Set scenario state. Any parameters not provided do not change the current state.",
        "short": "Set scenario state. [...]",
        "member": "set_game_state{game_finished?=, player_won?=, next_level?=, can_continue?=, victorious_force?=}",
        "args": {
          "game_finished": {
            "name": "game_finished",
            "type": "boolean?",
            "doc": ""
          },
          "player_won": {
            "name": "player_won",
            "type": "boolean?",
            "doc": ""
          },
          "next_level": {
            "name": "next_level",
            "type": "string?",
            "doc": ""
          },
          "can_continue": {
            "name": "can_continue",
            "type": "boolean?",
            "doc": ""
          },
          "victorious_force": {
            "name": "victorious_force",
            "type": "ForceIdentification?",
            "doc": ""
          }
        }
      },
      "reset_game_state": {
        "name": "reset_game_state",
        "doc": "Reset scenario state (game_finished, player_won, etc.).",
        "short": "Reset scenario state (game_finished, player_won, etc.).",
        "member": "reset_game_state()",
        "type": "function"
      },
      "get_entity_by_tag": {
        "name": "get_entity_by_tag",
        "type": "function",
        "doc": "Gets an entity by its name tag. Entity name tags can be set in the entity \"extra settings\" GUI in the map editor.",
        "short": "Gets an entity by its name tag. [...]",
        "member": "get_entity_by_tag(tag)  LuaEntity?",
        "args": {
          "tag": {
            "name": "tag",
            "type": "string",
            "doc": ""
          }
        }
      },
      "show_message_dialog": {
        "name": "show_message_dialog",
        "doc": "Show an in-game message dialog.",
        "short": "Show an in-game message dialog.",
        "member": "show_message_dialog{text=, image?=, point_to?=, style?=, wrapper_frame_style?=}",
        "args": {
          "text": {
            "name": "text",
            "type": "LocalisedString",
            "doc": "What the dialog should say"
          },
          "image": {
            "name": "image",
            "type": "string?",
            "doc": "Path to an image to show on the dialog"
          },
          "point_to": {
            "name": "point_to",
            "type": "GuiArrowSpecification?",
            "doc": "If specified, dialog will show an arrow pointing to this place. When not specified, the arrow will point to the player's position. (Use point_to={type=\"nowhere\"} to remove the arrow entirely.) The dialog itself will be placed near the arrow's target."
          },
          "style": {
            "name": "style",
            "type": "string?",
            "doc": "The gui style to use for this speech bubble. Must be of type speech_bubble."
          },
          "wrapper_frame_style": {
            "name": "wrapper_frame_style",
            "type": "string?",
            "doc": "Must be of type flow_style."
          }
        }
      },
      "is_demo": {
        "name": "is_demo",
        "type": "function",
        "doc": "Is this the demo version of Factorio?",
        "short": "Is this the demo version of Factorio?",
        "member": "is_demo()  boolean"
      },
      "reload_script": {
        "name": "reload_script",
        "doc": "Forces a reload of the scenario script from the original scenario location.",
        "short": "Forces a reload of the scenario script from the original scenario location.",
        "member": "reload_script()",
        "type": "function"
      },
      "reload_mods": {
        "name": "reload_mods",
        "doc": "Forces a reload of all mods.",
        "short": "Forces a reload of all mods.",
        "member": "reload_mods()",
        "type": "function"
      },
      "save_atlas": {
        "name": "save_atlas",
        "doc": "Saves the current configuration of Atlas to a file. This will result in huge file containing all of the game graphics moved to as small space as possible.",
        "short": "Saves the current configuration of Atlas to a file. [...]",
        "member": "save_atlas()",
        "type": "function"
      },
      "check_consistency": {
        "name": "check_consistency",
        "doc": "Run internal consistency checks. Allegedly prints any errors it finds.",
        "short": "Run internal consistency checks. [...]",
        "member": "check_consistency()",
        "type": "function"
      },
      "regenerate_entity": {
        "name": "regenerate_entity",
        "doc": "Regenerate autoplacement of some entities on all surfaces. This can be used to autoplace newly-added entities.",
        "short": "Regenerate autoplacement of some entities on all surfaces. [...]",
        "member": "regenerate_entity(entities)",
        "type": "function",
        "args": {
          "entities": {
            "name": "entities",
            "type": "string or array[string]",
            "doc": "Prototype names of entity or entities to autoplace."
          }
        }
      },
      "take_screenshot": {
        "name": "take_screenshot",
        "doc": "Take a screenshot of the game and save it to the script-output folder, located in the game's user data directory. The name of the image file can be specified via the path parameter.",
        "short": "Take a screenshot of the game and save it to the script-output folder, located in the game's user data directory. [...]",
        "member": "take_screenshot{player?=, by_player?=, surface?=, position?=, resolution?=, zoom?=, path?=, show_gui?=, show_entity_info?=, show_cursor_building_preview?=, anti_alias?=, quality?=, allow_in_replay?=, daytime?=, water_tick?=, force_render?=}",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to focus on. Defaults to the local player."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If defined, the screenshot will only be taken for this player."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "If defined, the screenshot will be taken on this surface."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "If defined, the screenshot will be centered on this position. Otherwise, the screenshot will center on player."
          },
          "resolution": {
            "name": "resolution",
            "type": "TilePosition?",
            "doc": "The maximum allowed resolution is 16384x16384 (8192x8192 when anti_alias is true), but the maximum recommended resolution is 4096x4096 (resp. 2048x2048). The x value of the position is used as the width, the y value as the height."
          },
          "zoom": {
            "name": "zoom",
            "type": "double?",
            "doc": "The map zoom to take the screenshot at. Defaults to 1."
          },
          "path": {
            "name": "path",
            "type": "string?",
            "doc": "The name of the image file. It should include a file extension indicating the desired format. Supports .png, .jpg /.jpeg, .tga and .bmp. Providing a directory path (ex. \"save/here/screenshot.png\") will create the necessary folder structure in script-output. Defaults to \"screenshot.png\"."
          },
          "show_gui": {
            "name": "show_gui",
            "type": "boolean?",
            "doc": "Whether to include GUIs in the screenshot or not. Defaults to false."
          },
          "show_entity_info": {
            "name": "show_entity_info",
            "type": "boolean?",
            "doc": "Whether to include entity info (\"Alt mode\") or not. Defaults to false."
          },
          "show_cursor_building_preview": {
            "name": "show_cursor_building_preview",
            "type": "boolean?",
            "doc": "When true and when player is specified, the building preview for the item in the player's cursor will also be rendered. Defaults to false."
          },
          "anti_alias": {
            "name": "anti_alias",
            "type": "boolean?",
            "doc": "Whether to render in double resolution and downscale the result (including GUI). Defaults to false."
          },
          "quality": {
            "name": "quality",
            "type": "int?",
            "doc": "The .jpg render quality as a percentage (from 0% to 100% inclusive), if used. A lower value means a more compressed image. Defaults to 80."
          },
          "allow_in_replay": {
            "name": "allow_in_replay",
            "type": "boolean?",
            "doc": "Whether to save the screenshot even during replay playback. Defaults to false."
          },
          "daytime": {
            "name": "daytime",
            "type": "double?",
            "doc": "Overrides the current surface daytime for the duration of screenshot rendering."
          },
          "water_tick": {
            "name": "water_tick",
            "type": "uint?",
            "doc": "Overrides the tick of water animation, if animated water is enabled."
          },
          "force_render": {
            "name": "force_render",
            "type": "boolean?",
            "doc": "Screenshot requests are processed in between game update and render. The game may skip rendering (ie. drop frames) if the previous frame has not finished rendering or the game simulation starts to fall below 60 updates per second. If force_render is set to true, the game won't drop frames and process the screenshot request at the end of the update in which the request was created. This is not honored on multiplayer clients that are catching up to server. Defaults to false."
          }
        }
      },
      "set_wait_for_screenshots_to_finish": {
        "name": "set_wait_for_screenshots_to_finish",
        "doc": "Forces the screenshot saving system to wait until all queued screenshots have been written to disk.",
        "short": "Forces the screenshot saving system to wait until all queued screenshots have been written to disk.",
        "member": "set_wait_for_screenshots_to_finish()",
        "type": "function"
      },
      "take_technology_screenshot": {
        "name": "take_technology_screenshot",
        "doc": "Take a screenshot of the technology screen and save it to the script-output folder, located in the game's user data directory. The name of the image file can be specified via the path parameter.",
        "short": "Take a screenshot of the technology screen and save it to the script-output folder, located in the game's user data directory. [...]",
        "member": "take_technology_screenshot{force?=, path?=, by_player?=, selected_technology?=, skip_disabled?=, quality?=}",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force whose technology to screenshot. If not given, the \"player\" force is used."
          },
          "path": {
            "name": "path",
            "type": "string?",
            "doc": "The name of the image file. It should include a file extension indicating the desired format. Supports .png, .jpg /.jpeg, .tga and .bmp. Providing a directory path (ex. \"save/here/screenshot.png\") will create the necessary folder structure in script-output. Defaults to \"technology-screenshot.png\"."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "If given, the screenshot will only be taken for this player."
          },
          "selected_technology": {
            "name": "selected_technology",
            "type": "TechnologyIdentification?",
            "doc": "The technology to highlight."
          },
          "skip_disabled": {
            "name": "skip_disabled",
            "type": "boolean?",
            "doc": "If true, disabled technologies will be skipped. Their successors will be attached to the disabled technology's parents. Defaults to false."
          },
          "quality": {
            "name": "quality",
            "type": "int?",
            "doc": "The .jpg render quality as a percentage (from 0% to 100% inclusive), if used. A lower value means a more compressed image. Defaults to 80."
          }
        }
      },
      "table_to_json": {
        "name": "table_to_json",
        "type": "function",
        "doc": "Convert a table to a JSON string",
        "short": "Convert a table to a JSON string",
        "member": "table_to_json(data)  string",
        "args": {
          "data": {
            "name": "data",
            "type": "table",
            "doc": ""
          }
        }
      },
      "json_to_table": {
        "name": "json_to_table",
        "type": "function",
        "doc": "Convert a JSON string to a table. Returns: The returned object, or nil if the JSON string was invalid.",
        "short": "Convert a JSON string to a table.",
        "member": "json_to_table(json)  AnyBasic?",
        "returns": "AnyBasic?",
        "args": {
          "json": {
            "name": "json",
            "type": "string",
            "doc": "The string to convert."
          }
        }
      },
      "write_file": {
        "name": "write_file",
        "doc": "Write a file to the script-output folder, located in the game's user data directory. The name and file extension of the file can be specified via the filename parameter.",
        "short": "Write a file to the script-output folder, located in the game's user data directory. [...]",
        "member": "write_file(filename, data, append?, for_player?)",
        "type": "function",
        "args": {
          "filename": {
            "name": "filename",
            "type": "string",
            "doc": "The name of the file. Providing a directory path (ex. \"save/here/example.txt\") will create the necessary folder structure in script-output."
          },
          "data": {
            "name": "data",
            "type": "LocalisedString",
            "doc": "The content to write to the file."
          },
          "append": {
            "name": "append",
            "type": "boolean?",
            "doc": "If true, data will be appended to the end of the file. Defaults to false, which will overwrite any pre-existing file with the new data."
          },
          "for_player": {
            "name": "for_player",
            "type": "uint?",
            "doc": "If given, the file will only be written for this player_index. Providing 0 will only write to the server's output if present."
          }
        }
      },
      "remove_path": {
        "name": "remove_path",
        "doc": "Remove a file or directory in the script-output folder, located in the game's user data directory. Can be used to remove files created by LuaGameScript::write_file.",
        "short": "Remove a file or directory in the script-output folder, located in the game's user data directory. [...]",
        "member": "remove_path(path)",
        "type": "function",
        "args": {
          "path": {
            "name": "path",
            "type": "string",
            "doc": "The path to the file or directory to remove, relative to script-output."
          }
        }
      },
      "remove_offline_players": {
        "name": "remove_offline_players",
        "doc": "Remove players who are currently not connected from the map.",
        "short": "Remove players who are currently not connected from the map.",
        "member": "remove_offline_players(players?)",
        "type": "function",
        "args": {
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "List of players to remove. If not specified, remove all offline players."
          },
          "on_pre_player_removed": {
            "name": "on_pre_player_removed",
            "doc": ""
          },
          "on_player_removed": {
            "name": "on_player_removed",
            "doc": ""
          }
        }
      },
      "force_crc": {
        "name": "force_crc",
        "doc": "Force a CRC check. Tells all peers to calculate their current CRC, which are then compared to each other. If a mismatch is detected, the game desyncs and some peers are forced to reconnect.",
        "short": "Force a CRC check. [...]",
        "member": "force_crc()",
        "type": "function"
      },
      "create_force": {
        "name": "create_force",
        "type": "function",
        "doc": "Create a new force. Returns: The force that was just created",
        "short": "Create a new force.",
        "member": "create_force(force)  LuaForce",
        "returns": "LuaForce",
        "args": {
          "force": {
            "name": "force",
            "type": "string",
            "doc": "Name of the new force"
          },
          "on_force_created": {
            "name": "on_force_created",
            "doc": ""
          }
        }
      },
      "merge_forces": {
        "name": "merge_forces",
        "doc": "Marks two forces to be merged together. All players and entities in the source force will be reassigned to the target force. The source force will then be destroyed. Importantly, this does not merge technologies or bonuses, which are instead retained from the target force.",
        "short": "Marks two forces to be merged together. [...]",
        "member": "merge_forces(source, destination)",
        "type": "function",
        "args": {
          "source": {
            "name": "source",
            "type": "ForceIdentification",
            "doc": "The force to remove."
          },
          "destination": {
            "name": "destination",
            "type": "ForceIdentification",
            "doc": "The force to reassign all entities to."
          },
          "on_forces_merging": {
            "name": "on_forces_merging",
            "doc": ""
          },
          "on_forces_merged": {
            "name": "on_forces_merged",
            "doc": ""
          }
        }
      },
      "create_surface": {
        "name": "create_surface",
        "type": "function",
        "doc": "Create a new surface. Returns: The surface that was just created.",
        "short": "Create a new surface.",
        "member": "create_surface(name, settings?)  LuaSurface",
        "returns": "LuaSurface",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the new surface."
          },
          "settings": {
            "name": "settings",
            "type": "MapGenSettings?",
            "doc": "Map generation settings."
          },
          "on_surface_created": {
            "name": "on_surface_created",
            "doc": ""
          }
        }
      },
      "server_save": {
        "name": "server_save",
        "doc": "Instruct the server to save the map. Only actually saves when in multiplayer.",
        "short": "Instruct the server to save the map. [...]",
        "member": "server_save(name?)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string?",
            "doc": "Save file name. If not specified, the currently running save is overwritten."
          }
        }
      },
      "auto_save": {
        "name": "auto_save",
        "doc": "Instruct the game to perform an auto-save.",
        "short": "Instruct the game to perform an auto-save.",
        "member": "auto_save(name?)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string?",
            "doc": "The autosave name if any. Saves will be named _autosave-name when provided."
          }
        }
      },
      "delete_surface": {
        "name": "delete_surface",
        "doc": "Deletes the given surface and all entities on it.",
        "short": "Deletes the given surface and all entities on it.",
        "member": "delete_surface(surface)",
        "type": "function",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "The surface to be deleted. Currently the primary surface (1, 'nauvis') cannot be deleted."
          },
          "on_pre_surface_deleted": {
            "name": "on_pre_surface_deleted",
            "doc": ""
          },
          "on_surface_deleted": {
            "name": "on_surface_deleted",
            "doc": ""
          }
        }
      },
      "disable_replay": {
        "name": "disable_replay",
        "doc": "Disables replay saving for the current save file. Once done there's no way to re-enable replay saving for the save file without loading an old save.",
        "short": "Disables replay saving for the current save file. [...]",
        "member": "disable_replay()",
        "type": "function"
      },
      "disable_tutorial_triggers": {
        "name": "disable_tutorial_triggers",
        "doc": "Disables tutorial triggers, that unlock new tutorials and show notices about unlocked tutorials.",
        "short": "Disables tutorial triggers, that unlock new tutorials and show notices about unlocked tutorials.",
        "member": "disable_tutorial_triggers()",
        "type": "function"
      },
      "direction_to_string": {
        "name": "direction_to_string",
        "doc": "Converts the given direction into the string version of the direction.",
        "short": "Converts the given direction into the string version of the direction.",
        "member": "direction_to_string(direction)",
        "type": "function",
        "args": {
          "direction": {
            "name": "direction",
            "type": "defines.direction",
            "doc": ""
          }
        }
      },
      "print": {
        "name": "print",
        "doc": "Print text to the chat console all players.",
        "short": "Print text to the chat console all players.",
        "member": "print(message, print_settings?)",
        "type": "function",
        "args": {
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": ""
          },
          "print_settings": {
            "name": "print_settings",
            "type": "Color or PrintSettings?",
            "doc": ""
          }
        }
      },
      "create_random_generator": {
        "name": "create_random_generator",
        "type": "function",
        "doc": "Creates a deterministic standalone random generator with the given seed or if a seed is not provided the initial map seed is used.",
        "short": "Creates a deterministic standalone random generator with the given seed or if a seed is not provided the initial map seed is used.",
        "member": "create_random_generator(seed?)  LuaRandomGenerator",
        "args": {
          "seed": {
            "name": "seed",
            "type": "uint?",
            "doc": ""
          }
        }
      },
      "check_prototype_translations": {
        "name": "check_prototype_translations",
        "doc": "Goes over all items, entities, tiles, recipes, technologies among other things and logs if the locale is incorrect.",
        "short": "Goes over all items, entities, tiles, recipes, technologies among other things and logs if the locale is incorrect.",
        "member": "check_prototype_translations()",
        "type": "function"
      },
      "play_sound": {
        "name": "play_sound",
        "doc": "Play a sound for every player in the game.",
        "short": "Play a sound for every player in the game.",
        "member": "play_sound{path=, position?=, volume_modifier?=, override_sound_type?=}",
        "args": {
          "path": {
            "name": "path",
            "type": "SoundPath",
            "doc": "The sound to play."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Where the sound should be played. If not given, it's played at the current position of each player."
          },
          "volume_modifier": {
            "name": "volume_modifier",
            "type": "double?",
            "doc": "The volume of the sound to play. Must be between 0 and 1 inclusive."
          },
          "override_sound_type": {
            "name": "override_sound_type",
            "type": "SoundType?",
            "doc": "The volume mixer to play the sound through. Defaults to the default mixer for the given sound type."
          }
        }
      },
      "is_valid_sound_path": {
        "name": "is_valid_sound_path",
        "type": "function",
        "doc": "Checks if the given SoundPath is valid.",
        "short": "Checks if the given SoundPath is valid.",
        "member": "is_valid_sound_path(sound_path)  boolean",
        "args": {
          "sound_path": {
            "name": "sound_path",
            "type": "SoundPath",
            "doc": "Path to the sound."
          }
        }
      },
      "is_valid_sprite_path": {
        "name": "is_valid_sprite_path",
        "type": "function",
        "doc": "Checks if the given SpritePath is valid and contains a loaded sprite. The existence of the image is not checked for paths of type file.",
        "short": "Checks if the given SpritePath is valid and contains a loaded sprite. [...]",
        "member": "is_valid_sprite_path(sprite_path)  boolean",
        "args": {
          "sprite_path": {
            "name": "sprite_path",
            "type": "SpritePath",
            "doc": "Path to the image."
          }
        }
      },
      "kick_player": {
        "name": "kick_player",
        "doc": "Kicks the given player from this multiplayer game. Does nothing if this is a single player game or if the player running this isn't an admin.",
        "short": "Kicks the given player from this multiplayer game. [...]",
        "member": "kick_player(player, reason?)",
        "type": "function",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": "The player to kick."
          },
          "reason": {
            "name": "reason",
            "type": "string?",
            "doc": "The reason given if any."
          },
          "on_player_kicked": {
            "name": "on_player_kicked",
            "doc": ""
          },
          "on_console_command": {
            "name": "on_console_command",
            "doc": ""
          }
        }
      },
      "ban_player": {
        "name": "ban_player",
        "doc": "Bans the given player from this multiplayer game. Does nothing if this is a single player game of if the player running this isn't an admin.",
        "short": "Bans the given player from this multiplayer game. [...]",
        "member": "ban_player(player, reason?)",
        "type": "function",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": "The player to ban."
          },
          "reason": {
            "name": "reason",
            "type": "string?",
            "doc": "The reason given if any."
          },
          "on_player_banned": {
            "name": "on_player_banned",
            "doc": ""
          },
          "on_console_command": {
            "name": "on_console_command",
            "doc": ""
          }
        }
      },
      "unban_player": {
        "name": "unban_player",
        "doc": "Unbans the given player from this multiplayer game. Does nothing if this is a single player game of if the player running this isn't an admin.",
        "short": "Unbans the given player from this multiplayer game. [...]",
        "member": "unban_player(player)",
        "type": "function",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": "The player to unban."
          },
          "on_player_unbanned": {
            "name": "on_player_unbanned",
            "doc": ""
          },
          "on_console_command": {
            "name": "on_console_command",
            "doc": ""
          }
        }
      },
      "purge_player": {
        "name": "purge_player",
        "doc": "Purges the given players messages from the game. Does nothing if the player running this isn't an admin.",
        "short": "Purges the given players messages from the game. [...]",
        "member": "purge_player(player)",
        "type": "function",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": "The player to purge."
          },
          "on_console_command": {
            "name": "on_console_command",
            "doc": ""
          }
        }
      },
      "mute_player": {
        "name": "mute_player",
        "doc": "Mutes the given player. Does nothing if the player running this isn't an admin.",
        "short": "Mutes the given player. [...]",
        "member": "mute_player(player)",
        "type": "function",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": "The player to mute."
          },
          "on_player_muted": {
            "name": "on_player_muted",
            "doc": ""
          },
          "on_console_command": {
            "name": "on_console_command",
            "doc": ""
          }
        }
      },
      "unmute_player": {
        "name": "unmute_player",
        "doc": "Unmutes the given player. Does nothing if the player running this isn't an admin.",
        "short": "Unmutes the given player. [...]",
        "member": "unmute_player(player)",
        "type": "function",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": "The player to unmute."
          },
          "on_player_unmuted": {
            "name": "on_player_unmuted",
            "doc": ""
          },
          "on_console_command": {
            "name": "on_console_command",
            "doc": ""
          }
        }
      },
      "count_pipe_groups": {
        "name": "count_pipe_groups",
        "doc": "Counts how many distinct groups of pipes exist in the world.",
        "short": "Counts how many distinct groups of pipes exist in the world.",
        "member": "count_pipe_groups()",
        "type": "function"
      },
      "is_multiplayer": {
        "name": "is_multiplayer",
        "type": "function",
        "doc": "Whether the save is loaded as a multiplayer map.",
        "short": "Whether the save is loaded as a multiplayer map.",
        "member": "is_multiplayer()  boolean"
      },
      "get_active_entities_count": {
        "name": "get_active_entities_count",
        "type": "function",
        "doc": "Gets the number of entities that are active (updated each tick).",
        "short": "Gets the number of entities that are active (updated each tick).",
        "member": "get_active_entities_count(surface?)  uint",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "If given, only the entities active on this surface are counted."
          }
        }
      },
      "get_map_exchange_string": {
        "name": "get_map_exchange_string",
        "type": "function",
        "doc": "Gets the map exchange string for the map generation settings that were used to create this map.",
        "short": "Gets the map exchange string for the map generation settings that were used to create this map.",
        "member": "get_map_exchange_string()  string"
      },
      "parse_map_exchange_string": {
        "name": "parse_map_exchange_string",
        "type": "function",
        "doc": "Convert a map exchange string to map gen settings and map settings.",
        "short": "Convert a map exchange string to map gen settings and map settings.",
        "member": "parse_map_exchange_string(map_exchange_string)  MapExchangeStringData",
        "args": {
          "map_exchange_string": {
            "name": "map_exchange_string",
            "type": "string",
            "doc": ""
          }
        }
      },
      "get_train_stops": {
        "name": "get_train_stops",
        "type": "LuaEntity",
        "doc": "Gets train stops matching the given filters.",
        "short": "Gets train stops matching the given filters.",
        "member": "get_train_stops{name?=, surface?=, force?=}  array[LuaEntity]",
        "args": {
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "The name(s) of the train stops. Not providing names will match any stop."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": "The surface to search. Not providing a surface will match stops on any surface."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force to search. Not providing a force will match stops in any force."
          }
        }
      },
      "get_player": {
        "name": "get_player",
        "type": "function",
        "doc": "Gets the given player or returns nil if no player is found.",
        "short": "Gets the given player or returns nil if no player is found.",
        "member": "get_player(player)  LuaPlayer?",
        "args": {
          "player": {
            "name": "player",
            "type": "uint or string",
            "doc": "The player index or name."
          }
        }
      },
      "get_surface": {
        "name": "get_surface",
        "type": "function",
        "doc": "Gets the given surface or returns nil if no surface is found.",
        "short": "Gets the given surface or returns nil if no surface is found.",
        "member": "get_surface(surface)  LuaSurface?",
        "args": {
          "surface": {
            "name": "surface",
            "type": "uint or string",
            "doc": "The surface index or name."
          }
        }
      },
      "create_profiler": {
        "name": "create_profiler",
        "type": "function",
        "doc": "Creates a LuaProfiler, which is used for measuring script performance.",
        "short": "Creates a LuaProfiler, which is used for measuring script performance.",
        "member": "create_profiler(stopped?)  LuaProfiler",
        "args": {
          "stopped": {
            "name": "stopped",
            "type": "boolean?",
            "doc": "Create the timer stopped"
          }
        }
      },
      "evaluate_expression": {
        "name": "evaluate_expression",
        "type": "function",
        "doc": "Evaluate an expression, substituting variables as provided. For details on the formula, see TechnologyPrototype::unit.",
        "short": "Evaluate an expression, substituting variables as provided. [...]",
        "member": "evaluate_expression(expression, variables?)  double",
        "args": {
          "expression": {
            "name": "expression",
            "type": "string",
            "doc": "The expression to evaluate."
          },
          "variables": {
            "name": "variables",
            "type": "dictionary[string double]?",
            "doc": "Variables to be substituted."
          }
        }
      },
      "get_filtered_entity_prototypes": {
        "name": "get_filtered_entity_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaEntityPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaEntityPrototypes that fit the given filters. [...]",
        "member": "get_filtered_entity_prototypes(filters)  LuaCustomTable[string LuaEntityPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[EntityPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_item_prototypes": {
        "name": "get_filtered_item_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaItemPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaItemPrototypes that fit the given filters. [...]",
        "member": "get_filtered_item_prototypes(filters)  LuaCustomTable[string LuaItemPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[ItemPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_equipment_prototypes": {
        "name": "get_filtered_equipment_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaEquipmentPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaEquipmentPrototypes that fit the given filters. [...]",
        "member": "get_filtered_equipment_prototypes(filters)  LuaCustomTable[string LuaEquipmentPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[EquipmentPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_mod_setting_prototypes": {
        "name": "get_filtered_mod_setting_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaModSettingPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaModSettingPrototypes that fit the given filters. [...]",
        "member": "get_filtered_mod_setting_prototypes(filters)  LuaCustomTable[string LuaModSettingPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[ModSettingPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_achievement_prototypes": {
        "name": "get_filtered_achievement_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaAchievementPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaAchievementPrototypes that fit the given filters. [...]",
        "member": "get_filtered_achievement_prototypes(filters)  LuaCustomTable[string LuaAchievementPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[AchievementPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_tile_prototypes": {
        "name": "get_filtered_tile_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaTilePrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaTilePrototypes that fit the given filters. [...]",
        "member": "get_filtered_tile_prototypes(filters)  LuaCustomTable[string LuaTilePrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[TilePrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_decorative_prototypes": {
        "name": "get_filtered_decorative_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaDecorativePrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaDecorativePrototypes that fit the given filters. [...]",
        "member": "get_filtered_decorative_prototypes(filters)  LuaCustomTable[string LuaDecorativePrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[DecorativePrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_fluid_prototypes": {
        "name": "get_filtered_fluid_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaFluidPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaFluidPrototypes that fit the given filters. [...]",
        "member": "get_filtered_fluid_prototypes(filters)  LuaCustomTable[string LuaFluidPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[FluidPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_recipe_prototypes": {
        "name": "get_filtered_recipe_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaRecipePrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaRecipePrototypes that fit the given filters. [...]",
        "member": "get_filtered_recipe_prototypes(filters)  LuaCustomTable[string LuaRecipePrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[RecipePrototypeFilter]",
            "doc": ""
          }
        }
      },
      "get_filtered_technology_prototypes": {
        "name": "get_filtered_technology_prototypes",
        "type": "function",
        "doc": "Returns a dictionary of all LuaTechnologyPrototypes that fit the given filters. The prototypes are indexed by name.",
        "short": "Returns a dictionary of all LuaTechnologyPrototypes that fit the given filters. [...]",
        "member": "get_filtered_technology_prototypes(filters)  LuaCustomTable[string LuaTechnologyPrototype]",
        "args": {
          "filters": {
            "name": "filters",
            "type": "array[TechnologyPrototypeFilter]",
            "doc": ""
          }
        }
      },
      "create_inventory": {
        "name": "create_inventory",
        "type": "function",
        "doc": "Creates an inventory that is not owned by any game object. It can be resized later with LuaInventory::resize.",
        "short": "Creates an inventory that is not owned by any game object. [...]",
        "member": "create_inventory(size)  LuaInventory",
        "args": {
          "size": {
            "name": "size",
            "type": "uint16",
            "doc": "The number of slots the inventory initially has."
          }
        }
      },
      "get_script_inventories": {
        "name": "get_script_inventories",
        "type": "function",
        "doc": "Gets the inventories created through LuaGameScript::create_inventory Returns: A mapping of mod name to array of inventories owned by that mod.",
        "short": "Gets the inventories created through LuaGameScript::create_inventory",
        "member": "get_script_inventories(mod?)  dictionary[string array[LuaInventory]]",
        "returns": "dictionary[string array[LuaInventory]]",
        "args": {
          "mod": {
            "name": "mod",
            "type": "string?",
            "doc": "The mod who's inventories to get. If not provided all inventories are returned."
          }
        }
      },
      "reset_time_played": {
        "name": "reset_time_played",
        "doc": "Resets the amount of time played for this map.",
        "short": "Resets the amount of time played for this map.",
        "member": "reset_time_played()",
        "type": "function"
      },
      "encode_string": {
        "name": "encode_string",
        "type": "function",
        "doc": "Deflates and base64 encodes the given string. Returns: The encoded string or nil if the encode failed.",
        "short": "Deflates and base64 encodes the given string.",
        "member": "encode_string(string)  string?",
        "returns": "string?",
        "args": {
          "string": {
            "name": "string",
            "type": "string",
            "doc": "The string to encode."
          }
        }
      },
      "decode_string": {
        "name": "decode_string",
        "type": "function",
        "doc": "Base64 decodes and inflates the given string. Returns: The decoded string or nil if the decode failed.",
        "short": "Base64 decodes and inflates the given string.",
        "member": "decode_string(string)  string?",
        "returns": "string?",
        "args": {
          "string": {
            "name": "string",
            "type": "string",
            "doc": "The string to decode."
          }
        }
      },
      "get_train_by_id": {
        "name": "get_train_by_id",
        "type": "function",
        "doc": "Searches for a train with given ID. Returns: Train if found",
        "short": "Searches for a train with given ID.",
        "member": "get_train_by_id(train_id)  LuaTrain?",
        "returns": "LuaTrain?",
        "args": {
          "train_id": {
            "name": "train_id",
            "type": "uint",
            "doc": "Train ID to search"
          }
        }
      },
      "request_train_path": {
        "name": "request_train_path",
        "type": "TrainPathFinderPathResult",
        "doc": "Direct access to Trains Pathfinder. Allows to search rail paths or querying which stops are accessible Returns: The type of the returned value depends on type.",
        "short": "Direct access to Trains Pathfinder. [...]",
        "member": "request_train_path{goals=, in_chain_signal_section?=, train?=, type?=, return_path?=, from_front?=, allow_path_within_segment_front?=, from_back?=, allow_path_within_segment_back?=, search_direction?=, steps_limit?=}  TrainPathFinderPathResult or TrainPathAnyGoalResult or TrainPathAllGoalsResult",
        "returns": "TrainPathFinderPathResult or TrainPathAnyGoalResult or TrainPathAllGoalsResult",
        "args": {
          "goals": {
            "name": "goals",
            "type": "array[TrainStopGoal or RailEnd]",
            "doc": ""
          },
          "in_chain_signal_section": {
            "name": "in_chain_signal_section",
            "type": "boolean?",
            "doc": "Defaults to false. If set to true, pathfinder will not return a path that cannot have its beginning immediately reserved. A path that cannot have its beginning immediately reserved could cause a train to stop inside of an intersection."
          },
          "train": {
            "name": "train",
            "type": "LuaTrain?",
            "doc": "Mandatory if from_front and from_back are not provided, optional otherwise. Selects a context for the pathfinder to decide which train to exclude from penalties and which signals are considered possible to reacquire. If from_front and from_back are not provided, then it is also used to collect front and back ends for the search"
          },
          "type": {
            "name": "type",
            "type": "TrainPathRequestType?",
            "doc": "Request type. Determines the return type of the method. Defaults to \"path\"."
          },
          "return_path": {
            "name": "return_path",
            "type": "boolean?",
            "doc": "Only relevant if request type is \"path\". Returning a full path is expensive due to multiple LuaEntity created. In order for path to be returned, true must be provided here. Defaults to false in which case a path will not be provided."
          },
          "from_front": {
            "name": "from_front",
            "type": "RailEnd?",
            "doc": "Manually provided starting front of the train."
          },
          "allow_path_within_segment_front": {
            "name": "allow_path_within_segment_front",
            "type": "boolean?",
            "doc": "Only relevant if from_front is given. Defaults to true. Providing false will cause the pathfinder to reject a path that starts on front and ends within the same segment as the path would be too short to provide correct alignment with a goal."
          },
          "from_back": {
            "name": "from_back",
            "type": "RailEnd?",
            "doc": "Manually provided starting back of the train."
          },
          "allow_path_within_segment_back": {
            "name": "allow_path_within_segment_back",
            "type": "boolean?",
            "doc": "Only relevant if from_back is given. Defaults to true. Providing false will cause the pathfinder to reject a path that starts on back and ends within the same segment as the path would be too short to provide correct alignment with a goal."
          },
          "search_direction": {
            "name": "search_direction",
            "type": "\"respect-movement-direction\" or \"any-direction-with-locomotives\"?",
            "doc": "Only relevant if none of from_front/from_back was provided in which case from_front and from_back are deduced from the train. Selects which train ends should be considered as starts. Defaults to \"any-direction-with-locomotives\"."
          },
          "steps_limit": {
            "name": "steps_limit",
            "type": "uint?",
            "doc": "Maximum amount of steps pathfinder is allowed to perform."
          }
        }
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "This property is only populated inside custom command handlers and when writing Lua console commands. Returns the player that is typing the command, nil in all other instances.",
        "short": "This property is only populated inside custom command handlers and when writing Lua console commands. [...]",
        "member": "player  ::LuaPlayer? Read"
      },
      "players": {
        "name": "players",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Get a table of all the players that currently exist. This sparse table allows you to find players by indexing it with either their name or index. Iterating this table with pairs() will only iterate the array part of the table. Iterating with ipairs() will not work at all.",
        "short": "Get a table of all the players that currently exist. [...]",
        "member": "players  ::LuaCustomTable[uint or string LuaPlayer] Read"
      },
      "map_settings": {
        "name": "map_settings",
        "type": "MapSettings",
        "mode": "[R]",
        "doc": "The currently active set of map settings. Even though this property is marked as read-only, the members of the dictionary that is returned can be modified mid-game.",
        "short": "The currently active set of map settings. [...]",
        "member": "map_settings  ::MapSettings Read"
      },
      "difficulty_settings": {
        "name": "difficulty_settings",
        "type": "DifficultySettings",
        "mode": "[R]",
        "doc": "The currently active set of difficulty settings. Even though this property is marked as read-only, the members of the dictionary that is returned can be modified mid-game. This is however not recommended as different difficulties can have differing technology and recipe trees, which can cause problems for players.",
        "short": "The currently active set of difficulty settings. [...]",
        "member": "difficulty_settings  ::DifficultySettings Read"
      },
      "difficulty": {
        "name": "difficulty",
        "type": "defines.difficulty",
        "mode": "[R]",
        "doc": "Current scenario difficulty.",
        "short": "Current scenario difficulty.",
        "member": "difficulty  ::defines.difficulty Read"
      },
      "forces": {
        "name": "forces",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Get a table of all the forces that currently exist. This sparse table allows you to find forces by indexing it with either their name or index. Iterating this table with pairs() will only iterate the hash part of the table. Iterating with ipairs() will not work at all.",
        "short": "Get a table of all the forces that currently exist. [...]",
        "member": "forces  ::LuaCustomTable[uint or string LuaForce] Read"
      },
      "entity_prototypes": {
        "name": "entity_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaEntityPrototype indexed by name.",
        "short": "A dictionary containing every LuaEntityPrototype indexed by name.",
        "member": "entity_prototypes  ::LuaCustomTable[string LuaEntityPrototype] Read"
      },
      "item_prototypes": {
        "name": "item_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaItemPrototype indexed by name.",
        "short": "A dictionary containing every LuaItemPrototype indexed by name.",
        "member": "item_prototypes  ::LuaCustomTable[string LuaItemPrototype] Read"
      },
      "fluid_prototypes": {
        "name": "fluid_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaFluidPrototype indexed by name.",
        "short": "A dictionary containing every LuaFluidPrototype indexed by name.",
        "member": "fluid_prototypes  ::LuaCustomTable[string LuaFluidPrototype] Read"
      },
      "tile_prototypes": {
        "name": "tile_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaTilePrototype indexed by name.",
        "short": "A dictionary containing every LuaTilePrototype indexed by name.",
        "member": "tile_prototypes  ::LuaCustomTable[string LuaTilePrototype] Read"
      },
      "equipment_prototypes": {
        "name": "equipment_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaEquipmentPrototype indexed by name.",
        "short": "A dictionary containing every LuaEquipmentPrototype indexed by name.",
        "member": "equipment_prototypes  ::LuaCustomTable[string LuaEquipmentPrototype] Read"
      },
      "damage_prototypes": {
        "name": "damage_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaDamagePrototype indexed by name.",
        "short": "A dictionary containing every LuaDamagePrototype indexed by name.",
        "member": "damage_prototypes  ::LuaCustomTable[string LuaDamagePrototype] Read"
      },
      "virtual_signal_prototypes": {
        "name": "virtual_signal_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaVirtualSignalPrototype indexed by name.",
        "short": "A dictionary containing every LuaVirtualSignalPrototype indexed by name.",
        "member": "virtual_signal_prototypes  ::LuaCustomTable[string LuaVirtualSignalPrototype] Read"
      },
      "equipment_grid_prototypes": {
        "name": "equipment_grid_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaEquipmentGridPrototype indexed by name.",
        "short": "A dictionary containing every LuaEquipmentGridPrototype indexed by name.",
        "member": "equipment_grid_prototypes  ::LuaCustomTable[string LuaEquipmentGridPrototype] Read"
      },
      "recipe_prototypes": {
        "name": "recipe_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaRecipePrototype indexed by name.",
        "short": "A dictionary containing every LuaRecipePrototype indexed by name.",
        "member": "recipe_prototypes  ::LuaCustomTable[string LuaRecipePrototype] Read"
      },
      "technology_prototypes": {
        "name": "technology_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaTechnologyPrototype indexed by name.",
        "short": "A dictionary containing every LuaTechnologyPrototype indexed by name.",
        "member": "technology_prototypes  ::LuaCustomTable[string LuaTechnologyPrototype] Read"
      },
      "decorative_prototypes": {
        "name": "decorative_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaDecorativePrototype indexed by name.",
        "short": "A dictionary containing every LuaDecorativePrototype indexed by name.",
        "member": "decorative_prototypes  ::LuaCustomTable[string LuaDecorativePrototype] Read"
      },
      "particle_prototypes": {
        "name": "particle_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaParticlePrototype indexed by name.",
        "short": "A dictionary containing every LuaParticlePrototype indexed by name.",
        "member": "particle_prototypes  ::LuaCustomTable[string LuaParticlePrototype] Read"
      },
      "autoplace_control_prototypes": {
        "name": "autoplace_control_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaAutoplaceControlPrototype indexed by name.",
        "short": "A dictionary containing every LuaAutoplaceControlPrototype indexed by name.",
        "member": "autoplace_control_prototypes  ::LuaCustomTable[string LuaAutoplaceControlPrototype] Read"
      },
      "noise_layer_prototypes": {
        "name": "noise_layer_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaNoiseLayerPrototype indexed by name.",
        "short": "A dictionary containing every LuaNoiseLayerPrototype indexed by name.",
        "member": "noise_layer_prototypes  ::LuaCustomTable[string LuaNoiseLayerPrototype] Read"
      },
      "mod_setting_prototypes": {
        "name": "mod_setting_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaModSettingPrototype indexed by name.",
        "short": "A dictionary containing every LuaModSettingPrototype indexed by name.",
        "member": "mod_setting_prototypes  ::LuaCustomTable[string LuaModSettingPrototype] Read"
      },
      "custom_input_prototypes": {
        "name": "custom_input_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaCustomInputPrototype indexed by name.",
        "short": "A dictionary containing every LuaCustomInputPrototype indexed by name.",
        "member": "custom_input_prototypes  ::LuaCustomTable[string LuaCustomInputPrototype] Read"
      },
      "ammo_category_prototypes": {
        "name": "ammo_category_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaAmmoCategoryPrototype indexed by name.",
        "short": "A dictionary containing every LuaAmmoCategoryPrototype indexed by name.",
        "member": "ammo_category_prototypes  ::LuaCustomTable[string LuaAmmoCategoryPrototype] Read"
      },
      "named_noise_expressions": {
        "name": "named_noise_expressions",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaNamedNoiseExpression indexed by name.",
        "short": "A dictionary containing every LuaNamedNoiseExpression indexed by name.",
        "member": "named_noise_expressions  ::LuaCustomTable[string LuaNamedNoiseExpression] Read"
      },
      "item_subgroup_prototypes": {
        "name": "item_subgroup_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every ItemSubgroup indexed by name.",
        "short": "A dictionary containing every ItemSubgroup indexed by name.",
        "member": "item_subgroup_prototypes  ::LuaCustomTable[string LuaGroup] Read"
      },
      "item_group_prototypes": {
        "name": "item_group_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every ItemGroup indexed by name.",
        "short": "A dictionary containing every ItemGroup indexed by name.",
        "member": "item_group_prototypes  ::LuaCustomTable[string LuaGroup] Read"
      },
      "fuel_category_prototypes": {
        "name": "fuel_category_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaFuelCategoryPrototype indexed by name.",
        "short": "A dictionary containing every LuaFuelCategoryPrototype indexed by name.",
        "member": "fuel_category_prototypes  ::LuaCustomTable[string LuaFuelCategoryPrototype] Read"
      },
      "resource_category_prototypes": {
        "name": "resource_category_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaResourceCategoryPrototype indexed by name.",
        "short": "A dictionary containing every LuaResourceCategoryPrototype indexed by name.",
        "member": "resource_category_prototypes  ::LuaCustomTable[string LuaResourceCategoryPrototype] Read"
      },
      "achievement_prototypes": {
        "name": "achievement_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaAchievementPrototype indexed by name.",
        "short": "A dictionary containing every LuaAchievementPrototype indexed by name.",
        "member": "achievement_prototypes  ::LuaCustomTable[string LuaAchievementPrototype] Read"
      },
      "module_category_prototypes": {
        "name": "module_category_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaModuleCategoryPrototype indexed by name.",
        "short": "A dictionary containing every LuaModuleCategoryPrototype indexed by name.",
        "member": "module_category_prototypes  ::LuaCustomTable[string LuaModuleCategoryPrototype] Read"
      },
      "equipment_category_prototypes": {
        "name": "equipment_category_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaEquipmentCategoryPrototype indexed by name.",
        "short": "A dictionary containing every LuaEquipmentCategoryPrototype indexed by name.",
        "member": "equipment_category_prototypes  ::LuaCustomTable[string LuaEquipmentCategoryPrototype] Read"
      },
      "trivial_smoke_prototypes": {
        "name": "trivial_smoke_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaTrivialSmokePrototype indexed by name.",
        "short": "A dictionary containing every LuaTrivialSmokePrototype indexed by name.",
        "member": "trivial_smoke_prototypes  ::LuaCustomTable[string LuaTrivialSmokePrototype] Read"
      },
      "shortcut_prototypes": {
        "name": "shortcut_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaShortcutPrototype indexed by name.",
        "short": "A dictionary containing every LuaShortcutPrototype indexed by name.",
        "member": "shortcut_prototypes  ::LuaCustomTable[string LuaShortcutPrototype] Read"
      },
      "recipe_category_prototypes": {
        "name": "recipe_category_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaRecipeCategoryPrototype indexed by name.",
        "short": "A dictionary containing every LuaRecipeCategoryPrototype indexed by name.",
        "member": "recipe_category_prototypes  ::LuaCustomTable[string LuaRecipeCategoryPrototype] Read"
      },
      "font_prototypes": {
        "name": "font_prototypes",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every LuaFontPrototype indexed by name.",
        "short": "A dictionary containing every LuaFontPrototype indexed by name.",
        "member": "font_prototypes  ::LuaCustomTable[string LuaFontPrototype] Read"
      },
      "map_gen_presets": {
        "name": "map_gen_presets",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "A dictionary containing every MapGenPreset indexed by name.",
        "short": "A dictionary containing every MapGenPreset indexed by name.",
        "member": "map_gen_presets  ::LuaCustomTable[string MapGenPreset] Read"
      },
      "console_command_used": {
        "name": "console_command_used",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether a console command has been used.",
        "short": "Whether a console command has been used.",
        "member": "console_command_used  ::boolean Read"
      },
      "styles": {
        "name": "styles",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "The styles that LuaGuiElement can use, indexed by name.",
        "short": "The styles that LuaGuiElement can use, indexed by name.",
        "member": "styles  ::LuaCustomTable[string string] Read"
      },
      "tick": {
        "name": "tick",
        "type": "uint",
        "mode": "[R]",
        "doc": "Current map tick.",
        "short": "Current map tick.",
        "member": "tick  ::uint Read"
      },
      "ticks_played": {
        "name": "ticks_played",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of ticks since this game was created using either \"new game\" or \"new game from scenario\". Notably, this number progresses even when the game is tick_paused.",
        "short": "The number of ticks since this game was created using either \"new game\" or \"new game from scenario\". [...]",
        "member": "ticks_played  ::uint Read"
      },
      "tick_paused": {
        "name": "tick_paused",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If the tick has been paused. This means that entity update has been paused.",
        "short": "If the tick has been paused. [...]",
        "member": "tick_paused  ::boolean Read/Write"
      },
      "ticks_to_run": {
        "name": "ticks_to_run",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The number of ticks to be run while the tick is paused. When LuaGameScript::tick_paused is true, ticks_to_run behaves the following way: While this is > 0, the entity update is running normally and this value is decremented every tick. When this reaches 0, the game will pause again.",
        "short": "The number of ticks to be run while the tick is paused. [...]",
        "member": "ticks_to_run  ::uint Read/Write"
      },
      "finished": {
        "name": "finished",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True while the victory screen is shown.",
        "short": "True while the victory screen is shown.",
        "member": "finished  ::boolean Read"
      },
      "finished_but_continuing": {
        "name": "finished_but_continuing",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True after players finished the game and clicked \"continue\".",
        "short": "True after players finished the game and clicked \"continue\".",
        "member": "finished_but_continuing  ::boolean Read"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[RW]",
        "doc": "Speed to update the map at. 1.0 is normal speed -- 60 UPS.",
        "short": "Speed to update the map at. [...]",
        "member": "speed  ::float Read/Write"
      },
      "surfaces": {
        "name": "surfaces",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Get a table of all the surfaces that currently exist. This sparse table allows you to find surfaces by indexing it with either their name or index. Iterating this table with pairs() will only iterate the hash part of the table. Iterating with ipairs() will not work at all.",
        "short": "Get a table of all the surfaces that currently exist. [...]",
        "member": "surfaces  ::LuaCustomTable[uint or string LuaSurface] Read"
      },
      "active_mods": {
        "name": "active_mods",
        "type": "string",
        "mode": "[R]",
        "doc": "The active mods versions. The keys are mod names, the values are the versions.",
        "short": "The active mods versions. [...]",
        "member": "active_mods  ::dictionary[string string] Read"
      },
      "connected_players": {
        "name": "connected_players",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The players that are currently online.",
        "short": "The players that are currently online. [...]",
        "member": "connected_players  ::array[LuaPlayer] Read"
      },
      "permissions": {
        "name": "permissions",
        "type": "LuaPermissionGroups",
        "mode": "[R]",
        "member": "permissions  ::LuaPermissionGroups Read"
      },
      "backer_names": {
        "name": "backer_names",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Array of the names of all the backers that supported the game development early on. These are used as names for labs, locomotives, radars, roboports, and train stops.",
        "short": "Array of the names of all the backers that supported the game development early on. [...]",
        "member": "backer_names  ::LuaCustomTable[uint string] Read"
      },
      "default_map_gen_settings": {
        "name": "default_map_gen_settings",
        "type": "MapGenSettings",
        "mode": "[R]",
        "doc": "The default map gen settings for this save.",
        "short": "The default map gen settings for this save.",
        "member": "default_map_gen_settings  ::MapGenSettings Read"
      },
      "enemy_has_vision_on_land_mines": {
        "name": "enemy_has_vision_on_land_mines",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Determines if enemy land mines are completely invisible or not.",
        "short": "Determines if enemy land mines are completely invisible or not.",
        "member": "enemy_has_vision_on_land_mines  ::boolean Read/Write"
      },
      "autosave_enabled": {
        "name": "autosave_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "True by default. Can be used to disable autosaving. Make sure to turn it back on soon after.",
        "short": "True by default. [...]",
        "member": "autosave_enabled  ::boolean Read/Write"
      },
      "draw_resource_selection": {
        "name": "draw_resource_selection",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "True by default. Can be used to disable the highlighting of resource patches when they are hovered on the map.",
        "short": "True by default. [...]",
        "member": "draw_resource_selection  ::boolean Read/Write"
      },
      "pollution_statistics": {
        "name": "pollution_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[R]",
        "doc": "The pollution statistics for this map.",
        "short": "The pollution statistics for this map.",
        "member": "pollution_statistics  ::LuaFlowStatistics Read"
      },
      "max_force_distraction_distance": {
        "name": "max_force_distraction_distance",
        "type": "double",
        "mode": "[R]",
        "member": "max_force_distraction_distance  ::double Read"
      },
      "max_force_distraction_chunk_distance": {
        "name": "max_force_distraction_chunk_distance",
        "type": "uint",
        "mode": "[R]",
        "member": "max_force_distraction_chunk_distance  ::uint Read"
      },
      "max_electric_pole_supply_area_distance": {
        "name": "max_electric_pole_supply_area_distance",
        "type": "float",
        "mode": "[R]",
        "member": "max_electric_pole_supply_area_distance  ::float Read"
      },
      "max_electric_pole_connection_distance": {
        "name": "max_electric_pole_connection_distance",
        "type": "double",
        "mode": "[R]",
        "member": "max_electric_pole_connection_distance  ::double Read"
      },
      "max_beacon_supply_area_distance": {
        "name": "max_beacon_supply_area_distance",
        "type": "double",
        "mode": "[R]",
        "member": "max_beacon_supply_area_distance  ::double Read"
      },
      "max_gate_activation_distance": {
        "name": "max_gate_activation_distance",
        "type": "double",
        "mode": "[R]",
        "member": "max_gate_activation_distance  ::double Read"
      },
      "max_inserter_reach_distance": {
        "name": "max_inserter_reach_distance",
        "type": "double",
        "mode": "[R]",
        "member": "max_inserter_reach_distance  ::double Read"
      },
      "max_pipe_to_ground_distance": {
        "name": "max_pipe_to_ground_distance",
        "type": "uint8",
        "mode": "[R]",
        "member": "max_pipe_to_ground_distance  ::uint8 Read"
      },
      "max_underground_belt_distance": {
        "name": "max_underground_belt_distance",
        "type": "uint8",
        "mode": "[R]",
        "member": "max_underground_belt_distance  ::uint8 Read"
      }
    }
  },
  "LuaGenericOnOffControlBehavior": {
    "name": "LuaGenericOnOffControlBehavior",
    "type": "LuaGenericOnOffControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "disabled": {
        "name": "disabled",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the entity is currently disabled because of the control behavior.",
        "short": "If the entity is currently disabled because of the control behavior.",
        "member": "disabled  ::boolean Read"
      },
      "circuit_condition": {
        "name": "circuit_condition",
        "type": "CircuitConditionDefinition",
        "mode": "[RW]",
        "doc": "The circuit condition. Writing nil clears the circuit condition.",
        "short": "The circuit condition. [...]",
        "member": "circuit_condition  ::CircuitConditionDefinition Read/Write"
      },
      "logistic_condition": {
        "name": "logistic_condition",
        "type": "CircuitConditionDefinition",
        "mode": "[RW]",
        "doc": "The logistic condition. Writing nil clears the logistic condition.",
        "short": "The logistic condition. [...]",
        "member": "logistic_condition  ::CircuitConditionDefinition Read/Write"
      },
      "connect_to_logistic_network": {
        "name": "connect_to_logistic_network",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if this should connect to the logistic network.",
        "short": "true if this should connect to the logistic network.",
        "member": "connect_to_logistic_network  ::boolean Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaGroup": {
    "name": "LuaGroup",
    "type": "LuaGroup",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of the group.",
        "short": "Localised name of the group.",
        "member": "localised_name  ::LocalisedString Read"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "member": "type  ::string Read"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "The parent group.",
        "short": "The parent group.",
        "member": "group  ::LuaGroup Read"
      },
      "subgroups": {
        "name": "subgroups",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Subgroups of this group.",
        "short": "Subgroups of this group.",
        "member": "subgroups  ::array[LuaGroup] Read"
      },
      "order_in_recipe": {
        "name": "order_in_recipe",
        "type": "string",
        "mode": "[R]",
        "doc": "The additional order value used in recipe ordering.",
        "short": "The additional order value used in recipe ordering.",
        "member": "order_in_recipe  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaGui": {
    "name": "LuaGui",
    "type": "LuaGui",
    "inherits": [],
    "properties": {
      "is_valid_sprite_path": {
        "name": "is_valid_sprite_path",
        "type": "function",
        "doc": "Returns true if sprite_path is valid and contains loaded sprite, otherwise false. Sprite path of type file doesn't validate if file exists.",
        "short": "Returns true if sprite_path is valid and contains loaded sprite, otherwise false. [...]",
        "member": "is_valid_sprite_path(sprite_path)  boolean",
        "args": {
          "sprite_path": {
            "name": "sprite_path",
            "type": "SpritePath",
            "doc": "Path to a image."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The player who owns this gui.",
        "short": "The player who owns this gui.",
        "member": "player  ::LuaPlayer Read"
      },
      "children": {
        "name": "children",
        "type": "string",
        "mode": "[R]",
        "doc": "The children GUI elements mapped by name <> element.",
        "short": "The children GUI elements mapped by name <> element.",
        "member": "children  ::dictionary[string LuaGuiElement] Read"
      },
      "top": {
        "name": "top",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The top part of the GUI. It is a flow element inside a scroll pane element.",
        "short": "The top part of the GUI. [...]",
        "member": "top  ::LuaGuiElement Read"
      },
      "left": {
        "name": "left",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The left part of the GUI. It is a flow element inside a scroll pane element.",
        "short": "The left part of the GUI. [...]",
        "member": "left  ::LuaGuiElement Read"
      },
      "center": {
        "name": "center",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The center part of the GUI. It is a flow element.",
        "short": "The center part of the GUI. [...]",
        "member": "center  ::LuaGuiElement Read"
      },
      "goal": {
        "name": "goal",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The flow used in the objectives window. It is a flow element. The objectives window is only visible when the flow is not empty or the objective text is set.",
        "short": "The flow used in the objectives window. [...]",
        "member": "goal  ::LuaGuiElement Read"
      },
      "screen": {
        "name": "screen",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "For showing a GUI somewhere on the entire screen. It is an empty-widget element.",
        "short": "For showing a GUI somewhere on the entire screen. [...]",
        "member": "screen  ::LuaGuiElement Read"
      },
      "relative": {
        "name": "relative",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "For showing a GUI somewhere relative to one of the game GUIs. It is an empty-widget element.",
        "short": "For showing a GUI somewhere relative to one of the game GUIs. [...]",
        "member": "relative  ::LuaGuiElement Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaGuiElement": {
    "name": "LuaGuiElement",
    "type": "LuaGuiElement",
    "inherits": [],
    "properties": {
      "add": {
        "name": "add",
        "type": "LuaGuiElement",
        "doc": "Add a new child element to this GuiElement. Returns: The GUI element that was added.",
        "short": "Add a new child element to this GuiElement.",
        "member": "add{type=, name?=, caption?=, tooltip?=, elem_tooltip?=, enabled?=, visible?=, ignored_by_interaction?=, style?=, tags?=, index?=, anchor?=, game_controller_interaction?=, raise_hover_events?=}  LuaGuiElement",
        "returns": "LuaGuiElement",
        "args": {
          "type": {
            "name": "type",
            "type": "GuiElementType",
            "doc": "The kind of element to add, which potentially has its own attributes as listed below."
          },
          "name": {
            "name": "name",
            "type": "string?",
            "doc": "Name of the child element. It must be unique within the parent element."
          },
          "caption": {
            "name": "caption",
            "type": "LocalisedString?",
            "doc": "Text displayed on the child element. For frames, this is their title. For other elements, like buttons or labels, this is the content. Whilst this attribute may be used on all elements, it doesn't make sense for tables and flows as they won't display it."
          },
          "tooltip": {
            "name": "tooltip",
            "type": "LocalisedString?",
            "doc": "Tooltip of the child element."
          },
          "elem_tooltip": {
            "name": "elem_tooltip",
            "type": "ElemID?",
            "doc": "Elem tooltip of the child element. Will be displayed above tooltip."
          },
          "enabled": {
            "name": "enabled",
            "type": "boolean?",
            "doc": "Whether the child element is enabled. Defaults to true."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "Whether the child element is visible. Defaults to true."
          },
          "ignored_by_interaction": {
            "name": "ignored_by_interaction",
            "type": "boolean?",
            "doc": "Whether the child element is ignored by interaction. Defaults to false."
          },
          "style": {
            "name": "style",
            "type": "string?",
            "doc": "The name of the style prototype to apply to the new element."
          },
          "tags": {
            "name": "tags",
            "type": "Tags?",
            "doc": "Tags associated with the child element."
          },
          "index": {
            "name": "index",
            "type": "uint?",
            "doc": "Location in its parent that the child element should slot into. By default, the child will be appended onto the end."
          },
          "anchor": {
            "name": "anchor",
            "type": "GuiAnchor?",
            "doc": "Where to position the child element when in the relative element."
          },
          "game_controller_interaction": {
            "name": "game_controller_interaction",
            "type": "defines.game_controller_interaction?",
            "doc": "How the element should interact with game controllers. Defaults to defines.game_controller_interaction.normal."
          },
          "raise_hover_events": {
            "name": "raise_hover_events",
            "type": "boolean?",
            "doc": "Whether this element will raise on_gui_hover and on_gui_leave. Defaults to false."
          },
          "mouse_button_filter": {
            "name": "mouse_button_filter",
            "type": "MouseButtonFlags?",
            "doc": "The mouse buttons that the button responds to. Defaults to \"left-and-right\"."
          },
          "auto_toggle": {
            "name": "auto_toggle",
            "type": "boolean?",
            "doc": "Whether the button will automatically toggle when clicked. Defaults to false."
          },
          "toggled": {
            "name": "toggled",
            "type": "boolean?",
            "doc": "The initial toggled state of the button. Defaults to false."
          },
          "direction": {
            "name": "direction",
            "type": "GuiDirection?",
            "doc": "The initial direction of the line. Defaults to \"horizontal\"."
          },
          "column_count": {
            "name": "column_count",
            "type": "uint",
            "doc": "Number of columns. This can't be changed after the table is created."
          },
          "draw_vertical_lines": {
            "name": "draw_vertical_lines",
            "type": "boolean?",
            "doc": "Whether the table should draw vertical grid lines. Defaults to false."
          },
          "draw_horizontal_lines": {
            "name": "draw_horizontal_lines",
            "type": "boolean?",
            "doc": "Whether the table should draw horizontal grid lines. Defaults to false."
          },
          "draw_horizontal_line_after_headers": {
            "name": "draw_horizontal_line_after_headers",
            "type": "boolean?",
            "doc": "Whether the table should draw a single horizontal grid line after the headers. Defaults to false."
          },
          "vertical_centering": {
            "name": "vertical_centering",
            "type": "boolean?",
            "doc": "Whether the content of the table should be vertically centered. Defaults to true."
          },
          "text": {
            "name": "text",
            "type": "string?",
            "doc": "The initial text contained in the text-box."
          },
          "numeric": {
            "name": "numeric",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "allow_decimal": {
            "name": "allow_decimal",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "allow_negative": {
            "name": "allow_negative",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "is_password": {
            "name": "is_password",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "lose_focus_on_confirm": {
            "name": "lose_focus_on_confirm",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "clear_and_focus_on_right_click": {
            "name": "clear_and_focus_on_right_click",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "value": {
            "name": "value",
            "type": "double?",
            "doc": "The initial value for the slider. Defaults to minimum_value."
          },
          "state": {
            "name": "state",
            "type": "boolean",
            "doc": "The initial checked-state of the radiobutton."
          },
          "sprite": {
            "name": "sprite",
            "type": "SpritePath?",
            "doc": "Path to the image to display."
          },
          "hovered_sprite": {
            "name": "hovered_sprite",
            "type": "SpritePath?",
            "doc": "Path to the image to display on the button when it is hovered."
          },
          "clicked_sprite": {
            "name": "clicked_sprite",
            "type": "SpritePath?",
            "doc": "Path to the image to display on the button when it is clicked."
          },
          "number": {
            "name": "number",
            "type": "double?",
            "doc": "The number shown on the button."
          },
          "show_percent_for_small_numbers": {
            "name": "show_percent_for_small_numbers",
            "type": "boolean?",
            "doc": "Formats small numbers as percentages. Defaults to false."
          },
          "resize_to_sprite": {
            "name": "resize_to_sprite",
            "type": "boolean?",
            "doc": "Whether the widget should resize according to the sprite in it. Defaults to true."
          },
          "horizontal_scroll_policy": {
            "name": "horizontal_scroll_policy",
            "type": "ScrollPolicy?",
            "doc": "Policy of the horizontal scroll bar. Defaults to \"auto\"."
          },
          "vertical_scroll_policy": {
            "name": "vertical_scroll_policy",
            "type": "ScrollPolicy?",
            "doc": "Policy of the vertical scroll bar. Defaults to \"auto\"."
          },
          "items": {
            "name": "items",
            "type": "array[LocalisedString]?",
            "doc": "The initial items in the listbox."
          },
          "selected_index": {
            "name": "selected_index",
            "type": "uint?",
            "doc": "The index of the initially selected item. Defaults to 0."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "The position the minimap centers on. Defaults to the player's current position."
          },
          "surface_index": {
            "name": "surface_index",
            "type": "uint?",
            "doc": "The surface the camera will render. Defaults to the player's current surface."
          },
          "zoom": {
            "name": "zoom",
            "type": "double?",
            "doc": "The initial camera zoom. Defaults to 0.75."
          },
          "elem_type": {
            "name": "elem_type",
            "type": "ElemType",
            "doc": "The type of the button - one of the following values."
          },
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "If type is \"item\" - the default value for the button."
          },
          "tile": {
            "name": "tile",
            "type": "string?",
            "doc": "If type is \"tile\" - the default value for the button."
          },
          "entity": {
            "name": "entity",
            "type": "string?",
            "doc": "If type is \"entity\" - the default value for the button."
          },
          "signal": {
            "name": "signal",
            "type": "SignalID?",
            "doc": "If type is \"signal\" - the default value for the button."
          },
          "fluid": {
            "name": "fluid",
            "type": "string?",
            "doc": "If type is \"fluid\" - the default value for the button."
          },
          "recipe": {
            "name": "recipe",
            "type": "string?",
            "doc": "If type is \"recipe\" - the default value for the button."
          },
          "decorative": {
            "name": "decorative",
            "type": "string?",
            "doc": "If type is \"decorative\" - the default value for the button."
          },
          "item-group": {
            "name": "item-group",
            "type": "string?",
            "doc": "If type is \"item-group\" - the default value for the button."
          },
          "achievement": {
            "name": "achievement",
            "type": "string?",
            "doc": "If type is \"achievement\" - the default value for the button."
          },
          "equipment": {
            "name": "equipment",
            "type": "string?",
            "doc": "If type is \"equipment\" - the default value for the button."
          },
          "technology": {
            "name": "technology",
            "type": "string?",
            "doc": "If type is \"technology\" - the default value for the button."
          },
          "elem_filters": {
            "name": "elem_filters",
            "type": "PrototypeFilter?",
            "doc": "Filters describing what to show in the selection window. The applicable filter depends on the elem_type."
          },
          "minimum_value": {
            "name": "minimum_value",
            "type": "double?",
            "doc": "The minimum value for the slider. Defaults to 0."
          },
          "maximum_value": {
            "name": "maximum_value",
            "type": "double?",
            "doc": "The maximum value for the slider. Defaults to 30."
          },
          "value_step": {
            "name": "value_step",
            "type": "double?",
            "doc": "The minimum value the slider can move. Defaults to 1."
          },
          "discrete_slider": {
            "name": "discrete_slider",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "discrete_values": {
            "name": "discrete_values",
            "type": "boolean?",
            "doc": "Defaults to true."
          },
          "chart_player_index": {
            "name": "chart_player_index",
            "type": "uint?",
            "doc": "The player index the map should use. Defaults to the current player."
          },
          "force": {
            "name": "force",
            "type": "string?",
            "doc": "The force this minimap should use. Defaults to the player's current force."
          },
          "badge_text": {
            "name": "badge_text",
            "type": "LocalisedString?",
            "doc": "The text to display after the normal tab text (designed to work with numbers)."
          },
          "switch_state": {
            "name": "switch_state",
            "type": "SwitchState?",
            "doc": "If set to \"none\", allow_none_state must be true. Defaults to \"left\"."
          },
          "allow_none_state": {
            "name": "allow_none_state",
            "type": "boolean?",
            "doc": "Whether the switch can be set to a middle state. Defaults to false."
          },
          "left_label_caption": {
            "name": "left_label_caption",
            "type": "LocalisedString?",
            "doc": ""
          },
          "left_label_tooltip": {
            "name": "left_label_tooltip",
            "type": "LocalisedString?",
            "doc": ""
          },
          "right_label_caption": {
            "name": "right_label_caption",
            "type": "LocalisedString?",
            "doc": ""
          },
          "right_label_tooltip": {
            "name": "right_label_tooltip",
            "type": "LocalisedString?",
            "doc": ""
          }
        }
      },
      "clear": {
        "name": "clear",
        "doc": "Remove children of this element. Any LuaGuiElement objects referring to the destroyed elements become invalid after this operation.",
        "short": "Remove children of this element. [...]",
        "member": "clear()",
        "type": "function"
      },
      "destroy": {
        "name": "destroy",
        "doc": "Remove this element, along with its children. Any LuaGuiElement objects referring to the destroyed elements become invalid after this operation.",
        "short": "Remove this element, along with its children. [...]",
        "member": "destroy()",
        "type": "function"
      },
      "get_mod": {
        "name": "get_mod",
        "type": "function",
        "doc": "The mod that owns this Gui element or nil if it's owned by the scenario script.",
        "short": "The mod that owns this Gui element or nil if it's owned by the scenario script.",
        "member": "get_mod()  string?"
      },
      "get_index_in_parent": {
        "name": "get_index_in_parent",
        "type": "function",
        "doc": "Gets the index that this element has in its parent element.",
        "short": "Gets the index that this element has in its parent element.",
        "member": "get_index_in_parent()  uint"
      },
      "swap_children": {
        "name": "swap_children",
        "doc": "Swaps the children at the given indices in this element.",
        "short": "Swaps the children at the given indices in this element.",
        "member": "swap_children(index_1, index_2)",
        "type": "function",
        "args": {
          "index_1": {
            "name": "index_1",
            "type": "uint",
            "doc": "The index of the first child."
          },
          "index_2": {
            "name": "index_2",
            "type": "uint",
            "doc": "The index of the second child."
          }
        }
      },
      "clear_items": {
        "name": "clear_items",
        "doc": "Removes the items in this dropdown or listbox.",
        "short": "Removes the items in this dropdown or listbox.",
        "member": "clear_items()",
        "type": "function"
      },
      "get_item": {
        "name": "get_item",
        "type": "function",
        "doc": "Gets the item at the given index from this dropdown or listbox.",
        "short": "Gets the item at the given index from this dropdown or listbox.",
        "member": "get_item(index)  LocalisedString",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index to get"
          }
        }
      },
      "set_item": {
        "name": "set_item",
        "doc": "Sets the given string at the given index in this dropdown or listbox.",
        "short": "Sets the given string at the given index in this dropdown or listbox.",
        "member": "set_item(index, string)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index whose text to replace."
          },
          "string": {
            "name": "string",
            "type": "LocalisedString",
            "doc": "The text to set at the given index."
          }
        }
      },
      "add_item": {
        "name": "add_item",
        "doc": "Inserts a string at the end or at the given index of this dropdown or listbox.",
        "short": "Inserts a string at the end or at the given index of this dropdown or listbox.",
        "member": "add_item(string, index?)",
        "type": "function",
        "args": {
          "string": {
            "name": "string",
            "type": "LocalisedString",
            "doc": "The text to insert."
          },
          "index": {
            "name": "index",
            "type": "uint?",
            "doc": "The index at which to insert the item."
          }
        }
      },
      "remove_item": {
        "name": "remove_item",
        "doc": "Removes the item at the given index from this dropdown or listbox.",
        "short": "Removes the item at the given index from this dropdown or listbox.",
        "member": "remove_item(index)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index"
          }
        }
      },
      "get_slider_minimum": {
        "name": "get_slider_minimum",
        "type": "function",
        "doc": "Gets this sliders minimum value.",
        "short": "Gets this sliders minimum value.",
        "member": "get_slider_minimum()  double"
      },
      "get_slider_maximum": {
        "name": "get_slider_maximum",
        "type": "function",
        "doc": "Gets this sliders maximum value.",
        "short": "Gets this sliders maximum value.",
        "member": "get_slider_maximum()  double"
      },
      "set_slider_minimum_maximum": {
        "name": "set_slider_minimum_maximum",
        "doc": "Sets this sliders minimum and maximum values.",
        "short": "Sets this sliders minimum and maximum values.",
        "member": "set_slider_minimum_maximum(minimum, maximum)",
        "type": "function",
        "args": {
          "minimum": {
            "name": "minimum",
            "type": "double",
            "doc": ""
          },
          "maximum": {
            "name": "maximum",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_slider_value_step": {
        "name": "get_slider_value_step",
        "type": "function",
        "doc": "Gets the minimum distance this slider can move.",
        "short": "Gets the minimum distance this slider can move.",
        "member": "get_slider_value_step()  double"
      },
      "get_slider_discrete_slider": {
        "name": "get_slider_discrete_slider",
        "type": "function",
        "doc": "Returns whether this slider only allows being moved to discrete positions.",
        "short": "Returns whether this slider only allows being moved to discrete positions.",
        "member": "get_slider_discrete_slider()  boolean"
      },
      "get_slider_discrete_values": {
        "name": "get_slider_discrete_values",
        "type": "function",
        "doc": "Returns whether this slider only allows discrete values.",
        "short": "Returns whether this slider only allows discrete values.",
        "member": "get_slider_discrete_values()  boolean"
      },
      "set_slider_value_step": {
        "name": "set_slider_value_step",
        "doc": "Sets the minimum distance this slider can move.",
        "short": "Sets the minimum distance this slider can move.",
        "member": "set_slider_value_step(value)",
        "type": "function",
        "args": {
          "value": {
            "name": "value",
            "type": "double",
            "doc": ""
          }
        }
      },
      "set_slider_discrete_slider": {
        "name": "set_slider_discrete_slider",
        "doc": "Sets whether this slider only allows being moved to discrete positions.",
        "short": "Sets whether this slider only allows being moved to discrete positions.",
        "member": "set_slider_discrete_slider(value)",
        "type": "function",
        "args": {
          "value": {
            "name": "value",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "set_slider_discrete_values": {
        "name": "set_slider_discrete_values",
        "doc": "Sets whether this slider only allows discrete values.",
        "short": "Sets whether this slider only allows discrete values.",
        "member": "set_slider_discrete_values(value)",
        "type": "function",
        "args": {
          "value": {
            "name": "value",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "focus": {
        "name": "focus",
        "doc": "Focuses this GUI element if possible.",
        "short": "Focuses this GUI element if possible.",
        "member": "focus()",
        "type": "function"
      },
      "scroll_to_top": {
        "name": "scroll_to_top",
        "doc": "Scrolls this scroll bar to the top.",
        "short": "Scrolls this scroll bar to the top.",
        "member": "scroll_to_top()",
        "type": "function"
      },
      "scroll_to_bottom": {
        "name": "scroll_to_bottom",
        "doc": "Scrolls this scroll bar to the bottom.",
        "short": "Scrolls this scroll bar to the bottom.",
        "member": "scroll_to_bottom()",
        "type": "function"
      },
      "scroll_to_left": {
        "name": "scroll_to_left",
        "doc": "Scrolls this scroll bar to the left.",
        "short": "Scrolls this scroll bar to the left.",
        "member": "scroll_to_left()",
        "type": "function"
      },
      "scroll_to_right": {
        "name": "scroll_to_right",
        "doc": "Scrolls this scroll bar to the right.",
        "short": "Scrolls this scroll bar to the right.",
        "member": "scroll_to_right()",
        "type": "function"
      },
      "scroll_to_element": {
        "name": "scroll_to_element",
        "doc": "Scrolls this scroll bar such that the specified GUI element is visible to the player.",
        "short": "Scrolls this scroll bar such that the specified GUI element is visible to the player.",
        "member": "scroll_to_element(element, scroll_mode?)",
        "type": "function",
        "args": {
          "element": {
            "name": "element",
            "type": "LuaGuiElement",
            "doc": "The element to scroll to."
          },
          "scroll_mode": {
            "name": "scroll_mode",
            "type": "\"in-view\" or \"top-third\"?",
            "doc": "Where the element should be positioned in the scroll-pane. Defaults to \"in-view\"."
          }
        }
      },
      "select_all": {
        "name": "select_all",
        "doc": "Selects all the text in this textbox.",
        "short": "Selects all the text in this textbox.",
        "member": "select_all()",
        "type": "function"
      },
      "select": {
        "name": "select",
        "doc": "Selects a range of text in this textbox.",
        "short": "Selects a range of text in this textbox.",
        "member": "select(start_index, end_index)",
        "type": "function",
        "args": {
          "start_index": {
            "name": "start_index",
            "type": "int",
            "doc": "The index of the first character to select"
          },
          "end_index": {
            "name": "end_index",
            "type": "int",
            "doc": "The index of the last character to select"
          }
        }
      },
      "add_tab": {
        "name": "add_tab",
        "doc": "Adds the given tab and content widgets to this tabbed pane as a new tab.",
        "short": "Adds the given tab and content widgets to this tabbed pane as a new tab.",
        "member": "add_tab(tab, content)",
        "type": "function",
        "args": {
          "tab": {
            "name": "tab",
            "type": "LuaGuiElement",
            "doc": "The tab to add, must be a GUI element of type \"tab\"."
          },
          "content": {
            "name": "content",
            "type": "LuaGuiElement",
            "doc": "The content to show when this tab is selected. Can be any type of GUI element."
          }
        }
      },
      "remove_tab": {
        "name": "remove_tab",
        "doc": "Removes the given tab and its associated content from this tabbed pane.",
        "short": "Removes the given tab and its associated content from this tabbed pane.",
        "member": "remove_tab(tab)",
        "type": "function",
        "args": {
          "tab": {
            "name": "tab",
            "type": "LuaGuiElement",
            "doc": "The tab to remove. If not given, it removes all tabs."
          }
        }
      },
      "force_auto_center": {
        "name": "force_auto_center",
        "doc": "Forces this frame to re-auto-center. Only works on frames stored directly in LuaGui::screen.",
        "short": "Forces this frame to re-auto-center. [...]",
        "member": "force_auto_center()",
        "type": "function",
        "args": {
          "on_gui_location_changed": {
            "name": "on_gui_location_changed",
            "doc": ""
          }
        }
      },
      "scroll_to_item": {
        "name": "scroll_to_item",
        "doc": "Scrolls the scroll bar such that the specified listbox item is visible to the player.",
        "short": "Scrolls the scroll bar such that the specified listbox item is visible to the player.",
        "member": "scroll_to_item(index, scroll_mode?)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "int",
            "doc": "The item index to scroll to."
          },
          "scroll_mode": {
            "name": "scroll_mode",
            "type": "\"in-view\" or \"top-third\"?",
            "doc": "Where the item should be positioned in the list-box. Defaults to \"in-view\"."
          }
        }
      },
      "bring_to_front": {
        "name": "bring_to_front",
        "doc": "Moves this GUI element to the \"front\" so it will draw over other elements.",
        "short": "Moves this GUI element to the \"front\" so it will draw over other elements.",
        "member": "bring_to_front()",
        "type": "function"
      },
      "close_dropdown": {
        "name": "close_dropdown",
        "doc": "Closes the dropdown list if this is a dropdown and it is open.",
        "short": "Closes the dropdown list if this is a dropdown and it is open.",
        "member": "close_dropdown()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[R]",
        "doc": "The index of this GUI element (unique amongst the GUI elements of a LuaPlayer).",
        "short": "The index of this GUI element (unique amongst the GUI elements of a LuaPlayer).",
        "member": "index  ::uint Read"
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[R]",
        "doc": "The GUI this element is a child of.",
        "short": "The GUI this element is a child of.",
        "member": "gui  ::LuaGui Read"
      },
      "parent": {
        "name": "parent",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The direct parent of this element. nil if this is a top-level element.",
        "short": "The direct parent of this element. [...]",
        "member": "parent  ::LuaGuiElement? Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[RW]",
        "doc": "The name of this element. \"\" if no name was set.",
        "short": "The name of this element. [...]",
        "member": "name  ::string Read/Write"
      },
      "caption": {
        "name": "caption",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The text displayed on this element. For frames, this is the \"heading\". For other elements, like buttons or labels, this is the content.",
        "short": "The text displayed on this element. [...]",
        "member": "caption  ::LocalisedString Read/Write"
      },
      "value": {
        "name": "value",
        "type": "double",
        "mode": "[RW]",
        "doc": "How much this progress bar is filled. It is a value in the range [0, 1].",
        "short": "How much this progress bar is filled. [...]",
        "member": "value  ::double Read/Write"
      },
      "direction": {
        "name": "direction",
        "type": "GuiDirection",
        "mode": "[R]",
        "doc": "Direction of this element's layout.",
        "short": "Direction of this element's layout.",
        "member": "direction  ::GuiDirection Read"
      },
      "style": {
        "name": "style",
        "type": "LuaStyle",
        "mode": "[RW]",
        "doc": "The style of this element. When read, this evaluates to a LuaStyle. For writing, it only accepts a string that specifies the textual identifier (prototype name) of the desired style.",
        "short": "The style of this element. [...]",
        "member": "style  ::LuaStyle or string Read/Write"
      },
      "visible": {
        "name": "visible",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Sets whether this GUI element is visible or completely hidden, taking no space in the layout.",
        "short": "Sets whether this GUI element is visible or completely hidden, taking no space in the layout.",
        "member": "visible  ::boolean Read/Write"
      },
      "text": {
        "name": "text",
        "type": "string",
        "mode": "[RW]",
        "doc": "The text contained in this textfield or text-box.",
        "short": "The text contained in this textfield or text-box.",
        "member": "text  ::string Read/Write"
      },
      "children_names": {
        "name": "children_names",
        "type": "string",
        "mode": "[R]",
        "doc": "Names of all the children of this element. These are the identifiers that can be used to access the child as an attribute of this element.",
        "short": "Names of all the children of this element. [...]",
        "member": "children_names  ::array[string] Read"
      },
      "state": {
        "name": "state",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Is this checkbox or radiobutton checked?",
        "short": "Is this checkbox or radiobutton checked?",
        "member": "state  ::boolean Read/Write"
      },
      "player_index": {
        "name": "player_index",
        "type": "uint",
        "mode": "[R]",
        "doc": "Index into LuaGameScript::players specifying the player who owns this element.",
        "short": "Index into LuaGameScript::players specifying the player who owns this element.",
        "member": "player_index  ::uint Read"
      },
      "sprite": {
        "name": "sprite",
        "type": "SpritePath",
        "mode": "[RW]",
        "doc": "The sprite to display on this sprite-button or sprite in the default state.",
        "short": "The sprite to display on this sprite-button or sprite in the default state.",
        "member": "sprite  ::SpritePath Read/Write"
      },
      "resize_to_sprite": {
        "name": "resize_to_sprite",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the sprite widget should resize according to the sprite in it. Defaults to true.",
        "short": "Whether the sprite widget should resize according to the sprite in it. [...]",
        "member": "resize_to_sprite  ::boolean Read/Write"
      },
      "hovered_sprite": {
        "name": "hovered_sprite",
        "type": "SpritePath",
        "mode": "[RW]",
        "doc": "The sprite to display on this sprite-button when it is hovered.",
        "short": "The sprite to display on this sprite-button when it is hovered.",
        "member": "hovered_sprite  ::SpritePath Read/Write"
      },
      "clicked_sprite": {
        "name": "clicked_sprite",
        "type": "SpritePath",
        "mode": "[RW]",
        "doc": "The sprite to display on this sprite-button when it is clicked.",
        "short": "The sprite to display on this sprite-button when it is clicked.",
        "member": "clicked_sprite  ::SpritePath Read/Write"
      },
      "tooltip": {
        "name": "tooltip",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The text to display when hovering over this element. Writing \"\" will disable the tooltip, while writing nil will set it to \"nil\".",
        "short": "The text to display when hovering over this element. [...]",
        "member": "tooltip  ::LocalisedString Read/Write"
      },
      "elem_tooltip": {
        "name": "elem_tooltip",
        "type": "ElemID",
        "mode": "[RW]",
        "doc": "The element tooltip to display when hovering over this element, or nil.",
        "short": "The element tooltip to display when hovering over this element, or nil.",
        "member": "elem_tooltip  ::ElemID? Read/Write"
      },
      "horizontal_scroll_policy": {
        "name": "horizontal_scroll_policy",
        "type": "ScrollPolicy",
        "mode": "[RW]",
        "doc": "Policy of the horizontal scroll bar.",
        "short": "Policy of the horizontal scroll bar.",
        "member": "horizontal_scroll_policy  ::ScrollPolicy Read/Write"
      },
      "vertical_scroll_policy": {
        "name": "vertical_scroll_policy",
        "type": "ScrollPolicy",
        "mode": "[RW]",
        "doc": "Policy of the vertical scroll bar.",
        "short": "Policy of the vertical scroll bar.",
        "member": "vertical_scroll_policy  ::ScrollPolicy Read/Write"
      },
      "type": {
        "name": "type",
        "type": "GuiElementType",
        "mode": "[R]",
        "doc": "The type of this GUI element.",
        "short": "The type of this GUI element.",
        "member": "type  ::GuiElementType Read"
      },
      "children": {
        "name": "children",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The child-elements of this GUI element.",
        "short": "The child-elements of this GUI element.",
        "member": "children  ::array[LuaGuiElement] Read"
      },
      "items": {
        "name": "items",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The items in this dropdown or listbox.",
        "short": "The items in this dropdown or listbox.",
        "member": "items  ::array[LocalisedString] Read/Write"
      },
      "selected_index": {
        "name": "selected_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The selected index for this dropdown or listbox. Returns 0 if none is selected.",
        "short": "The selected index for this dropdown or listbox. [...]",
        "member": "selected_index  ::uint Read/Write"
      },
      "number": {
        "name": "number",
        "type": "double",
        "mode": "[RW]",
        "doc": "The number to be shown in the bottom right corner of this sprite-button. Set this to nil to show nothing.",
        "short": "The number to be shown in the bottom right corner of this sprite-button. [...]",
        "member": "number  ::double Read/Write"
      },
      "show_percent_for_small_numbers": {
        "name": "show_percent_for_small_numbers",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Related to the number to be shown in the bottom right corner of this sprite-button. When set to true, numbers that are non-zero and smaller than one are shown as a percentage rather than the value. For example, 0.5 will be shown as 50% instead.",
        "short": "Related to the number to be shown in the bottom right corner of this sprite-button. [...]",
        "member": "show_percent_for_small_numbers  ::boolean Read/Write"
      },
      "location": {
        "name": "location",
        "type": "GuiLocation",
        "mode": "[RW]",
        "doc": "The location of this widget when stored in LuaGui::screen. nil if not set or not in LuaGui::screen.",
        "short": "The location of this widget when stored in LuaGui::screen. [...]",
        "member": "location  ::GuiLocation? Read/Write"
      },
      "auto_center": {
        "name": "auto_center",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this frame auto-centers on window resize when stored in LuaGui::screen.",
        "short": "Whether this frame auto-centers on window resize when stored in LuaGui::screen.",
        "member": "auto_center  ::boolean Read/Write"
      },
      "badge_text": {
        "name": "badge_text",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The text to display after the normal tab text (designed to work with numbers)",
        "short": "The text to display after the normal tab text (designed to work with numbers)",
        "member": "badge_text  ::LocalisedString Read/Write"
      },
      "auto_toggle": {
        "name": "auto_toggle",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this button will automatically toggle when clicked.",
        "short": "Whether this button will automatically toggle when clicked.",
        "member": "auto_toggle  ::boolean Read/Write"
      },
      "toggled": {
        "name": "toggled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this button is currently toggled. When a button is toggled, it will use the selected_graphical_set and selected_font_color defined in its style.",
        "short": "Whether this button is currently toggled. [...]",
        "member": "toggled  ::boolean Read/Write"
      },
      "game_controller_interaction": {
        "name": "game_controller_interaction",
        "type": "defines.game_controller_interaction",
        "mode": "[RW]",
        "doc": "How this element should interact with game controllers.",
        "short": "How this element should interact with game controllers.",
        "member": "game_controller_interaction  ::defines.game_controller_interaction Read/Write"
      },
      "position": {
        "name": "position",
        "type": "MapPosition",
        "mode": "[RW]",
        "doc": "The position this camera or minimap is focused on, if any.",
        "short": "The position this camera or minimap is focused on, if any.",
        "member": "position  ::MapPosition Read/Write"
      },
      "surface_index": {
        "name": "surface_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The surface index this camera or minimap is using.",
        "short": "The surface index this camera or minimap is using.",
        "member": "surface_index  ::uint Read/Write"
      },
      "zoom": {
        "name": "zoom",
        "type": "double",
        "mode": "[RW]",
        "doc": "The zoom this camera or minimap is using. This value must be positive.",
        "short": "The zoom this camera or minimap is using. [...]",
        "member": "zoom  ::double Read/Write"
      },
      "minimap_player_index": {
        "name": "minimap_player_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The player index this minimap is using.",
        "short": "The player index this minimap is using.",
        "member": "minimap_player_index  ::uint Read/Write"
      },
      "force": {
        "name": "force",
        "type": "string",
        "mode": "[RW]",
        "doc": "The force this minimap is using, if any.",
        "short": "The force this minimap is using, if any.",
        "member": "force  ::string? Read/Write"
      },
      "elem_type": {
        "name": "elem_type",
        "type": "ElemType",
        "mode": "[R]",
        "doc": "The elem type of this choose-elem-button.",
        "short": "The elem type of this choose-elem-button.",
        "member": "elem_type  ::ElemType Read"
      },
      "elem_value": {
        "name": "elem_value",
        "type": "string",
        "mode": "[RW]",
        "doc": "The elem value of this choose-elem-button, if any.",
        "short": "The elem value of this choose-elem-button, if any.",
        "member": "elem_value  ::string or SignalID? Read/Write"
      },
      "elem_filters": {
        "name": "elem_filters",
        "type": "PrototypeFilter",
        "mode": "[RW]",
        "doc": "The elem filters of this choose-elem-button, if any. The compatible type of filter is determined by elem_type.",
        "short": "The elem filters of this choose-elem-button, if any. [...]",
        "member": "elem_filters  ::PrototypeFilter? Read/Write"
      },
      "selectable": {
        "name": "selectable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the contents of this text-box are selectable. Defaults to true.",
        "short": "Whether the contents of this text-box are selectable. [...]",
        "member": "selectable  ::boolean Read/Write"
      },
      "word_wrap": {
        "name": "word_wrap",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this text-box will word-wrap automatically. Defaults to false.",
        "short": "Whether this text-box will word-wrap automatically. [...]",
        "member": "word_wrap  ::boolean Read/Write"
      },
      "read_only": {
        "name": "read_only",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this text-box is read-only. Defaults to false.",
        "short": "Whether this text-box is read-only. [...]",
        "member": "read_only  ::boolean Read/Write"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this GUI element is enabled. Disabled GUI elements don't trigger events when clicked.",
        "short": "Whether this GUI element is enabled. [...]",
        "member": "enabled  ::boolean Read/Write"
      },
      "ignored_by_interaction": {
        "name": "ignored_by_interaction",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this GUI element is ignored by interaction. This makes clicks on this element 'go through' to the GUI element or even the game surface below it.",
        "short": "Whether this GUI element is ignored by interaction. [...]",
        "member": "ignored_by_interaction  ::boolean Read/Write"
      },
      "locked": {
        "name": "locked",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this choose-elem-button can be changed by the player.",
        "short": "Whether this choose-elem-button can be changed by the player.",
        "member": "locked  ::boolean Read/Write"
      },
      "draw_vertical_lines": {
        "name": "draw_vertical_lines",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this table should draw vertical grid lines.",
        "short": "Whether this table should draw vertical grid lines.",
        "member": "draw_vertical_lines  ::boolean Read/Write"
      },
      "draw_horizontal_lines": {
        "name": "draw_horizontal_lines",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this table should draw horizontal grid lines.",
        "short": "Whether this table should draw horizontal grid lines.",
        "member": "draw_horizontal_lines  ::boolean Read/Write"
      },
      "draw_horizontal_line_after_headers": {
        "name": "draw_horizontal_line_after_headers",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this table should draw a horizontal grid line below the first table row.",
        "short": "Whether this table should draw a horizontal grid line below the first table row.",
        "member": "draw_horizontal_line_after_headers  ::boolean Read/Write"
      },
      "column_count": {
        "name": "column_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of columns in this table.",
        "short": "The number of columns in this table.",
        "member": "column_count  ::uint Read"
      },
      "vertical_centering": {
        "name": "vertical_centering",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the content of this table should be vertically centered. Overrides LuaStyle::column_alignments. Defaults to true.",
        "short": "Whether the content of this table should be vertically centered. [...]",
        "member": "vertical_centering  ::boolean Read/Write"
      },
      "slider_value": {
        "name": "slider_value",
        "type": "double",
        "mode": "[RW]",
        "doc": "The value of this slider element.",
        "short": "The value of this slider element.",
        "member": "slider_value  ::double Read/Write"
      },
      "mouse_button_filter": {
        "name": "mouse_button_filter",
        "type": "MouseButtonFlags",
        "mode": "[RW]",
        "doc": "The mouse button filters for this button or sprite-button.",
        "short": "The mouse button filters for this button or sprite-button.",
        "member": "mouse_button_filter  ::MouseButtonFlags Read/Write"
      },
      "numeric": {
        "name": "numeric",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this textfield is limited to only numberic characters.",
        "short": "Whether this textfield is limited to only numberic characters.",
        "member": "numeric  ::boolean Read/Write"
      },
      "allow_decimal": {
        "name": "allow_decimal",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this textfield (when in numeric mode) allows decimal numbers.",
        "short": "Whether this textfield (when in numeric mode) allows decimal numbers.",
        "member": "allow_decimal  ::boolean Read/Write"
      },
      "allow_negative": {
        "name": "allow_negative",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this textfield (when in numeric mode) allows negative numbers.",
        "short": "Whether this textfield (when in numeric mode) allows negative numbers.",
        "member": "allow_negative  ::boolean Read/Write"
      },
      "is_password": {
        "name": "is_password",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this textfield displays as a password field, which renders all characters as *.",
        "short": "Whether this textfield displays as a password field, which renders all characters as *.",
        "member": "is_password  ::boolean Read/Write"
      },
      "lose_focus_on_confirm": {
        "name": "lose_focus_on_confirm",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this textfield loses focus after defines.events.on_gui_confirmed is fired.",
        "short": "Whether this textfield loses focus after defines.events.on_gui_confirmed is fired.",
        "member": "lose_focus_on_confirm  ::boolean Read/Write"
      },
      "clear_and_focus_on_right_click": {
        "name": "clear_and_focus_on_right_click",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Makes it so right-clicking on this textfield clears and focuses it.",
        "short": "Makes it so right-clicking on this textfield clears and focuses it.",
        "member": "clear_and_focus_on_right_click  ::boolean Read/Write"
      },
      "drag_target": {
        "name": "drag_target",
        "type": "LuaGuiElement",
        "mode": "[RW]",
        "doc": "The frame that is being moved when dragging this GUI element, if any. This element needs to be a child of the drag_target at some level.",
        "short": "The frame that is being moved when dragging this GUI element, if any. [...]",
        "member": "drag_target  ::LuaGuiElement? Read/Write"
      },
      "selected_tab_index": {
        "name": "selected_tab_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The selected tab index for this tabbed pane, if any.",
        "short": "The selected tab index for this tabbed pane, if any.",
        "member": "selected_tab_index  ::uint? Read/Write"
      },
      "tabs": {
        "name": "tabs",
        "type": "TabAndContent",
        "mode": "[R]",
        "doc": "The tabs and contents being shown in this tabbed-pane.",
        "short": "The tabs and contents being shown in this tabbed-pane.",
        "member": "tabs  ::array[TabAndContent] Read"
      },
      "entity": {
        "name": "entity",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The entity associated with this entity-preview, camera, minimap, if any.",
        "short": "The entity associated with this entity-preview, camera, minimap, if any.",
        "member": "entity  ::LuaEntity? Read/Write"
      },
      "anchor": {
        "name": "anchor",
        "type": "GuiAnchor",
        "mode": "[RW]",
        "doc": "The anchor for this relative widget, if any. Setting nil clears the anchor.",
        "short": "The anchor for this relative widget, if any. [...]",
        "member": "anchor  ::GuiAnchor? Read/Write"
      },
      "tags": {
        "name": "tags",
        "type": "Tags",
        "mode": "[RW]",
        "doc": "The tags associated with this LuaGuiElement.",
        "short": "The tags associated with this LuaGuiElement.",
        "member": "tags  ::Tags Read/Write"
      },
      "raise_hover_events": {
        "name": "raise_hover_events",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether this element will raise on_gui_hover and on_gui_leave.",
        "short": "Whether this element will raise on_gui_hover and on_gui_leave.",
        "member": "raise_hover_events  ::boolean Read/Write"
      },
      "switch_state": {
        "name": "switch_state",
        "type": "SwitchState",
        "mode": "[RW]",
        "doc": "The switch state for this switch.",
        "short": "The switch state for this switch.",
        "member": "switch_state  ::SwitchState Read/Write"
      },
      "allow_none_state": {
        "name": "allow_none_state",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the \"none\" state is allowed for this switch.",
        "short": "Whether the \"none\" state is allowed for this switch.",
        "member": "allow_none_state  ::boolean Read/Write"
      },
      "left_label_caption": {
        "name": "left_label_caption",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The text shown for the left switch label.",
        "short": "The text shown for the left switch label.",
        "member": "left_label_caption  ::LocalisedString Read/Write"
      },
      "left_label_tooltip": {
        "name": "left_label_tooltip",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The tooltip shown on the left switch label.",
        "short": "The tooltip shown on the left switch label.",
        "member": "left_label_tooltip  ::LocalisedString Read/Write"
      },
      "right_label_caption": {
        "name": "right_label_caption",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The text shown for the right switch label.",
        "short": "The text shown for the right switch label.",
        "member": "right_label_caption  ::LocalisedString Read/Write"
      },
      "right_label_tooltip": {
        "name": "right_label_tooltip",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The tooltip shown on the right switch label.",
        "short": "The tooltip shown on the right switch label.",
        "member": "right_label_tooltip  ::LocalisedString Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "[] (index)": {
        "name": "[] (index)",
        "type": "LuaGuiElement",
        "mode": "[R]",
        "doc": "The indexing operator. [...]"
      }
    }
  },
  "LuaHeatBufferPrototype": {
    "name": "LuaHeatBufferPrototype",
    "type": "LuaHeatBufferPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "max_temperature": {
        "name": "max_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "max_temperature  ::double Read"
      },
      "default_temperature": {
        "name": "default_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "default_temperature  ::double Read"
      },
      "specific_heat": {
        "name": "specific_heat",
        "type": "double",
        "mode": "[R]",
        "member": "specific_heat  ::double Read"
      },
      "max_transfer": {
        "name": "max_transfer",
        "type": "double",
        "mode": "[R]",
        "member": "max_transfer  ::double Read"
      },
      "min_temperature_gradient": {
        "name": "min_temperature_gradient",
        "type": "double",
        "mode": "[R]",
        "member": "min_temperature_gradient  ::double Read"
      },
      "min_working_temperature": {
        "name": "min_working_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "min_working_temperature  ::double Read"
      },
      "minimum_glow_temperature": {
        "name": "minimum_glow_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "minimum_glow_temperature  ::double Read"
      },
      "connections": {
        "name": "connections",
        "type": "HeatConnection",
        "mode": "[R]",
        "member": "connections  ::array[HeatConnection] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaHeatEnergySourcePrototype": {
    "name": "LuaHeatEnergySourcePrototype",
    "type": "LuaHeatEnergySourcePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions of this energy source in pollution/Joule. Multiplying it by energy consumption in Watt gives pollution/second.",
        "short": "The emissions of this energy source in pollution/Joule. [...]",
        "member": "emissions  ::double Read"
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_network_icon  ::boolean Read"
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_power_icon  ::boolean Read"
      },
      "max_temperature": {
        "name": "max_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "max_temperature  ::double Read"
      },
      "default_temperature": {
        "name": "default_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "default_temperature  ::double Read"
      },
      "specific_heat": {
        "name": "specific_heat",
        "type": "double",
        "mode": "[R]",
        "member": "specific_heat  ::double Read"
      },
      "max_transfer": {
        "name": "max_transfer",
        "type": "double",
        "mode": "[R]",
        "member": "max_transfer  ::double Read"
      },
      "min_temperature_gradient": {
        "name": "min_temperature_gradient",
        "type": "double",
        "mode": "[R]",
        "member": "min_temperature_gradient  ::double Read"
      },
      "min_working_temperature": {
        "name": "min_working_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "min_working_temperature  ::double Read"
      },
      "minimum_glow_temperature": {
        "name": "minimum_glow_temperature",
        "type": "double",
        "mode": "[R]",
        "member": "minimum_glow_temperature  ::double Read"
      },
      "connections": {
        "name": "connections",
        "type": "HeatConnection",
        "mode": "[R]",
        "member": "connections  ::array[HeatConnection] Read"
      },
      "heat_buffer_prototype": {
        "name": "heat_buffer_prototype",
        "type": "LuaHeatBufferPrototype",
        "mode": "[R]",
        "member": "heat_buffer_prototype  ::LuaHeatBufferPrototype Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaInserterControlBehavior": {
    "name": "LuaInserterControlBehavior",
    "type": "LuaInserterControlBehavior",
    "inherits": [
      "Inherited from LuaGenericOnOffControlBehavior: disabled, circuit_condition, logistic_condition, connect_to_logistic_network, valid, object_name, help",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "circuit_read_hand_contents": {
        "name": "circuit_read_hand_contents",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the contents of the inserter hand should be sent to the circuit network",
        "short": "true if the contents of the inserter hand should be sent to the circuit network",
        "member": "circuit_read_hand_contents  ::boolean Read/Write"
      },
      "circuit_mode_of_operation": {
        "name": "circuit_mode_of_operation",
        "type": "defines.control_behavior.inserter.circuit_mode_of_operation",
        "mode": "[RW]",
        "doc": "The circuit mode of operations for the inserter.",
        "short": "The circuit mode of operations for the inserter.",
        "member": "circuit_mode_of_operation  ::defines.control_behavior.inserter.circuit_mode_of_operation Read/Write"
      },
      "circuit_hand_read_mode": {
        "name": "circuit_hand_read_mode",
        "type": "defines.control_behavior.inserter.hand_read_mode",
        "mode": "[RW]",
        "doc": "The hand read mode for the inserter.",
        "short": "The hand read mode for the inserter.",
        "member": "circuit_hand_read_mode  ::defines.control_behavior.inserter.hand_read_mode Read/Write"
      },
      "circuit_set_stack_size": {
        "name": "circuit_set_stack_size",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If the stack size of the inserter is set through the circuit network or not.",
        "short": "If the stack size of the inserter is set through the circuit network or not.",
        "member": "circuit_set_stack_size  ::boolean Read/Write"
      },
      "circuit_stack_control_signal": {
        "name": "circuit_stack_control_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "doc": "The signal used to set the stack size of the inserter.",
        "short": "The signal used to set the stack size of the inserter.",
        "member": "circuit_stack_control_signal  ::SignalID Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaInventory": {
    "name": "LuaInventory",
    "type": "LuaInventory",
    "inherits": [],
    "properties": {
      "clear": {
        "name": "clear",
        "doc": "Make this inventory empty.",
        "short": "Make this inventory empty.",
        "member": "clear()",
        "type": "function"
      },
      "can_insert": {
        "name": "can_insert",
        "type": "function",
        "doc": "Can at least some items be inserted? Returns: true if at least a part of the given items could be inserted into this inventory.",
        "short": "Can at least some items be inserted?",
        "member": "can_insert(items)  boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items that would be inserted."
          }
        }
      },
      "insert": {
        "name": "insert",
        "type": "function",
        "doc": "Insert items into this inventory. Returns: Number of items actually inserted.",
        "short": "Insert items into this inventory.",
        "member": "insert(items)  uint",
        "returns": "uint",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items to insert."
          }
        }
      },
      "remove": {
        "name": "remove",
        "type": "function",
        "doc": "Remove items from this inventory. Returns: Number of items actually removed.",
        "short": "Remove items from this inventory.",
        "member": "remove(items)  uint",
        "returns": "uint",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items to remove."
          }
        }
      },
      "get_item_count": {
        "name": "get_item_count",
        "type": "function",
        "doc": "Get the number of all or some items in this inventory.",
        "short": "Get the number of all or some items in this inventory.",
        "member": "get_item_count(item?)  uint",
        "args": {
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "Prototype name of the item to count. If not specified, count all items."
          }
        }
      },
      "is_empty": {
        "name": "is_empty",
        "type": "function",
        "doc": "Does this inventory contain nothing?",
        "short": "Does this inventory contain nothing?",
        "member": "is_empty()  boolean"
      },
      "is_full": {
        "name": "is_full",
        "type": "function",
        "doc": "Is every stack in this inventory full? Ignores stacks blocked by the current bar.",
        "short": "Is every stack in this inventory full? [...]",
        "member": "is_full()  boolean"
      },
      "get_contents": {
        "name": "get_contents",
        "type": "function",
        "doc": "Get counts of all items in this inventory. Returns: The counts, indexed by item names.",
        "short": "Get counts of all items in this inventory.",
        "member": "get_contents()  dictionary[string uint]",
        "returns": "dictionary[string uint]"
      },
      "supports_bar": {
        "name": "supports_bar",
        "type": "function",
        "doc": "Does this inventory support a bar? Bar is the draggable red thing, found for example on chests, that limits the portion of the inventory that may be manipulated by machines.",
        "short": "Does this inventory support a bar? [...]",
        "member": "supports_bar()  boolean"
      },
      "get_bar": {
        "name": "get_bar",
        "type": "function",
        "doc": "Get the current bar. This is the index at which the red area starts.",
        "short": "Get the current bar. [...]",
        "member": "get_bar()  uint"
      },
      "set_bar": {
        "name": "set_bar",
        "doc": "Set the current bar.",
        "short": "Set the current bar.",
        "member": "set_bar(bar?)",
        "type": "function",
        "args": {
          "bar": {
            "name": "bar",
            "type": "uint?",
            "doc": "The new limit. Omitting this parameter will clear the limit."
          }
        }
      },
      "supports_filters": {
        "name": "supports_filters",
        "type": "function",
        "doc": "If this inventory supports filters.",
        "short": "If this inventory supports filters.",
        "member": "supports_filters()  boolean"
      },
      "is_filtered": {
        "name": "is_filtered",
        "type": "function",
        "doc": "If this inventory supports filters and has at least 1 filter set.",
        "short": "If this inventory supports filters and has at least 1 filter set.",
        "member": "is_filtered()  boolean"
      },
      "can_set_filter": {
        "name": "can_set_filter",
        "type": "function",
        "doc": "If the given inventory slot filter can be set to the given filter.",
        "short": "If the given inventory slot filter can be set to the given filter.",
        "member": "can_set_filter(index, filter)  boolean",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The item stack index"
          },
          "filter": {
            "name": "filter",
            "type": "string",
            "doc": "The item name of the filter"
          }
        }
      },
      "get_filter": {
        "name": "get_filter",
        "type": "function",
        "doc": "Gets the filter for the given item stack index. Returns: The current filter or nil if none.",
        "short": "Gets the filter for the given item stack index.",
        "member": "get_filter(index)  string?",
        "returns": "string?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The item stack index"
          }
        }
      },
      "set_filter": {
        "name": "set_filter",
        "type": "function",
        "doc": "Sets the filter for the given item stack index. Returns: If the filter was allowed to be set.",
        "short": "Sets the filter for the given item stack index.",
        "member": "set_filter(index, filter)  boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The item stack index."
          },
          "filter": {
            "name": "filter",
            "type": "string or nil",
            "doc": "The new filter. nil erases any existing filter."
          }
        }
      },
      "find_item_stack": {
        "name": "find_item_stack",
        "type": "function",
        "doc": "Finds the first LuaItemStack in the inventory that matches the given item name. Returns: The stack index of the matching stack, if any is found.",
        "short": "Finds the first LuaItemStack in the inventory that matches the given item name.",
        "member": "find_item_stack(item)  LuaItemStack?, uint?",
        "returns": "uint?",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "The item name to find"
          }
        }
      },
      "find_empty_stack": {
        "name": "find_empty_stack",
        "type": "function",
        "doc": "Finds the first empty stack. Filtered slots are excluded unless a filter item is given. Returns: The stack index of the matching stack, if any is found.",
        "short": "Finds the first empty stack. [...]",
        "member": "find_empty_stack(item?)  LuaItemStack?, uint?",
        "returns": "uint?",
        "args": {
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "If given, empty stacks that are filtered for this item will be included."
          }
        }
      },
      "count_empty_stacks": {
        "name": "count_empty_stacks",
        "type": "function",
        "doc": "Counts the number of empty stacks.",
        "short": "Counts the number of empty stacks.",
        "member": "count_empty_stacks(include_filtered?, include_bar?)  uint",
        "args": {
          "include_filtered": {
            "name": "include_filtered",
            "type": "boolean?",
            "doc": "If true, filtered slots will be included. Defaults to false."
          },
          "include_bar": {
            "name": "include_bar",
            "type": "boolean?",
            "doc": "If true, slots blocked by the current bar will be included. Defaults to true."
          }
        }
      },
      "get_insertable_count": {
        "name": "get_insertable_count",
        "type": "function",
        "doc": "Gets the number of the given item that can be inserted into this inventory.",
        "short": "Gets the number of the given item that can be inserted into this inventory.",
        "member": "get_insertable_count(item)  uint",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "The item to check."
          }
        }
      },
      "sort_and_merge": {
        "name": "sort_and_merge",
        "doc": "Sorts and merges the items in this inventory.",
        "short": "Sorts and merges the items in this inventory.",
        "member": "sort_and_merge()",
        "type": "function"
      },
      "resize": {
        "name": "resize",
        "doc": "Resizes the inventory.",
        "short": "Resizes the inventory.",
        "member": "resize(size)",
        "type": "function",
        "args": {
          "size": {
            "name": "size",
            "type": "uint16",
            "doc": "New size of a inventory"
          },
          "on_pre_script_inventory_resized": {
            "name": "on_pre_script_inventory_resized",
            "doc": ""
          },
          "on_script_inventory_resized": {
            "name": "on_script_inventory_resized",
            "doc": ""
          }
        }
      },
      "destroy": {
        "name": "destroy",
        "doc": "Destroys this inventory.",
        "short": "Destroys this inventory.",
        "member": "destroy()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "index": {
        "name": "index",
        "type": "defines.inventory",
        "mode": "[R]",
        "doc": "The inventory index this inventory uses, if any.",
        "short": "The inventory index this inventory uses, if any.",
        "member": "index  ::defines.inventory? Read"
      },
      "entity_owner": {
        "name": "entity_owner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The entity that owns this inventory, if any.",
        "short": "The entity that owns this inventory, if any.",
        "member": "entity_owner  ::LuaEntity? Read"
      },
      "player_owner": {
        "name": "player_owner",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The player that owns this inventory, if any.",
        "short": "The player that owns this inventory, if any.",
        "member": "player_owner  ::LuaPlayer? Read"
      },
      "equipment_owner": {
        "name": "equipment_owner",
        "type": "LuaEquipment",
        "mode": "[R]",
        "doc": "The equipment that owns this inventory, if any.",
        "short": "The equipment that owns this inventory, if any.",
        "member": "equipment_owner  ::LuaEquipment? Read"
      },
      "mod_owner": {
        "name": "mod_owner",
        "type": "string",
        "mode": "[R]",
        "doc": "The mod that owns this inventory, if any.",
        "short": "The mod that owns this inventory, if any.",
        "member": "mod_owner  ::string? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "# (length)": {
        "name": "# (length)",
        "type": "uint",
        "mode": "[R]",
        "doc": "Get the number of slots in this inventory."
      },
      "[] (index)": {
        "name": "[] (index)",
        "type": "LuaItemStack",
        "mode": "[R]",
        "doc": "The indexing operator."
      }
    }
  },
  "LuaItemPrototype": {
    "name": "LuaItemPrototype",
    "type": "LuaItemPrototype",
    "inherits": [],
    "properties": {
      "has_flag": {
        "name": "has_flag",
        "type": "function",
        "doc": "Does this prototype have a flag enabled?",
        "short": "Does this prototype have a flag enabled?",
        "member": "has_flag(flag)  boolean",
        "args": {
          "flag": {
            "name": "flag",
            "type": "ItemPrototypeFlag",
            "doc": "The flag to check."
          }
        }
      },
      "get_ammo_type": {
        "name": "get_ammo_type",
        "type": "function",
        "doc": "The type of this ammo prototype.",
        "short": "The type of this ammo prototype.",
        "member": "get_ammo_type(ammo_source_type?)  AmmoType?",
        "args": {
          "ammo_source_type": {
            "name": "ammo_source_type",
            "type": "\"default\" or \"player\" or \"turret\" or \"vehicle\"?",
            "doc": "Defaults to \"default\"."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "Type of this prototype. E.g. \"gun\" or \"mining-tool\".",
        "short": "Type of this prototype. [...]",
        "member": "type  ::string Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "place_result": {
        "name": "place_result",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "Prototype of the entity that will be created by placing this item, if any.",
        "short": "Prototype of the entity that will be created by placing this item, if any.",
        "member": "place_result  ::LuaEntityPrototype? Read"
      },
      "place_as_equipment_result": {
        "name": "place_as_equipment_result",
        "type": "LuaEquipmentPrototype",
        "mode": "[R]",
        "doc": "Prototype of the equipment that will be created by placing this item in an equipment grid, if any.",
        "short": "Prototype of the equipment that will be created by placing this item in an equipment grid, if any.",
        "member": "place_as_equipment_result  ::LuaEquipmentPrototype? Read"
      },
      "place_as_tile_result": {
        "name": "place_as_tile_result",
        "type": "PlaceAsTileResult",
        "mode": "[R]",
        "doc": "The place-as-tile result if one is defined, if any.",
        "short": "The place-as-tile result if one is defined, if any.",
        "member": "place_as_tile_result  ::PlaceAsTileResult? Read"
      },
      "stackable": {
        "name": "stackable",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this item allowed to stack at all?",
        "short": "Is this item allowed to stack at all?",
        "member": "stackable  ::boolean Read"
      },
      "default_request_amount": {
        "name": "default_request_amount",
        "type": "uint",
        "mode": "[R]",
        "doc": "The default request value.",
        "short": "The default request value.",
        "member": "default_request_amount  ::uint Read"
      },
      "stack_size": {
        "name": "stack_size",
        "type": "uint",
        "mode": "[R]",
        "doc": "Maximum stack size of the item specified by this prototype.",
        "short": "Maximum stack size of the item specified by this prototype.",
        "member": "stack_size  ::uint Read"
      },
      "wire_count": {
        "name": "wire_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of items needed to connect two entities with this as wire.",
        "short": "The number of items needed to connect two entities with this as wire.",
        "member": "wire_count  ::uint Read"
      },
      "fuel_category": {
        "name": "fuel_category",
        "type": "string",
        "mode": "[R]",
        "doc": "The fuel category of this item prototype, if any.",
        "short": "The fuel category of this item prototype, if any.",
        "member": "fuel_category  ::string? Read"
      },
      "burnt_result": {
        "name": "burnt_result",
        "type": "LuaItemPrototype",
        "mode": "[R]",
        "doc": "The result of burning this item as fuel, if any.",
        "short": "The result of burning this item as fuel, if any.",
        "member": "burnt_result  ::LuaItemPrototype? Read"
      },
      "fuel_value": {
        "name": "fuel_value",
        "type": "float",
        "mode": "[R]",
        "doc": "Fuel value when burned.",
        "short": "Fuel value when burned.",
        "member": "fuel_value  ::float Read"
      },
      "fuel_acceleration_multiplier": {
        "name": "fuel_acceleration_multiplier",
        "type": "double",
        "mode": "[R]",
        "doc": "The acceleration multiplier when this item is used as fuel in a vehicle.",
        "short": "The acceleration multiplier when this item is used as fuel in a vehicle.",
        "member": "fuel_acceleration_multiplier  ::double Read"
      },
      "fuel_top_speed_multiplier": {
        "name": "fuel_top_speed_multiplier",
        "type": "double",
        "mode": "[R]",
        "doc": "The fuel top speed multiplier when this item is used as fuel in a vehicle.",
        "short": "The fuel top speed multiplier when this item is used as fuel in a vehicle.",
        "member": "fuel_top_speed_multiplier  ::double Read"
      },
      "fuel_emissions_multiplier": {
        "name": "fuel_emissions_multiplier",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions multiplier if this is used as fuel.",
        "short": "The emissions multiplier if this is used as fuel.",
        "member": "fuel_emissions_multiplier  ::double Read"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "The subgroup this prototype belongs to.",
        "short": "The subgroup this prototype belongs to.",
        "member": "subgroup  ::LuaGroup Read"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "The group this prototype belongs to.",
        "short": "The group this prototype belongs to.",
        "member": "group  ::LuaGroup Read"
      },
      "flags": {
        "name": "flags",
        "type": "ItemPrototypeFlags",
        "mode": "[R]",
        "doc": "The flags for this item prototype.",
        "short": "The flags for this item prototype.",
        "member": "flags  ::ItemPrototypeFlags Read"
      },
      "rocket_launch_products": {
        "name": "rocket_launch_products",
        "type": "Product",
        "mode": "[R]",
        "doc": "The results of launching this item in a rocket.",
        "short": "The results of launching this item in a rocket.",
        "member": "rocket_launch_products  ::array[Product] Read"
      },
      "can_be_mod_opened": {
        "name": "can_be_mod_opened",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this item can be mod-opened.",
        "short": "If this item can be mod-opened.",
        "member": "can_be_mod_opened  ::boolean Read"
      },
      "magazine_size": {
        "name": "magazine_size",
        "type": "float",
        "mode": "[R]",
        "doc": "Size of full magazine.",
        "short": "Size of full magazine.",
        "member": "magazine_size  ::float? Read"
      },
      "reload_time": {
        "name": "reload_time",
        "type": "float",
        "mode": "[R]",
        "doc": "Amount of extra time (in ticks) it takes to reload the weapon after depleting the magazine.",
        "short": "Amount of extra time (in ticks) it takes to reload the weapon after depleting the magazine.",
        "member": "reload_time  ::float? Read"
      },
      "equipment_grid": {
        "name": "equipment_grid",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[R]",
        "doc": "The prototype of this armor's equipment grid, if any.",
        "short": "The prototype of this armor's equipment grid, if any.",
        "member": "equipment_grid  ::LuaEquipmentGridPrototype? Read"
      },
      "resistances": {
        "name": "resistances",
        "type": "string",
        "mode": "[R]",
        "doc": "Resistances of this armor item, if any, indexed by damage type name.",
        "short": "Resistances of this armor item, if any, indexed by damage type name.",
        "member": "resistances  ::dictionary[string Resistance]? Read"
      },
      "inventory_size_bonus": {
        "name": "inventory_size_bonus",
        "type": "uint",
        "mode": "[R]",
        "doc": "The inventory size bonus for this armor prototype.",
        "short": "The inventory size bonus for this armor prototype.",
        "member": "inventory_size_bonus  ::uint? Read"
      },
      "capsule_action": {
        "name": "capsule_action",
        "type": "CapsuleAction",
        "mode": "[R]",
        "doc": "The capsule action for this capsule item prototype.",
        "short": "The capsule action for this capsule item prototype.",
        "member": "capsule_action  ::CapsuleAction? Read"
      },
      "attack_parameters": {
        "name": "attack_parameters",
        "type": "AttackParameters",
        "mode": "[R]",
        "doc": "The gun attack parameters.",
        "short": "The gun attack parameters.",
        "member": "attack_parameters  ::AttackParameters? Read"
      },
      "inventory_size": {
        "name": "inventory_size",
        "type": "uint",
        "mode": "[R]",
        "doc": "The main inventory size for item-with-inventory-prototype.",
        "short": "The main inventory size for item-with-inventory-prototype.",
        "member": "inventory_size  ::uint? Read"
      },
      "item_filters": {
        "name": "item_filters",
        "type": "string",
        "mode": "[R]",
        "member": "item_filters  ::dictionary[string LuaItemPrototype]? Read"
      },
      "item_group_filters": {
        "name": "item_group_filters",
        "type": "string",
        "mode": "[R]",
        "member": "item_group_filters  ::dictionary[string LuaGroup]? Read"
      },
      "item_subgroup_filters": {
        "name": "item_subgroup_filters",
        "type": "string",
        "mode": "[R]",
        "member": "item_subgroup_filters  ::dictionary[string LuaGroup]? Read"
      },
      "filter_mode": {
        "name": "filter_mode",
        "mode": "[R]",
        "doc": "The filter mode used by this item with inventory.",
        "short": "The filter mode used by this item with inventory.",
        "member": "filter_mode  ::\"none\" or \"whitelist\" or \"blacklist\"? Read"
      },
      "insertion_priority_mode": {
        "name": "insertion_priority_mode",
        "mode": "[R]",
        "doc": "The insertion priority mode used by this item with inventory.",
        "short": "The insertion priority mode used by this item with inventory.",
        "member": "insertion_priority_mode  ::\"default\" or \"never\" or \"always\" or \"when-manually-filtered\"? Read"
      },
      "localised_filter_message": {
        "name": "localised_filter_message",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "The localised string used when the player attempts to put items into this item with inventory that aren't allowed.",
        "short": "The localised string used when the player attempts to put items into this item with inventory that aren't allowed.",
        "member": "localised_filter_message  ::LocalisedString? Read"
      },
      "extend_inventory_by_default": {
        "name": "extend_inventory_by_default",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this item with inventory extends the inventory it resides in by default.",
        "short": "If this item with inventory extends the inventory it resides in by default.",
        "member": "extend_inventory_by_default  ::boolean? Read"
      },
      "default_label_color": {
        "name": "default_label_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The default label color used for this item with label, if any.",
        "short": "The default label color used for this item with label, if any.",
        "member": "default_label_color  ::Color? Read"
      },
      "draw_label_for_cursor_render": {
        "name": "draw_label_for_cursor_render",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If true, and this item with label has a label it is drawn in place of the normal number when held in the cursor.",
        "short": "If true, and this item with label has a label it is drawn in place of the normal number when held in the cursor.",
        "member": "draw_label_for_cursor_render  ::boolean? Read"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[R]",
        "doc": "The repairing speed if this is a repairing tool.",
        "short": "The repairing speed if this is a repairing tool.",
        "member": "speed  ::float? Read"
      },
      "module_effects": {
        "name": "module_effects",
        "type": "ModuleEffects",
        "mode": "[R]",
        "doc": "Effects of this module.",
        "short": "Effects of this module.",
        "member": "module_effects  ::ModuleEffects? Read"
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[R]",
        "doc": "The name of a LuaModuleCategoryPrototype. Used when upgrading modules: Ctrl + click modules into an entity and it will replace lower tier modules of the same category with higher tier modules.",
        "short": "The name of a LuaModuleCategoryPrototype. [...]",
        "member": "category  ::string? Read"
      },
      "tier": {
        "name": "tier",
        "type": "uint",
        "mode": "[R]",
        "doc": "Tier of the module inside its category. Used when upgrading modules: Ctrl + click modules into an entity and it will replace lower tier modules with higher tier modules if they have the same category.",
        "short": "Tier of the module inside its category. [...]",
        "member": "tier  ::uint? Read"
      },
      "limitations": {
        "name": "limitations",
        "type": "string",
        "mode": "[R]",
        "doc": "An array of recipe names this module is allowed to work with. Empty when all recipes are allowed.",
        "short": "An array of recipe names this module is allowed to work with. [...]",
        "member": "limitations  ::array[string]? Read"
      },
      "limitation_message_key": {
        "name": "limitation_message_key",
        "type": "string",
        "mode": "[R]",
        "doc": "The limitation message key used when the player attempts to use this modules in some place it's not allowed.",
        "short": "The limitation message key used when the player attempts to use this modules in some place it's not allowed.",
        "member": "limitation_message_key  ::string? Read"
      },
      "straight_rail": {
        "name": "straight_rail",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The straight rail prototype used for this rail planner prototype.",
        "short": "The straight rail prototype used for this rail planner prototype.",
        "member": "straight_rail  ::LuaEntityPrototype? Read"
      },
      "curved_rail": {
        "name": "curved_rail",
        "type": "LuaEntityPrototype",
        "mode": "[R]",
        "doc": "The curved rail prototype used for this rail planner prototype.",
        "short": "The curved rail prototype used for this rail planner prototype.",
        "member": "curved_rail  ::LuaEntityPrototype? Read"
      },
      "repair_result": {
        "name": "repair_result",
        "type": "TriggerItem",
        "mode": "[R]",
        "doc": "The repair result of this repair tool prototype.",
        "short": "The repair result of this repair tool prototype.",
        "member": "repair_result  ::array[TriggerItem]? Read"
      },
      "selection_border_color": {
        "name": "selection_border_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The color used when doing normal selection with this selection tool prototype.",
        "short": "The color used when doing normal selection with this selection tool prototype.",
        "member": "selection_border_color  ::Color? Read"
      },
      "alt_selection_border_color": {
        "name": "alt_selection_border_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The color used when doing alt selection with this selection tool prototype.",
        "short": "The color used when doing alt selection with this selection tool prototype.",
        "member": "alt_selection_border_color  ::Color? Read"
      },
      "reverse_selection_border_color": {
        "name": "reverse_selection_border_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The color used when doing reverse selection with this selection tool prototype.",
        "short": "The color used when doing reverse selection with this selection tool prototype.",
        "member": "reverse_selection_border_color  ::Color? Read"
      },
      "alt_reverse_selection_border_color": {
        "name": "alt_reverse_selection_border_color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The color used when doing alt reverse selection with this selection tool prototype.",
        "short": "The color used when doing alt reverse selection with this selection tool prototype.",
        "member": "alt_reverse_selection_border_color  ::Color? Read"
      },
      "selection_mode_flags": {
        "name": "selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[R]",
        "doc": "Flags that affect which entities will be selected.",
        "short": "Flags that affect which entities will be selected.",
        "member": "selection_mode_flags  ::SelectionModeFlags? Read"
      },
      "alt_selection_mode_flags": {
        "name": "alt_selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[R]",
        "doc": "Flags that affect which entities will be selected during alternate selection.",
        "short": "Flags that affect which entities will be selected during alternate selection.",
        "member": "alt_selection_mode_flags  ::SelectionModeFlags? Read"
      },
      "reverse_selection_mode_flags": {
        "name": "reverse_selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[R]",
        "doc": "Flags that affect which entities will be selected during reverse selection.",
        "short": "Flags that affect which entities will be selected during reverse selection.",
        "member": "reverse_selection_mode_flags  ::SelectionModeFlags? Read"
      },
      "alt_reverse_selection_mode_flags": {
        "name": "alt_reverse_selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[R]",
        "doc": "Flags that affect which entities will be selected during alt reverse selection.",
        "short": "Flags that affect which entities will be selected during alt reverse selection.",
        "member": "alt_reverse_selection_mode_flags  ::SelectionModeFlags? Read"
      },
      "selection_cursor_box_type": {
        "name": "selection_cursor_box_type",
        "type": "CursorBoxRenderType",
        "mode": "[R]",
        "member": "selection_cursor_box_type  ::CursorBoxRenderType? Read"
      },
      "alt_selection_cursor_box_type": {
        "name": "alt_selection_cursor_box_type",
        "type": "CursorBoxRenderType",
        "mode": "[R]",
        "member": "alt_selection_cursor_box_type  ::CursorBoxRenderType? Read"
      },
      "reverse_selection_cursor_box_type": {
        "name": "reverse_selection_cursor_box_type",
        "type": "CursorBoxRenderType",
        "mode": "[R]",
        "member": "reverse_selection_cursor_box_type  ::CursorBoxRenderType? Read"
      },
      "alt_reverse_selection_cursor_box_type": {
        "name": "alt_reverse_selection_cursor_box_type",
        "type": "CursorBoxRenderType",
        "mode": "[R]",
        "member": "alt_reverse_selection_cursor_box_type  ::CursorBoxRenderType? Read"
      },
      "always_include_tiles": {
        "name": "always_include_tiles",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If tiles area always included when doing selection with this selection tool prototype.",
        "short": "If tiles area always included when doing selection with this selection tool prototype.",
        "member": "always_include_tiles  ::boolean? Read"
      },
      "entity_filter_mode": {
        "name": "entity_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The entity filter mode used by this selection tool.",
        "short": "The entity filter mode used by this selection tool.",
        "member": "entity_filter_mode  ::PrototypeFilterMode? Read"
      },
      "alt_entity_filter_mode": {
        "name": "alt_entity_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The alt entity filter mode used by this selection tool.",
        "short": "The alt entity filter mode used by this selection tool.",
        "member": "alt_entity_filter_mode  ::PrototypeFilterMode? Read"
      },
      "reverse_alt_entity_filter_mode": {
        "name": "reverse_alt_entity_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The reverse entity filter mode used by this selection tool.",
        "short": "The reverse entity filter mode used by this selection tool.",
        "member": "reverse_alt_entity_filter_mode  ::PrototypeFilterMode? Read"
      },
      "alt_reverse_alt_entity_filter_mode": {
        "name": "alt_reverse_alt_entity_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The alt reverse entity filter mode used by this selection tool.",
        "short": "The alt reverse entity filter mode used by this selection tool.",
        "member": "alt_reverse_alt_entity_filter_mode  ::PrototypeFilterMode? Read"
      },
      "tile_filter_mode": {
        "name": "tile_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The tile filter mode used by this selection tool.",
        "short": "The tile filter mode used by this selection tool.",
        "member": "tile_filter_mode  ::PrototypeFilterMode? Read"
      },
      "alt_tile_filter_mode": {
        "name": "alt_tile_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The alt tile filter mode used by this selection tool.",
        "short": "The alt tile filter mode used by this selection tool.",
        "member": "alt_tile_filter_mode  ::PrototypeFilterMode? Read"
      },
      "reverse_tile_filter_mode": {
        "name": "reverse_tile_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The reverse tile filter mode used by this selection tool.",
        "short": "The reverse tile filter mode used by this selection tool.",
        "member": "reverse_tile_filter_mode  ::PrototypeFilterMode? Read"
      },
      "alt_reverse_tile_filter_mode": {
        "name": "alt_reverse_tile_filter_mode",
        "type": "PrototypeFilterMode",
        "mode": "[R]",
        "doc": "The alt reverse tile filter mode used by this selection tool.",
        "short": "The alt reverse tile filter mode used by this selection tool.",
        "member": "alt_reverse_tile_filter_mode  ::PrototypeFilterMode? Read"
      },
      "entity_filters": {
        "name": "entity_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The entity filters used by this selection tool indexed by entity name.",
        "short": "The entity filters used by this selection tool indexed by entity name.",
        "member": "entity_filters  ::dictionary[string LuaEntityPrototype]? Read"
      },
      "alt_entity_filters": {
        "name": "alt_entity_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The alt entity filters used by this selection tool indexed by entity name.",
        "short": "The alt entity filters used by this selection tool indexed by entity name.",
        "member": "alt_entity_filters  ::dictionary[string LuaEntityPrototype]? Read"
      },
      "reverse_entity_filters": {
        "name": "reverse_entity_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The reverse entity filters used by this selection tool indexed by entity name.",
        "short": "The reverse entity filters used by this selection tool indexed by entity name.",
        "member": "reverse_entity_filters  ::dictionary[string LuaEntityPrototype]? Read"
      },
      "alt_reverse_entity_filters": {
        "name": "alt_reverse_entity_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The alt reverse entity filters used by this selection tool indexed by entity name.",
        "short": "The alt reverse entity filters used by this selection tool indexed by entity name.",
        "member": "alt_reverse_entity_filters  ::dictionary[string LuaEntityPrototype]? Read"
      },
      "entity_type_filters": {
        "name": "entity_type_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The entity type filters used by this selection tool indexed by entity type.",
        "short": "The entity type filters used by this selection tool indexed by entity type.",
        "member": "entity_type_filters  ::dictionary[string boolean]? Read"
      },
      "alt_entity_type_filters": {
        "name": "alt_entity_type_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The alt entity type filters used by this selection tool indexed by entity type.",
        "short": "The alt entity type filters used by this selection tool indexed by entity type.",
        "member": "alt_entity_type_filters  ::dictionary[string boolean]? Read"
      },
      "reverse_entity_type_filters": {
        "name": "reverse_entity_type_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The reverse entity type filters used by this selection tool indexed by entity type.",
        "short": "The reverse entity type filters used by this selection tool indexed by entity type.",
        "member": "reverse_entity_type_filters  ::dictionary[string boolean]? Read"
      },
      "alt_reverse_entity_type_filters": {
        "name": "alt_reverse_entity_type_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The alt reverse entity type filters used by this selection tool indexed by entity type.",
        "short": "The alt reverse entity type filters used by this selection tool indexed by entity type.",
        "member": "alt_reverse_entity_type_filters  ::dictionary[string boolean]? Read"
      },
      "tile_filters": {
        "name": "tile_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The tile filters used by this selection tool indexed by tile name.",
        "short": "The tile filters used by this selection tool indexed by tile name.",
        "member": "tile_filters  ::dictionary[string LuaTilePrototype]? Read"
      },
      "alt_tile_filters": {
        "name": "alt_tile_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The alt tile filters used by this selection tool indexed by tile name.",
        "short": "The alt tile filters used by this selection tool indexed by tile name.",
        "member": "alt_tile_filters  ::dictionary[string LuaTilePrototype]? Read"
      },
      "reverse_tile_filters": {
        "name": "reverse_tile_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The reverse tile filters used by this selection tool indexed by tile name.",
        "short": "The reverse tile filters used by this selection tool indexed by tile name.",
        "member": "reverse_tile_filters  ::dictionary[string LuaTilePrototype]? Read"
      },
      "alt_reverse_tile_filters": {
        "name": "alt_reverse_tile_filters",
        "type": "string",
        "mode": "[R]",
        "doc": "The alt reverse tile filters used by this selection tool indexed by tile name.",
        "short": "The alt reverse tile filters used by this selection tool indexed by tile name.",
        "member": "alt_reverse_tile_filters  ::dictionary[string LuaTilePrototype]? Read"
      },
      "entity_filter_slots": {
        "name": "entity_filter_slots",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of entity filters this deconstruction item has.",
        "short": "The number of entity filters this deconstruction item has.",
        "member": "entity_filter_slots  ::uint? Read"
      },
      "tile_filter_slots": {
        "name": "tile_filter_slots",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of tile filters this deconstruction item has.",
        "short": "The number of tile filters this deconstruction item has.",
        "member": "tile_filter_slots  ::uint? Read"
      },
      "durability_description_key": {
        "name": "durability_description_key",
        "type": "string",
        "mode": "[R]",
        "doc": "The durability message key used when displaying the durability of this tool.",
        "short": "The durability message key used when displaying the durability of this tool.",
        "member": "durability_description_key  ::string? Read"
      },
      "durability": {
        "name": "durability",
        "type": "double",
        "mode": "[R]",
        "doc": "The durability of this tool item.",
        "short": "The durability of this tool item.",
        "member": "durability  ::double? Read"
      },
      "infinite": {
        "name": "infinite",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this tool item has infinite durability.",
        "short": "If this tool item has infinite durability.",
        "member": "infinite  ::boolean? Read"
      },
      "mapper_count": {
        "name": "mapper_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "How many filters an upgrade item has.",
        "short": "How many filters an upgrade item has.",
        "member": "mapper_count  ::uint? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaItemStack": {
    "name": "LuaItemStack",
    "type": "LuaItemStack",
    "inherits": [],
    "properties": {
      "is_blueprint_setup": {
        "name": "is_blueprint_setup",
        "type": "function",
        "doc": "Is this blueprint item setup? I.e. is it a non-empty blueprint?",
        "short": "Is this blueprint item setup? [...]",
        "member": "is_blueprint_setup()  boolean"
      },
      "get_blueprint_entities": {
        "name": "get_blueprint_entities",
        "type": "function",
        "doc": "The entities in this blueprint.",
        "short": "The entities in this blueprint.",
        "member": "get_blueprint_entities()  array[BlueprintEntity]?"
      },
      "set_blueprint_entities": {
        "name": "set_blueprint_entities",
        "doc": "Set new entities to be a part of this blueprint.",
        "short": "Set new entities to be a part of this blueprint.",
        "member": "set_blueprint_entities(entities)",
        "type": "function",
        "args": {
          "entities": {
            "name": "entities",
            "type": "array[BlueprintEntity]",
            "doc": "The new blueprint entities."
          }
        }
      },
      "add_ammo": {
        "name": "add_ammo",
        "doc": "Add ammo to this ammo item.",
        "short": "Add ammo to this ammo item.",
        "member": "add_ammo(amount)",
        "type": "function",
        "args": {
          "amount": {
            "name": "amount",
            "type": "float",
            "doc": "Amount of ammo to add."
          }
        }
      },
      "drain_ammo": {
        "name": "drain_ammo",
        "doc": "Remove ammo from this ammo item.",
        "short": "Remove ammo from this ammo item.",
        "member": "drain_ammo(amount)",
        "type": "function",
        "args": {
          "amount": {
            "name": "amount",
            "type": "float",
            "doc": "Amount of ammo to remove."
          }
        }
      },
      "add_durability": {
        "name": "add_durability",
        "doc": "Add durability to this tool item.",
        "short": "Add durability to this tool item.",
        "member": "add_durability(amount)",
        "type": "function",
        "args": {
          "amount": {
            "name": "amount",
            "type": "double",
            "doc": "Amount of durability to add."
          }
        }
      },
      "drain_durability": {
        "name": "drain_durability",
        "doc": "Remove durability from this tool item.",
        "short": "Remove durability from this tool item.",
        "member": "drain_durability(amount)",
        "type": "function",
        "args": {
          "amount": {
            "name": "amount",
            "type": "double",
            "doc": "Amount of durability to remove."
          }
        }
      },
      "use_capsule": {
        "name": "use_capsule",
        "type": "function",
        "doc": "Use the capsule item with the entity as the source, targeting the given position. Returns: Array of the entities that were created by the capsule action.",
        "short": "Use the capsule item with the entity as the source, targeting the given position.",
        "member": "use_capsule(entity, target_position)  array[LuaEntity]",
        "returns": "array[LuaEntity]",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "The entity to use the capsule item with."
          },
          "target_position": {
            "name": "target_position",
            "type": "MapPosition",
            "doc": "The position to use the capsule item with."
          }
        }
      },
      "can_set_stack": {
        "name": "can_set_stack",
        "type": "function",
        "doc": "Would a call to LuaItemStack::set_stack succeed?",
        "short": "Would a call to LuaItemStack::set_stack succeed?",
        "member": "can_set_stack(stack?)  boolean",
        "args": {
          "stack": {
            "name": "stack",
            "type": "ItemStackIdentification?",
            "doc": "Stack that would be set, possibly nil."
          }
        }
      },
      "set_stack": {
        "name": "set_stack",
        "type": "function",
        "doc": "Set this item stack to another item stack. Returns: Whether the stack was set successfully. Returns false if this stack was not valid for write.",
        "short": "Set this item stack to another item stack.",
        "member": "set_stack(stack?)  boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "name": "stack",
            "type": "ItemStackIdentification?",
            "doc": "Item stack to set it to. Omitting this parameter or passing nil will clear this item stack, as if LuaItemStack::clear was called."
          }
        }
      },
      "transfer_stack": {
        "name": "transfer_stack",
        "type": "function",
        "doc": "Transfers the given item stack into this item stack. Returns: true if the full stack was transferred.",
        "short": "Transfers the given item stack into this item stack.",
        "member": "transfer_stack(stack)  boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "name": "stack",
            "type": "ItemStackIdentification",
            "doc": ""
          }
        }
      },
      "export_stack": {
        "name": "export_stack",
        "type": "function",
        "doc": "Export a supported item (blueprint, blueprint-book, deconstruction-planner, upgrade-planner, item-with-tags) to a string. Returns: The exported string",
        "short": "Export a supported item (blueprint, blueprint-book, deconstruction-planner, upgrade-planner, item-with-tags) to a string.",
        "member": "export_stack()  string",
        "returns": "string"
      },
      "import_stack": {
        "name": "import_stack",
        "type": "function",
        "doc": "Import a supported item (blueprint, blueprint-book, deconstruction-planner, upgrade-planner, item-with-tags) from a string. Returns: 0 if the import succeeded with no errors. -1 if the import succeeded with errors. 1 if the import failed.",
        "short": "Import a supported item (blueprint, blueprint-book, deconstruction-planner, upgrade-planner, item-with-tags) from a string.",
        "member": "import_stack(data)  int",
        "returns": "int",
        "args": {
          "data": {
            "name": "data",
            "type": "string",
            "doc": "The string to import"
          }
        }
      },
      "swap_stack": {
        "name": "swap_stack",
        "type": "function",
        "doc": "Swaps this item stack with the given item stack if allowed. Returns: Whether the 2 stacks were swapped successfully.",
        "short": "Swaps this item stack with the given item stack if allowed.",
        "member": "swap_stack(stack)  boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "name": "stack",
            "type": "LuaItemStack",
            "doc": ""
          }
        }
      },
      "clear": {
        "name": "clear",
        "doc": "Clear this item stack.",
        "short": "Clear this item stack.",
        "member": "clear()",
        "type": "function"
      },
      "get_blueprint_tiles": {
        "name": "get_blueprint_tiles",
        "type": "function",
        "doc": "A list of the tiles in this blueprint.",
        "short": "A list of the tiles in this blueprint.",
        "member": "get_blueprint_tiles()  array[Tile]?"
      },
      "set_blueprint_tiles": {
        "name": "set_blueprint_tiles",
        "doc": "Set specific tiles in this blueprint.",
        "short": "Set specific tiles in this blueprint.",
        "member": "set_blueprint_tiles(tiles)",
        "type": "function",
        "args": {
          "tiles": {
            "name": "tiles",
            "type": "array[Tile]",
            "doc": "Tiles to be a part of the blueprint."
          }
        }
      },
      "get_inventory": {
        "name": "get_inventory",
        "type": "function",
        "doc": "Access the inner inventory of an item. Returns: nil if there is no inventory with the given index.",
        "short": "Access the inner inventory of an item.",
        "member": "get_inventory(inventory)  LuaInventory?",
        "returns": "LuaInventory?",
        "args": {
          "inventory": {
            "name": "inventory",
            "type": "defines.inventory",
            "doc": "Index of the inventory to access, which can only be defines.inventory.item_main."
          }
        }
      },
      "build_blueprint": {
        "name": "build_blueprint",
        "type": "LuaEntity",
        "doc": "Surface to build on Returns: Array of created ghosts",
        "member": "build_blueprint{surface=, force=, position=, force_build?=, direction?=, skip_fog_of_war?=, by_player?=, raise_built?=}  array[LuaEntity]",
        "returns": "array[LuaEntity]",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to build on"
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force to use for the building"
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position to build at"
          },
          "force_build": {
            "name": "force_build",
            "type": "boolean?",
            "doc": "When true, anything that can be built is else nothing is built if any one thing can't be built"
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "The direction to use when building"
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "The player to use if any. If provided defines.events.on_built_entity will also be fired on successful entity creation."
          },
          "raise_built": {
            "name": "raise_built",
            "type": "boolean?",
            "doc": "If true; defines.events.script_raised_built will be fired on successful entity creation. Note: this is ignored if by_player is provided."
          }
        }
      },
      "deconstruct_area": {
        "name": "deconstruct_area",
        "doc": "Deconstruct the given area with this deconstruction item.",
        "short": "Deconstruct the given area with this deconstruction item.",
        "member": "deconstruct_area{surface=, force=, area=, skip_fog_of_war?=, by_player?=}",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to deconstruct on"
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force to use for the deconstruction"
          },
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area to deconstruct"
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "The player to use if any."
          }
        }
      },
      "cancel_deconstruct_area": {
        "name": "cancel_deconstruct_area",
        "doc": "Cancel deconstruct the given area with this deconstruction item.",
        "short": "Cancel deconstruct the given area with this deconstruction item.",
        "member": "cancel_deconstruct_area{surface=, force=, area=, skip_fog_of_war?=, by_player?=}",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to cancel deconstruct on"
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force to use for canceling deconstruction"
          },
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area to deconstruct"
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "by_player": {
            "name": "by_player",
            "type": "PlayerIdentification?",
            "doc": "The player to use if any."
          }
        }
      },
      "create_blueprint": {
        "name": "create_blueprint",
        "type": "uint",
        "doc": "Sets up this blueprint using the found blueprintable entities/tiles on the surface. Returns: The blueprint entity index to source entity mapping.",
        "short": "Sets up this blueprint using the found blueprintable entities/tiles on the surface.",
        "member": "create_blueprint{surface=, force=, area=, always_include_tiles?=, include_entities?=, include_modules?=, include_station_names?=, include_trains?=, include_fuel?=}  dictionary[uint LuaEntity]",
        "returns": "dictionary[uint LuaEntity]",
        "args": {
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": "Surface to create from"
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force to use for the creation"
          },
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The bounding box"
          },
          "always_include_tiles": {
            "name": "always_include_tiles",
            "type": "boolean?",
            "doc": "When true, blueprintable tiles are always included in the blueprint. When false they're only included if no entities exist in the setup area."
          },
          "include_entities": {
            "name": "include_entities",
            "type": "boolean?",
            "doc": "When true, entities are included in the blueprint. Defaults to true."
          },
          "include_modules": {
            "name": "include_modules",
            "type": "boolean?",
            "doc": "When true, modules are included in the blueprint. Defaults to true."
          },
          "include_station_names": {
            "name": "include_station_names",
            "type": "boolean?",
            "doc": "When true, station names are included in the blueprint. Defaults to false."
          },
          "include_trains": {
            "name": "include_trains",
            "type": "boolean?",
            "doc": "When true, trains are included in the blueprint. Defaults to false."
          },
          "include_fuel": {
            "name": "include_fuel",
            "type": "boolean?",
            "doc": "When true, train fuel is included in the blueprint, Defaults to true."
          }
        }
      },
      "get_tag": {
        "name": "get_tag",
        "type": "function",
        "doc": "Gets the tag with the given name or returns nil if it doesn't exist.",
        "short": "Gets the tag with the given name or returns nil if it doesn't exist.",
        "member": "get_tag(tag_name)  AnyBasic?",
        "args": {
          "tag_name": {
            "name": "tag_name",
            "type": "string",
            "doc": ""
          }
        }
      },
      "set_tag": {
        "name": "set_tag",
        "doc": "Sets the tag with the given name and value.",
        "short": "Sets the tag with the given name and value.",
        "member": "set_tag(tag_name, tag)",
        "type": "function",
        "args": {
          "tag_name": {
            "name": "tag_name",
            "type": "string",
            "doc": ""
          },
          "tag": {
            "name": "tag",
            "type": "AnyBasic",
            "doc": ""
          }
        }
      },
      "remove_tag": {
        "name": "remove_tag",
        "type": "function",
        "doc": "Removes a tag with the given name. Returns: If the tag existed and was removed.",
        "short": "Removes a tag with the given name.",
        "member": "remove_tag(tag)  boolean",
        "returns": "boolean",
        "args": {
          "tag": {
            "name": "tag",
            "type": "string",
            "doc": ""
          }
        }
      },
      "clear_blueprint": {
        "name": "clear_blueprint",
        "doc": "Clears this blueprint item.",
        "short": "Clears this blueprint item.",
        "member": "clear_blueprint()",
        "type": "function"
      },
      "get_entity_filter": {
        "name": "get_entity_filter",
        "type": "function",
        "doc": "Gets the entity filter at the given index for this deconstruction item.",
        "short": "Gets the entity filter at the given index for this deconstruction item.",
        "member": "get_entity_filter(index)  string?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "set_entity_filter": {
        "name": "set_entity_filter",
        "type": "function",
        "doc": "Sets the entity filter at the given index for this deconstruction item. Returns: Whether the new filter was successfully set (meaning it was valid).",
        "short": "Sets the entity filter at the given index for this deconstruction item.",
        "member": "set_entity_filter(index, filter)  boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          },
          "filter": {
            "name": "filter",
            "type": "string or LuaEntityPrototype or LuaEntity or nil",
            "doc": "Writing nil removes the filter."
          }
        }
      },
      "get_tile_filter": {
        "name": "get_tile_filter",
        "type": "function",
        "doc": "Gets the tile filter at the given index for this deconstruction item.",
        "short": "Gets the tile filter at the given index for this deconstruction item.",
        "member": "get_tile_filter(index)  string?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "set_tile_filter": {
        "name": "set_tile_filter",
        "type": "function",
        "doc": "Sets the tile filter at the given index for this deconstruction item. Returns: Whether the new filter was successfully set (meaning it was valid).",
        "short": "Sets the tile filter at the given index for this deconstruction item.",
        "member": "set_tile_filter(index, filter)  boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          },
          "filter": {
            "name": "filter",
            "type": "string or LuaTilePrototype or LuaTile or nil",
            "doc": "Writing nil removes the filter."
          }
        }
      },
      "clear_deconstruction_item": {
        "name": "clear_deconstruction_item",
        "doc": "Clears all settings/filters on this deconstruction item resetting it to default values.",
        "short": "Clears all settings/filters on this deconstruction item resetting it to default values.",
        "member": "clear_deconstruction_item()",
        "type": "function"
      },
      "clear_upgrade_item": {
        "name": "clear_upgrade_item",
        "doc": "Clears all settings/filters on this upgrade item resetting it to default values.",
        "short": "Clears all settings/filters on this upgrade item resetting it to default values.",
        "member": "clear_upgrade_item()",
        "type": "function"
      },
      "get_mapper": {
        "name": "get_mapper",
        "type": "function",
        "doc": "Gets the filter at the given index for this upgrade item.",
        "short": "Gets the filter at the given index for this upgrade item.",
        "member": "get_mapper(index, type)  UpgradeFilter",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index of the mapper to read."
          },
          "type": {
            "name": "type",
            "type": "\"from\" or \"to\"",
            "doc": ""
          }
        }
      },
      "set_mapper": {
        "name": "set_mapper",
        "doc": "Sets the module filter at the given index for this upgrade item.",
        "short": "Sets the module filter at the given index for this upgrade item.",
        "member": "set_mapper(index, type, filter)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index of the mapper to set."
          },
          "type": {
            "name": "type",
            "type": "\"from\" or \"to\"",
            "doc": ""
          },
          "filter": {
            "name": "filter",
            "type": "UpgradeFilter or nil",
            "doc": "The filter to set or nil"
          }
        }
      },
      "get_blueprint_entity_count": {
        "name": "get_blueprint_entity_count",
        "type": "function",
        "doc": "Gets the number of entities in this blueprint item.",
        "short": "Gets the number of entities in this blueprint item.",
        "member": "get_blueprint_entity_count()  uint"
      },
      "get_blueprint_entity_tags": {
        "name": "get_blueprint_entity_tags",
        "type": "function",
        "doc": "Gets the tags for the given blueprint entity index in this blueprint item.",
        "short": "Gets the tags for the given blueprint entity index in this blueprint item.",
        "member": "get_blueprint_entity_tags(index)  Tags",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "set_blueprint_entity_tags": {
        "name": "set_blueprint_entity_tags",
        "doc": "Sets the tags on the given blueprint entity index in this blueprint item.",
        "short": "Sets the tags on the given blueprint entity index in this blueprint item.",
        "member": "set_blueprint_entity_tags(index, tags)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The entity index"
          },
          "tags": {
            "name": "tags",
            "type": "Tags",
            "doc": ""
          }
        }
      },
      "get_blueprint_entity_tag": {
        "name": "get_blueprint_entity_tag",
        "type": "function",
        "doc": "Gets the given tag on the given blueprint entity index in this blueprint item.",
        "short": "Gets the given tag on the given blueprint entity index in this blueprint item.",
        "member": "get_blueprint_entity_tag(index, tag)  AnyBasic?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The entity index."
          },
          "tag": {
            "name": "tag",
            "type": "string",
            "doc": "The tag to get."
          }
        }
      },
      "set_blueprint_entity_tag": {
        "name": "set_blueprint_entity_tag",
        "doc": "Sets the given tag on the given blueprint entity index in this blueprint item.",
        "short": "Sets the given tag on the given blueprint entity index in this blueprint item.",
        "member": "set_blueprint_entity_tag(index, tag, value)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The entity index."
          },
          "tag": {
            "name": "tag",
            "type": "string",
            "doc": "The tag to set."
          },
          "value": {
            "name": "value",
            "type": "AnyBasic",
            "doc": "The tag value to set or nil to clear the tag."
          }
        }
      },
      "create_grid": {
        "name": "create_grid",
        "type": "function",
        "doc": "Creates the equipment grid for this item if it doesn't exist and this is an item-with-entity-data that supports equipment grids.",
        "short": "Creates the equipment grid for this item if it doesn't exist and this is an item-with-entity-data that supports equipment grids.",
        "member": "create_grid()  LuaEquipmentGrid"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid_for_read": {
        "name": "valid_for_read",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this valid for reading? Differs from the usual valid in that valid will be true even if the item stack is blank but the entity that holds it is still valid.",
        "short": "Is this valid for reading? [...]",
        "member": "valid_for_read  ::boolean Read"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaItemPrototype",
        "mode": "[R]",
        "doc": "Prototype of the item held in this stack.",
        "short": "Prototype of the item held in this stack.",
        "member": "prototype  ::LuaItemPrototype Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Prototype name of the item held in this stack.",
        "short": "Prototype name of the item held in this stack.",
        "member": "name  ::string Read"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "Type of the item prototype.",
        "short": "Type of the item prototype.",
        "member": "type  ::string Read"
      },
      "count": {
        "name": "count",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Number of items in this stack.",
        "short": "Number of items in this stack.",
        "member": "count  ::uint Read/Write"
      },
      "grid": {
        "name": "grid",
        "type": "LuaEquipmentGrid",
        "mode": "[R]",
        "doc": "The equipment grid of this item, if any.",
        "short": "The equipment grid of this item, if any.",
        "member": "grid  ::LuaEquipmentGrid? Read"
      },
      "health": {
        "name": "health",
        "type": "float",
        "mode": "[RW]",
        "doc": "How much health the item has, as a number in range [0, 1].",
        "short": "How much health the item has, as a number in range [0, 1].",
        "member": "health  ::float Read/Write"
      },
      "durability": {
        "name": "durability",
        "type": "double",
        "mode": "[RW]",
        "doc": "Durability of the contained item. Automatically capped at the item's maximum durability.",
        "short": "Durability of the contained item. [...]",
        "member": "durability  ::double? Read/Write"
      },
      "ammo": {
        "name": "ammo",
        "type": "uint",
        "mode": "[RW]",
        "doc": "Number of bullets left in the magazine.",
        "short": "Number of bullets left in the magazine.",
        "member": "ammo  ::uint Read/Write"
      },
      "blueprint_icons": {
        "name": "blueprint_icons",
        "type": "BlueprintSignalIcon",
        "mode": "[RW]",
        "doc": "Icons of this blueprint item, blueprint book, deconstruction item or upgrade planner. An item that doesn't have icons returns nil on read and throws error on write.",
        "short": "Icons of this blueprint item, blueprint book, deconstruction item or upgrade planner. [...]",
        "member": "blueprint_icons  ::array[BlueprintSignalIcon]? Read/Write"
      },
      "blueprint_snap_to_grid": {
        "name": "blueprint_snap_to_grid",
        "type": "TilePosition",
        "mode": "[RW]",
        "doc": "The snapping grid size in this blueprint item. nil if snapping is not enabled.",
        "short": "The snapping grid size in this blueprint item. [...]",
        "member": "blueprint_snap_to_grid  ::TilePosition? Read/Write"
      },
      "blueprint_position_relative_to_grid": {
        "name": "blueprint_position_relative_to_grid",
        "type": "TilePosition",
        "mode": "[RW]",
        "doc": "The offset from the absolute grid. nil if absolute snapping is not enabled.",
        "short": "The offset from the absolute grid. [...]",
        "member": "blueprint_position_relative_to_grid  ::TilePosition? Read/Write"
      },
      "blueprint_absolute_snapping": {
        "name": "blueprint_absolute_snapping",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If absolute snapping is enabled on this blueprint item.",
        "short": "If absolute snapping is enabled on this blueprint item.",
        "member": "blueprint_absolute_snapping  ::boolean Read/Write"
      },
      "label": {
        "name": "label",
        "type": "string",
        "mode": "[RW]",
        "doc": "The current label for this item, if any.",
        "short": "The current label for this item, if any.",
        "member": "label  ::string? Read/Write"
      },
      "label_color": {
        "name": "label_color",
        "type": "Color",
        "mode": "[RW]",
        "doc": "The current label color for this item, if any.",
        "short": "The current label color for this item, if any.",
        "member": "label_color  ::Color? Read/Write"
      },
      "allow_manual_label_change": {
        "name": "allow_manual_label_change",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the label for this item can be manually changed. When false the label can only be changed through the API.",
        "short": "Whether the label for this item can be manually changed. [...]",
        "member": "allow_manual_label_change  ::boolean Read/Write"
      },
      "cost_to_build": {
        "name": "cost_to_build",
        "type": "string",
        "mode": "[R]",
        "doc": "Raw materials required to build this blueprint. Result is a dictionary mapping each item prototype name to the required count.",
        "short": "Raw materials required to build this blueprint. [...]",
        "member": "cost_to_build  ::dictionary[string uint] Read"
      },
      "extends_inventory": {
        "name": "extends_inventory",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If this item extends the inventory it resides in (provides its contents for counts, crafting, insertion). Only callable on items with inventories.",
        "short": "If this item extends the inventory it resides in (provides its contents for counts, crafting, insertion). [...]",
        "member": "extends_inventory  ::boolean Read/Write"
      },
      "prioritize_insertion_mode": {
        "name": "prioritize_insertion_mode",
        "mode": "[RW]",
        "doc": "The insertion mode priority this ItemWithInventory uses when items are inserted into an inventory it resides in. Only callable on items with inventories.",
        "short": "The insertion mode priority this ItemWithInventory uses when items are inserted into an inventory it resides in. [...]",
        "member": "prioritize_insertion_mode  ::\"default\" or \"never\" or \"always\" or \"when-manually-filtered\" Read/Write"
      },
      "default_icons": {
        "name": "default_icons",
        "type": "BlueprintSignalIcon",
        "mode": "[R]",
        "doc": "The default icons for a blueprint item.",
        "short": "The default icons for a blueprint item.",
        "member": "default_icons  ::array[BlueprintSignalIcon] Read"
      },
      "tags": {
        "name": "tags",
        "type": "Tags",
        "mode": "[RW]",
        "member": "tags  ::Tags Read/Write"
      },
      "custom_description": {
        "name": "custom_description",
        "type": "LocalisedString",
        "mode": "[RW]",
        "doc": "The custom description this item-with-tags. This is shown over the normal item description if this is set to a non-empty value.",
        "short": "The custom description this item-with-tags. [...]",
        "member": "custom_description  ::LocalisedString Read/Write"
      },
      "entity_filters": {
        "name": "entity_filters",
        "type": "string",
        "mode": "[RW]",
        "doc": "The entity filters for this deconstruction item. The attribute is a sparse array with the keys representing the index of the filter. All strings in this array must be entity prototype names that don't have the \"not-deconstructable\" flag set and are either a cliff or marked as minable.",
        "short": "The entity filters for this deconstruction item. [...]",
        "member": "entity_filters  ::array[string] Read/Write"
      },
      "tile_filters": {
        "name": "tile_filters",
        "type": "string",
        "mode": "[RW]",
        "doc": "The tile filters for this deconstruction item. The attribute is a sparse array with the keys representing the index of the filter. All strings in this array must be tile prototype names.",
        "short": "The tile filters for this deconstruction item. [...]",
        "member": "tile_filters  ::array[string] Read/Write"
      },
      "entity_filter_mode": {
        "name": "entity_filter_mode",
        "type": "defines.deconstruction_item.entity_filter_mode",
        "mode": "[RW]",
        "doc": "The blacklist/whitelist entity filter mode for this deconstruction item.",
        "short": "The blacklist/whitelist entity filter mode for this deconstruction item.",
        "member": "entity_filter_mode  ::defines.deconstruction_item.entity_filter_mode Read/Write"
      },
      "tile_filter_mode": {
        "name": "tile_filter_mode",
        "type": "defines.deconstruction_item.tile_filter_mode",
        "mode": "[RW]",
        "doc": "The blacklist/whitelist tile filter mode for this deconstruction item.",
        "short": "The blacklist/whitelist tile filter mode for this deconstruction item.",
        "member": "tile_filter_mode  ::defines.deconstruction_item.tile_filter_mode Read/Write"
      },
      "tile_selection_mode": {
        "name": "tile_selection_mode",
        "type": "defines.deconstruction_item.tile_selection_mode",
        "mode": "[RW]",
        "doc": "The tile selection mode for this deconstruction item.",
        "short": "The tile selection mode for this deconstruction item.",
        "member": "tile_selection_mode  ::defines.deconstruction_item.tile_selection_mode Read/Write"
      },
      "trees_and_rocks_only": {
        "name": "trees_and_rocks_only",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If this deconstruction item is set to allow trees and rocks only.",
        "short": "If this deconstruction item is set to allow trees and rocks only.",
        "member": "trees_and_rocks_only  ::boolean Read/Write"
      },
      "entity_filter_count": {
        "name": "entity_filter_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of entity filters this deconstruction item supports.",
        "short": "The number of entity filters this deconstruction item supports.",
        "member": "entity_filter_count  ::uint Read"
      },
      "tile_filter_count": {
        "name": "tile_filter_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of tile filters this deconstruction item supports.",
        "short": "The number of tile filters this deconstruction item supports.",
        "member": "tile_filter_count  ::uint Read"
      },
      "active_index": {
        "name": "active_index",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The active blueprint index for this blueprint book. nil if this blueprint book is empty.",
        "short": "The active blueprint index for this blueprint book. [...]",
        "member": "active_index  ::uint? Read/Write"
      },
      "item_number": {
        "name": "item_number",
        "type": "uint",
        "mode": "[R]",
        "doc": "The unique identifier for this item , if any. Note that this ID stays the same no matter where the item is moved to.",
        "short": "The unique identifier for this item , if any. [...]",
        "member": "item_number  ::uint? Read"
      },
      "connected_entity": {
        "name": "connected_entity",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "If this item is a spidertron remote that has a spidertron bound to it, it returns the connected spider-vehicle entity.",
        "short": "If this item is a spidertron remote that has a spidertron bound to it, it returns the connected spider-vehicle entity.",
        "member": "connected_entity  ::LuaEntity? Read/Write"
      },
      "entity_label": {
        "name": "entity_label",
        "type": "string",
        "mode": "[RW]",
        "doc": "If this is an item with entity data, get the stored entity label.",
        "short": "If this is an item with entity data, get the stored entity label.",
        "member": "entity_label  ::string? Read/Write"
      },
      "entity_color": {
        "name": "entity_color",
        "type": "Color",
        "mode": "[RW]",
        "doc": "If this is an item with entity data, get the stored entity color.",
        "short": "If this is an item with entity data, get the stored entity color.",
        "member": "entity_color  ::Color? Read/Write"
      },
      "is_blueprint": {
        "name": "is_blueprint",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a blueprint item.",
        "short": "If this is a blueprint item.",
        "member": "is_blueprint  ::boolean Read"
      },
      "is_blueprint_book": {
        "name": "is_blueprint_book",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a blueprint book item.",
        "short": "If this is a blueprint book item.",
        "member": "is_blueprint_book  ::boolean Read"
      },
      "is_module": {
        "name": "is_module",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a module item.",
        "short": "If this is a module item.",
        "member": "is_module  ::boolean Read"
      },
      "is_ammo": {
        "name": "is_ammo",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is an ammo item.",
        "short": "If this is an ammo item.",
        "member": "is_ammo  ::boolean Read"
      },
      "is_tool": {
        "name": "is_tool",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a tool item.",
        "short": "If this is a tool item.",
        "member": "is_tool  ::boolean Read"
      },
      "is_mining_tool": {
        "name": "is_mining_tool",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a mining tool item.",
        "short": "If this is a mining tool item.",
        "member": "is_mining_tool  ::boolean Read"
      },
      "is_armor": {
        "name": "is_armor",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is an armor item.",
        "short": "If this is an armor item.",
        "member": "is_armor  ::boolean Read"
      },
      "is_repair_tool": {
        "name": "is_repair_tool",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a repair tool item.",
        "short": "If this is a repair tool item.",
        "member": "is_repair_tool  ::boolean Read"
      },
      "is_item_with_label": {
        "name": "is_item_with_label",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is an item with label item.",
        "short": "If this is an item with label item.",
        "member": "is_item_with_label  ::boolean Read"
      },
      "is_item_with_inventory": {
        "name": "is_item_with_inventory",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is an item with inventory item.",
        "short": "If this is an item with inventory item.",
        "member": "is_item_with_inventory  ::boolean Read"
      },
      "is_item_with_entity_data": {
        "name": "is_item_with_entity_data",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is an item with entity data item.",
        "short": "If this is an item with entity data item.",
        "member": "is_item_with_entity_data  ::boolean Read"
      },
      "is_selection_tool": {
        "name": "is_selection_tool",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a selection tool item.",
        "short": "If this is a selection tool item.",
        "member": "is_selection_tool  ::boolean Read"
      },
      "is_item_with_tags": {
        "name": "is_item_with_tags",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is an item with tags item.",
        "short": "If this is an item with tags item.",
        "member": "is_item_with_tags  ::boolean Read"
      },
      "is_deconstruction_item": {
        "name": "is_deconstruction_item",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a deconstruction tool item.",
        "short": "If this is a deconstruction tool item.",
        "member": "is_deconstruction_item  ::boolean Read"
      },
      "is_upgrade_item": {
        "name": "is_upgrade_item",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this is a upgrade item.",
        "short": "If this is a upgrade item.",
        "member": "is_upgrade_item  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaLampControlBehavior": {
    "name": "LuaLampControlBehavior",
    "type": "LuaLampControlBehavior",
    "inherits": [
      "Inherited from LuaGenericOnOffControlBehavior: disabled, circuit_condition, logistic_condition, connect_to_logistic_network, valid, object_name, help",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "use_colors": {
        "name": "use_colors",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the lamp should set the color from the circuit network signals.",
        "short": "true if the lamp should set the color from the circuit network signals.",
        "member": "use_colors  ::boolean Read/Write"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[R]",
        "doc": "The color the lamp is showing, if any.",
        "short": "The color the lamp is showing, if any.",
        "member": "color  ::Color? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaLazyLoadedValue": {
    "name": "LuaLazyLoadedValue",
    "type": "LuaLazyLoadedValue",
    "inherits": [],
    "properties": {
      "get": {
        "name": "get",
        "type": "function",
        "doc": "Gets the value of this lazy loaded value.",
        "short": "Gets the value of this lazy loaded value.",
        "member": "get()  Any"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaLogisticCell": {
    "name": "LuaLogisticCell",
    "type": "LuaLogisticCell",
    "inherits": [],
    "properties": {
      "is_in_logistic_range": {
        "name": "is_in_logistic_range",
        "type": "function",
        "doc": "Is a given position within the logistic range of this cell?",
        "short": "Is a given position within the logistic range of this cell?",
        "member": "is_in_logistic_range(position)  boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          }
        }
      },
      "is_in_construction_range": {
        "name": "is_in_construction_range",
        "type": "function",
        "doc": "Is a given position within the construction range of this cell?",
        "short": "Is a given position within the construction range of this cell?",
        "member": "is_in_construction_range(position)  boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          }
        }
      },
      "is_neighbour_with": {
        "name": "is_neighbour_with",
        "type": "function",
        "doc": "Are two cells neighbours?",
        "short": "Are two cells neighbours?",
        "member": "is_neighbour_with(other)  boolean",
        "args": {
          "other": {
            "name": "other",
            "type": "LuaLogisticCell",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "logistic_radius": {
        "name": "logistic_radius",
        "type": "float",
        "mode": "[R]",
        "doc": "Logistic radius of this cell.",
        "short": "Logistic radius of this cell.",
        "member": "logistic_radius  ::float Read"
      },
      "logistics_connection_distance": {
        "name": "logistics_connection_distance",
        "type": "float",
        "mode": "[R]",
        "doc": "Logistic connection distance of this cell.",
        "short": "Logistic connection distance of this cell.",
        "member": "logistics_connection_distance  ::float Read"
      },
      "construction_radius": {
        "name": "construction_radius",
        "type": "float",
        "mode": "[R]",
        "doc": "Construction radius of this cell.",
        "short": "Construction radius of this cell.",
        "member": "construction_radius  ::float Read"
      },
      "stationed_logistic_robot_count": {
        "name": "stationed_logistic_robot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of stationed logistic robots in this cell.",
        "short": "Number of stationed logistic robots in this cell.",
        "member": "stationed_logistic_robot_count  ::uint Read"
      },
      "stationed_construction_robot_count": {
        "name": "stationed_construction_robot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of stationed construction robots in this cell.",
        "short": "Number of stationed construction robots in this cell.",
        "member": "stationed_construction_robot_count  ::uint Read"
      },
      "mobile": {
        "name": "mobile",
        "type": "boolean",
        "mode": "[R]",
        "doc": "true if this is a mobile cell. In vanilla, only the logistic cell created by a character's personal roboport is mobile.",
        "short": "true if this is a mobile cell. [...]",
        "member": "mobile  ::boolean Read"
      },
      "transmitting": {
        "name": "transmitting",
        "type": "boolean",
        "mode": "[R]",
        "doc": "true if this cell is active.",
        "short": "true if this cell is active.",
        "member": "transmitting  ::boolean Read"
      },
      "charge_approach_distance": {
        "name": "charge_approach_distance",
        "type": "float",
        "mode": "[R]",
        "doc": "Radius at which the robots hover when waiting to be charged.",
        "short": "Radius at which the robots hover when waiting to be charged.",
        "member": "charge_approach_distance  ::float Read"
      },
      "charging_robot_count": {
        "name": "charging_robot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of robots currently charging.",
        "short": "Number of robots currently charging.",
        "member": "charging_robot_count  ::uint Read"
      },
      "to_charge_robot_count": {
        "name": "to_charge_robot_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of robots waiting to charge.",
        "short": "Number of robots waiting to charge.",
        "member": "to_charge_robot_count  ::uint Read"
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "This cell's owner.",
        "short": "This cell's owner.",
        "member": "owner  ::LuaEntity Read"
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[R]",
        "doc": "The network that owns this cell, if any.",
        "short": "The network that owns this cell, if any.",
        "member": "logistic_network  ::LuaLogisticNetwork? Read"
      },
      "neighbours": {
        "name": "neighbours",
        "type": "LuaLogisticCell",
        "mode": "[R]",
        "doc": "Neighbouring cells.",
        "short": "Neighbouring cells.",
        "member": "neighbours  ::array[LuaLogisticCell] Read"
      },
      "charging_robots": {
        "name": "charging_robots",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "Robots currently being charged.",
        "short": "Robots currently being charged.",
        "member": "charging_robots  ::array[LuaEntity] Read"
      },
      "to_charge_robots": {
        "name": "to_charge_robots",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "Robots waiting to charge.",
        "short": "Robots waiting to charge.",
        "member": "to_charge_robots  ::array[LuaEntity] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaLogisticContainerControlBehavior": {
    "name": "LuaLogisticContainerControlBehavior",
    "type": "LuaLogisticContainerControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "circuit_mode_of_operation": {
        "name": "circuit_mode_of_operation",
        "type": "defines.control_behavior.logistic_container.circuit_mode_of_operation",
        "mode": "[RW]",
        "doc": "The circuit mode of operations for the logistic container. Can only be set on containers whose logistic_mode is set to \"requester\".",
        "short": "The circuit mode of operations for the logistic container. [...]",
        "member": "circuit_mode_of_operation  ::defines.control_behavior.logistic_container.circuit_mode_of_operation Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaLogisticNetwork": {
    "name": "LuaLogisticNetwork",
    "type": "LuaLogisticNetwork",
    "inherits": [],
    "properties": {
      "get_item_count": {
        "name": "get_item_count",
        "type": "function",
        "doc": "Count given or all items in the network or given members.",
        "short": "Count given or all items in the network or given members.",
        "member": "get_item_count(item?, member?)  int",
        "args": {
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "Item name to count. If not given, gives counts of all items in the network."
          },
          "member": {
            "name": "member",
            "type": "\"storage\" or \"providers\"?",
            "doc": "Logistic members to check. If not given, gives count in the entire network."
          }
        }
      },
      "get_contents": {
        "name": "get_contents",
        "type": "function",
        "doc": "Get item counts for the entire network, similar to how LuaInventory::get_contents does. Returns: A mapping of item prototype names to the number available in the network.",
        "short": "Get item counts for the entire network, similar to how LuaInventory::get_contents does.",
        "member": "get_contents()  dictionary[string uint]",
        "returns": "dictionary[string uint]"
      },
      "remove_item": {
        "name": "remove_item",
        "type": "function",
        "doc": "Remove items from the logistic network. This will actually remove the items from some logistic chests. Returns: Number of items removed.",
        "short": "Remove items from the logistic network. [...]",
        "member": "remove_item(item, members?)  uint",
        "returns": "uint",
        "args": {
          "item": {
            "name": "item",
            "type": "ItemStackIdentification",
            "doc": "What to remove."
          },
          "members": {
            "name": "members",
            "type": "\"active-provider\" or \"passive-provider\" or \"buffer\" or \"storage\"?",
            "doc": "Which logistic members to remove from. If not specified, removes from the network in the usual order."
          }
        }
      },
      "insert": {
        "name": "insert",
        "type": "function",
        "doc": "Insert items into the logistic network. This will actually insert the items into some logistic chests. Returns: Number of items actually inserted.",
        "short": "Insert items into the logistic network. [...]",
        "member": "insert(item, members?)  uint",
        "returns": "uint",
        "args": {
          "item": {
            "name": "item",
            "type": "ItemStackIdentification",
            "doc": "What to insert."
          },
          "members": {
            "name": "members",
            "type": "\"storage\" or \"storage-empty\" or \"storage-empty-slot\" or \"requester\"?",
            "doc": "Which logistic members to insert the items to. \"storage-empty\" inserts into storage chests that are completely empty, \"storage-empty-slot\" inserts into storage chests that have an empty slot. If not specified, inserts items into the logistic network in the usual order."
          }
        }
      },
      "find_cell_closest_to": {
        "name": "find_cell_closest_to",
        "type": "function",
        "doc": "Find logistic cell closest to a given position. Returns: nil if no cell was found.",
        "short": "Find logistic cell closest to a given position.",
        "member": "find_cell_closest_to(position)  LuaLogisticCell?",
        "returns": "LuaLogisticCell?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          }
        }
      },
      "select_pickup_point": {
        "name": "select_pickup_point",
        "type": "LuaLogisticPoint",
        "doc": "Find the 'best' logistic point with this item ID and from the given position or from given chest type. Returns: nil if no point was found.",
        "short": "Find the 'best' logistic point with this item ID and from the given position or from given chest type.",
        "member": "select_pickup_point{name=, position?=, include_buffers?=, members?=}  LuaLogisticPoint?",
        "returns": "LuaLogisticPoint?",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the item to pick up."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "When given, it will find the storage 'best' storage point from this position."
          },
          "include_buffers": {
            "name": "include_buffers",
            "type": "boolean?",
            "doc": "Whether to consider buffer chests or not. Defaults to false. Only considered if selecting with position."
          },
          "members": {
            "name": "members",
            "type": "\"active-provider\" or \"passive-provider\" or \"buffer\" or \"storage\"?",
            "doc": "When given, it will find from only the specific type of member. If not specified, selects with normal priorities. Not considered if position is specified."
          }
        }
      },
      "select_drop_point": {
        "name": "select_drop_point",
        "type": "LuaLogisticPoint",
        "doc": "Find a logistic point to drop the specific item stack. Returns: nil if no point was found.",
        "short": "Find a logistic point to drop the specific item stack.",
        "member": "select_drop_point{stack=, members?=}  LuaLogisticPoint?",
        "returns": "LuaLogisticPoint?",
        "args": {
          "stack": {
            "name": "stack",
            "type": "ItemStackIdentification",
            "doc": "Name of the item to drop off."
          },
          "members": {
            "name": "members",
            "type": "\"storage\" or \"storage-empty\" or \"storage-empty-slot\" or \"requester\"?",
            "doc": "When given, it will find from only the specific type of member. If not specified, selects with normal priorities."
          }
        }
      },
      "can_satisfy_request": {
        "name": "can_satisfy_request",
        "type": "function",
        "doc": "Can the network satisfy a request for a given item and count. Returns: Whether the network can satisfy the request.",
        "short": "Can the network satisfy a request for a given item and count.",
        "member": "can_satisfy_request(item, count?, include_buffers?)  boolean",
        "returns": "boolean",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "Item name to check."
          },
          "count": {
            "name": "count",
            "type": "uint?",
            "doc": "Count to check. Defaults to 1."
          },
          "include_buffers": {
            "name": "include_buffers",
            "type": "boolean?",
            "doc": "Should buffers be considered? Defaults to false."
          }
        }
      },
      "get_supply_counts": {
        "name": "get_supply_counts",
        "type": "function",
        "doc": "Get the amount of items of the given type indexed by the storage member.",
        "short": "Get the amount of items of the given type indexed by the storage member.",
        "member": "get_supply_counts(item)  LogisticsNetworkSupplyCounts",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "Item name to check."
          }
        }
      },
      "get_supply_points": {
        "name": "get_supply_points",
        "type": "function",
        "doc": "Gets the logistic points with of the given type indexed by the storage member.",
        "short": "Gets the logistic points with of the given type indexed by the storage member.",
        "member": "get_supply_points(item)  LogisticsNetworkSupplyPoints",
        "args": {
          "item": {
            "name": "item",
            "type": "string",
            "doc": "Item name to check."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force this logistic network belongs to.",
        "short": "The force this logistic network belongs to.",
        "member": "force  ::LuaForce Read"
      },
      "available_logistic_robots": {
        "name": "available_logistic_robots",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of logistic robots available for a job.",
        "short": "Number of logistic robots available for a job.",
        "member": "available_logistic_robots  ::uint Read"
      },
      "all_logistic_robots": {
        "name": "all_logistic_robots",
        "type": "uint",
        "mode": "[R]",
        "doc": "The total number of logistic robots in the network (idle and active + in roboports).",
        "short": "The total number of logistic robots in the network (idle and active + in roboports).",
        "member": "all_logistic_robots  ::uint Read"
      },
      "available_construction_robots": {
        "name": "available_construction_robots",
        "type": "uint",
        "mode": "[R]",
        "doc": "Number of construction robots available for a job.",
        "short": "Number of construction robots available for a job.",
        "member": "available_construction_robots  ::uint Read"
      },
      "all_construction_robots": {
        "name": "all_construction_robots",
        "type": "uint",
        "mode": "[R]",
        "doc": "The total number of construction robots in the network (idle and active + in roboports).",
        "short": "The total number of construction robots in the network (idle and active + in roboports).",
        "member": "all_construction_robots  ::uint Read"
      },
      "robot_limit": {
        "name": "robot_limit",
        "type": "uint",
        "mode": "[R]",
        "doc": "Maximum number of robots the network can work with. Currently only used for the personal roboport.",
        "short": "Maximum number of robots the network can work with. [...]",
        "member": "robot_limit  ::uint Read"
      },
      "cells": {
        "name": "cells",
        "type": "LuaLogisticCell",
        "mode": "[R]",
        "doc": "All cells in this network.",
        "short": "All cells in this network.",
        "member": "cells  ::array[LuaLogisticCell] Read"
      },
      "providers": {
        "name": "providers",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All entities that have logistic provider points in this network.",
        "short": "All entities that have logistic provider points in this network.",
        "member": "providers  ::array[LuaEntity] Read"
      },
      "empty_providers": {
        "name": "empty_providers",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All entities that have empty logistic provider points in this network.",
        "short": "All entities that have empty logistic provider points in this network.",
        "member": "empty_providers  ::array[LuaEntity] Read"
      },
      "requesters": {
        "name": "requesters",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All entities that have logistic requester points in this network.",
        "short": "All entities that have logistic requester points in this network.",
        "member": "requesters  ::array[LuaEntity] Read"
      },
      "storages": {
        "name": "storages",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All entities that have logistic storage points in this network.",
        "short": "All entities that have logistic storage points in this network.",
        "member": "storages  ::array[LuaEntity] Read"
      },
      "logistic_members": {
        "name": "logistic_members",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All other entities that have logistic points in this network (inserters mostly).",
        "short": "All other entities that have logistic points in this network (inserters mostly).",
        "member": "logistic_members  ::array[LuaEntity] Read"
      },
      "provider_points": {
        "name": "provider_points",
        "type": "LuaLogisticPoint",
        "mode": "[R]",
        "doc": "All things that have provider points in this network.",
        "short": "All things that have provider points in this network.",
        "member": "provider_points  ::array[LuaLogisticPoint] Read"
      },
      "passive_provider_points": {
        "name": "passive_provider_points",
        "type": "LuaLogisticPoint",
        "mode": "[R]",
        "doc": "All passive provider points in this network.",
        "short": "All passive provider points in this network.",
        "member": "passive_provider_points  ::array[LuaLogisticPoint] Read"
      },
      "active_provider_points": {
        "name": "active_provider_points",
        "type": "LuaLogisticPoint",
        "mode": "[R]",
        "doc": "All active provider points in this network.",
        "short": "All active provider points in this network.",
        "member": "active_provider_points  ::array[LuaLogisticPoint] Read"
      },
      "empty_provider_points": {
        "name": "empty_provider_points",
        "type": "LuaLogisticPoint",
        "mode": "[R]",
        "doc": "All things that have empty provider points in this network.",
        "short": "All things that have empty provider points in this network.",
        "member": "empty_provider_points  ::array[LuaLogisticPoint] Read"
      },
      "requester_points": {
        "name": "requester_points",
        "type": "LuaLogisticPoint",
        "mode": "[R]",
        "doc": "All things that have requester points in this network.",
        "short": "All things that have requester points in this network.",
        "member": "requester_points  ::array[LuaLogisticPoint] Read"
      },
      "storage_points": {
        "name": "storage_points",
        "type": "LuaLogisticPoint",
        "mode": "[R]",
        "doc": "All things that have storage points in this network.",
        "short": "All things that have storage points in this network.",
        "member": "storage_points  ::array[LuaLogisticPoint] Read"
      },
      "robots": {
        "name": "robots",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All robots in this logistic network.",
        "short": "All robots in this logistic network.",
        "member": "robots  ::array[LuaEntity] Read"
      },
      "construction_robots": {
        "name": "construction_robots",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All construction robots in this logistic network.",
        "short": "All construction robots in this logistic network.",
        "member": "construction_robots  ::array[LuaEntity] Read"
      },
      "logistic_robots": {
        "name": "logistic_robots",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "All logistic robots in this logistic network.",
        "short": "All logistic robots in this logistic network.",
        "member": "logistic_robots  ::array[LuaEntity] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaLogisticPoint": {
    "name": "LuaLogisticPoint",
    "type": "LuaLogisticPoint",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The LuaEntity owner of this LuaLogisticPoint.",
        "short": "The LuaEntity owner of this LuaLogisticPoint.",
        "member": "owner  ::LuaEntity Read"
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[R]",
        "member": "logistic_network  ::LuaLogisticNetwork Read"
      },
      "logistic_member_index": {
        "name": "logistic_member_index",
        "type": "uint",
        "mode": "[R]",
        "doc": "The Logistic member index of this logistic point.",
        "short": "The Logistic member index of this logistic point.",
        "member": "logistic_member_index  ::uint Read"
      },
      "filters": {
        "name": "filters",
        "type": "LogisticFilter",
        "mode": "[R]",
        "doc": "The logistic filters for this logistic point, if this uses any.",
        "short": "The logistic filters for this logistic point, if this uses any.",
        "member": "filters  ::array[LogisticFilter]? Read"
      },
      "mode": {
        "name": "mode",
        "type": "defines.logistic_mode",
        "mode": "[R]",
        "doc": "The logistic mode.",
        "short": "The logistic mode.",
        "member": "mode  ::defines.logistic_mode Read"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force of this logistic point.",
        "short": "The force of this logistic point.",
        "member": "force  ::LuaForce Read"
      },
      "targeted_items_pickup": {
        "name": "targeted_items_pickup",
        "type": "string",
        "mode": "[R]",
        "doc": "Items targeted to be picked up from this logistic point by robots. The attribute is a dictionary mapping the item prototype names to their item counts.",
        "short": "Items targeted to be picked up from this logistic point by robots. [...]",
        "member": "targeted_items_pickup  ::dictionary[string uint] Read"
      },
      "targeted_items_deliver": {
        "name": "targeted_items_deliver",
        "type": "string",
        "mode": "[R]",
        "doc": "Items targeted to be dropped off into this logistic point by robots. The attribute is a dictionary mapping the item prototype names to their item counts.",
        "short": "Items targeted to be dropped off into this logistic point by robots. [...]",
        "member": "targeted_items_deliver  ::dictionary[string uint] Read"
      },
      "exact": {
        "name": "exact",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this logistic point is using the exact mode. In exact mode robots never over-deliver requests.",
        "short": "If this logistic point is using the exact mode. [...]",
        "member": "exact  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaMiningDrillControlBehavior": {
    "name": "LuaMiningDrillControlBehavior",
    "type": "LuaMiningDrillControlBehavior",
    "inherits": [
      "Inherited from LuaGenericOnOffControlBehavior: disabled, circuit_condition, logistic_condition, connect_to_logistic_network, valid, object_name, help",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "circuit_enable_disable": {
        "name": "circuit_enable_disable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if this drill is enabled or disabled using the logistics or circuit condition.",
        "short": "true if this drill is enabled or disabled using the logistics or circuit condition.",
        "member": "circuit_enable_disable  ::boolean Read/Write"
      },
      "circuit_read_resources": {
        "name": "circuit_read_resources",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if this drill should send the resources in the field to the circuit network. Which resources depends on LuaMiningDrillControlBehavior::resource_read_mode",
        "short": "true if this drill should send the resources in the field to the circuit network. [...]",
        "member": "circuit_read_resources  ::boolean Read/Write"
      },
      "resource_read_mode": {
        "name": "resource_read_mode",
        "type": "defines.control_behavior.mining_drill.resource_read_mode",
        "mode": "[RW]",
        "doc": "If the mining drill should send just the resources in its area or the entire field it's on to the circuit network.",
        "short": "If the mining drill should send just the resources in its area or the entire field it's on to the circuit network.",
        "member": "resource_read_mode  ::defines.control_behavior.mining_drill.resource_read_mode Read/Write"
      },
      "resource_read_targets": {
        "name": "resource_read_targets",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The resource entities that the mining drill will send information about to the circuit network or an empty array.",
        "short": "The resource entities that the mining drill will send information about to the circuit network or an empty array.",
        "member": "resource_read_targets  ::array[LuaEntity] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaModSettingPrototype": {
    "name": "LuaModSettingPrototype",
    "type": "LuaModSettingPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[R]",
        "doc": "Type of this prototype.",
        "short": "Type of this prototype.",
        "member": "type  ::string Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "mod": {
        "name": "mod",
        "type": "string",
        "mode": "[R]",
        "doc": "The mod that owns this setting.",
        "short": "The mod that owns this setting.",
        "member": "mod  ::string Read"
      },
      "setting_type": {
        "name": "setting_type",
        "type": "string",
        "mode": "[R]",
        "member": "setting_type  ::string Read"
      },
      "default_value": {
        "name": "default_value",
        "type": "boolean",
        "mode": "[R]",
        "doc": "The default value of this setting.",
        "short": "The default value of this setting.",
        "member": "default_value  ::boolean or double or int or string Read"
      },
      "minimum_value": {
        "name": "minimum_value",
        "type": "double",
        "mode": "[R]",
        "doc": "The minimum value for this setting. nil if this setting type doesn't support a minimum.",
        "short": "The minimum value for this setting. [...]",
        "member": "minimum_value  ::double or int? Read"
      },
      "maximum_value": {
        "name": "maximum_value",
        "type": "double",
        "mode": "[R]",
        "doc": "The maximum value for this setting. nil if this setting type doesn't support a maximum.",
        "short": "The maximum value for this setting. [...]",
        "member": "maximum_value  ::double or int? Read"
      },
      "allowed_values": {
        "name": "allowed_values",
        "type": "string",
        "mode": "[R]",
        "doc": "The allowed values for this setting. nil if this setting doesn't use the a fixed set of values.",
        "short": "The allowed values for this setting. [...]",
        "member": "allowed_values  ::array[string] or array[int] or array[double]? Read"
      },
      "allow_blank": {
        "name": "allow_blank",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this string setting allows blank values. nil if not a string setting.",
        "short": "Whether this string setting allows blank values. [...]",
        "member": "allow_blank  ::boolean? Read"
      },
      "auto_trim": {
        "name": "auto_trim",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this string setting auto-trims values. nil if not a string setting",
        "short": "Whether this string setting auto-trims values. [...]",
        "member": "auto_trim  ::boolean? Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this setting is hidden from the GUI.",
        "short": "Whether this setting is hidden from the GUI.",
        "member": "hidden  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaModuleCategoryPrototype": {
    "name": "LuaModuleCategoryPrototype",
    "type": "LuaModuleCategoryPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaNamedNoiseExpression": {
    "name": "LuaNamedNoiseExpression",
    "type": "LuaNamedNoiseExpression",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "intended_property": {
        "name": "intended_property",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the property that this expression is intended to provide a value for, if any.",
        "short": "Name of the property that this expression is intended to provide a value for, if any.",
        "member": "intended_property  ::string Read"
      },
      "expression": {
        "name": "expression",
        "type": "NoiseExpression",
        "mode": "[R]",
        "doc": "The expression itself.",
        "short": "The expression itself.",
        "member": "expression  ::NoiseExpression Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaNoiseLayerPrototype": {
    "name": "LuaNoiseLayerPrototype",
    "type": "LuaNoiseLayerPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaParticlePrototype": {
    "name": "LuaParticlePrototype",
    "type": "LuaParticlePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "regular_trigger_effect": {
        "name": "regular_trigger_effect",
        "type": "TriggerEffectItem",
        "mode": "[R]",
        "member": "regular_trigger_effect  ::TriggerEffectItem Read"
      },
      "ended_in_water_trigger_effect": {
        "name": "ended_in_water_trigger_effect",
        "type": "TriggerEffectItem",
        "mode": "[R]",
        "member": "ended_in_water_trigger_effect  ::TriggerEffectItem Read"
      },
      "render_layer": {
        "name": "render_layer",
        "type": "RenderLayer",
        "mode": "[R]",
        "member": "render_layer  ::RenderLayer Read"
      },
      "render_layer_when_on_ground": {
        "name": "render_layer_when_on_ground",
        "type": "RenderLayer",
        "mode": "[R]",
        "member": "render_layer_when_on_ground  ::RenderLayer Read"
      },
      "life_time": {
        "name": "life_time",
        "type": "uint",
        "mode": "[R]",
        "member": "life_time  ::uint Read"
      },
      "regular_trigger_effect_frequency": {
        "name": "regular_trigger_effect_frequency",
        "type": "uint",
        "mode": "[R]",
        "member": "regular_trigger_effect_frequency  ::uint Read"
      },
      "movement_modifier_when_on_ground": {
        "name": "movement_modifier_when_on_ground",
        "type": "float",
        "mode": "[R]",
        "member": "movement_modifier_when_on_ground  ::float Read"
      },
      "movement_modifier": {
        "name": "movement_modifier",
        "type": "float",
        "mode": "[R]",
        "member": "movement_modifier  ::float Read"
      },
      "mining_particle_frame_speed": {
        "name": "mining_particle_frame_speed",
        "type": "float",
        "mode": "[R]",
        "member": "mining_particle_frame_speed  ::float Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaPermissionGroup": {
    "name": "LuaPermissionGroup",
    "type": "LuaPermissionGroup",
    "inherits": [],
    "properties": {
      "add_player": {
        "name": "add_player",
        "type": "function",
        "doc": "Adds the given player to this group. Returns: Whether the player was added.",
        "short": "Adds the given player to this group.",
        "member": "add_player(player)  boolean",
        "returns": "boolean",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": ""
          }
        }
      },
      "remove_player": {
        "name": "remove_player",
        "type": "function",
        "doc": "Removes the given player from this group. Returns: Whether the player was removed.",
        "short": "Removes the given player from this group.",
        "member": "remove_player(player)  boolean",
        "returns": "boolean",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": ""
          }
        }
      },
      "allows_action": {
        "name": "allows_action",
        "type": "function",
        "doc": "Whether this group allows the given action.",
        "short": "Whether this group allows the given action.",
        "member": "allows_action(action)  boolean",
        "args": {
          "action": {
            "name": "action",
            "type": "defines.input_action",
            "doc": "The action in question."
          }
        }
      },
      "set_allows_action": {
        "name": "set_allows_action",
        "type": "function",
        "doc": "Sets whether this group allows the performance the given action. Returns: Whether the value was successfully applied.",
        "short": "Sets whether this group allows the performance the given action.",
        "member": "set_allows_action(action, allow_action)  boolean",
        "returns": "boolean",
        "args": {
          "action": {
            "name": "action",
            "type": "defines.input_action",
            "doc": "The action in question."
          },
          "allow_action": {
            "name": "allow_action",
            "type": "boolean",
            "doc": "Whether to allow the specified action."
          }
        }
      },
      "destroy": {
        "name": "destroy",
        "type": "function",
        "doc": "Destroys this group. Returns: Whether the group was successfully destroyed.",
        "short": "Destroys this group.",
        "member": "destroy()  boolean",
        "returns": "boolean"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[RW]",
        "doc": "The name of this group.",
        "short": "The name of this group.",
        "member": "name  ::string Read/Write"
      },
      "players": {
        "name": "players",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The players in this group.",
        "short": "The players in this group.",
        "member": "players  ::array[LuaPlayer] Read"
      },
      "group_id": {
        "name": "group_id",
        "type": "uint",
        "mode": "[R]",
        "doc": "The group ID",
        "short": "The group ID",
        "member": "group_id  ::uint Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaPermissionGroups": {
    "name": "LuaPermissionGroups",
    "type": "LuaPermissionGroups",
    "inherits": [],
    "properties": {
      "create_group": {
        "name": "create_group",
        "type": "function",
        "doc": "Creates a new permission group. Returns: nil if the calling player doesn't have permission to make groups.",
        "short": "Creates a new permission group.",
        "member": "create_group(name?)  LuaPermissionGroup?",
        "returns": "LuaPermissionGroup?",
        "args": {
          "name": {
            "name": "name",
            "type": "string?",
            "doc": ""
          }
        }
      },
      "get_group": {
        "name": "get_group",
        "type": "function",
        "doc": "Gets the permission group with the given name or group ID. Returns: nil if there is no matching group.",
        "short": "Gets the permission group with the given name or group ID.",
        "member": "get_group(group)  LuaPermissionGroup?",
        "returns": "LuaPermissionGroup?",
        "args": {
          "group": {
            "name": "group",
            "type": "string or uint",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "groups": {
        "name": "groups",
        "type": "LuaPermissionGroup",
        "mode": "[R]",
        "doc": "All of the permission groups.",
        "short": "All of the permission groups.",
        "member": "groups  ::array[LuaPermissionGroup] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaPlayer": {
    "name": "LuaPlayer",
    "type": "LuaPlayer",
    "inherits": [
      "Inherited from LuaControl: surface, surface_index, position, vehicle, force, force_index, selected, opened, crafting_queue_size, crafting_queue_progress, walking_state, riding_state, mining_state, shooting_state, picking_state, repair_state, cursor_stack, cursor_ghost, driving, crafting_queue, following_robots, cheat_mode, character_crafting_speed_modifier, character_mining_speed_modifier, character_additional_mining_categories, character_running_speed_modifier, character_build_distance_bonus, character_item_drop_distance_bonus, character_reach_distance_bonus, character_resource_reach_distance_bonus, character_item_pickup_distance_bonus, character_loot_pickup_distance_bonus, character_inventory_slots_bonus, character_trash_slot_count_bonus, character_maximum_following_robot_count_bonus, character_health_bonus, character_personal_logistic_requests_enabled, vehicle_logistic_requests_enabled, opened_gui_type, build_distance, drop_item_distance, reach_distance, item_pickup_distance, loot_pickup_distance, resource_reach_distance, in_combat, character_running_speed, character_mining_progress, get_inventory, get_max_inventory_index, get_main_inventory, can_insert, insert, set_gui_arrow, clear_gui_arrow, get_item_count, has_items_inside, can_reach_entity, clear_items_inside, remove_item, teleport, update_selected_entity, clear_selected_entity, disable_flashlight, enable_flashlight, is_flashlight_enabled, get_craftable_count, begin_crafting, cancel_crafting, mine_entity, mine_tile, is_player, open_technology_gui, set_personal_logistic_slot, set_vehicle_logistic_slot, get_personal_logistic_slot, get_vehicle_logistic_slot, clear_personal_logistic_slot, clear_vehicle_logistic_slot, is_cursor_blueprint, get_blueprint_entities, is_cursor_empty"
    ],
    "properties": {
      "set_ending_screen_data": {
        "name": "set_ending_screen_data",
        "doc": "Setup the screen to be shown when the game is finished.",
        "short": "Setup the screen to be shown when the game is finished.",
        "member": "set_ending_screen_data(message, file?)",
        "type": "function",
        "args": {
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": "Message to be shown."
          },
          "file": {
            "name": "file",
            "type": "string?",
            "doc": "Path to image to be shown."
          }
        }
      },
      "print": {
        "name": "print",
        "doc": "Print text to the chat console.",
        "short": "Print text to the chat console.",
        "member": "print(message, print_settings?)",
        "type": "function",
        "args": {
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": ""
          },
          "print_settings": {
            "name": "print_settings",
            "type": "Color or PrintSettings?",
            "doc": ""
          }
        }
      },
      "clear_console": {
        "name": "clear_console",
        "doc": "Clear the chat console.",
        "short": "Clear the chat console.",
        "member": "clear_console()",
        "type": "function"
      },
      "get_goal_description": {
        "name": "get_goal_description",
        "type": "function",
        "doc": "Get the current goal description, as a localised string.",
        "short": "Get the current goal description, as a localised string.",
        "member": "get_goal_description()  LocalisedString"
      },
      "set_goal_description": {
        "name": "set_goal_description",
        "doc": "Set the text in the goal window (top left).",
        "short": "Set the text in the goal window (top left).",
        "member": "set_goal_description(text?, only_update?)",
        "type": "function",
        "args": {
          "text": {
            "name": "text",
            "type": "LocalisedString?",
            "doc": "The text to display. Lines can be delimited with \\n. Passing an empty string or omitting this parameter entirely will make the goal window disappear."
          },
          "only_update": {
            "name": "only_update",
            "type": "boolean?",
            "doc": "When true, won't play the \"goal updated\" sound."
          }
        }
      },
      "set_controller": {
        "name": "set_controller",
        "doc": "Set the controller type of the player.",
        "short": "Set the controller type of the player.",
        "member": "set_controller{type=, character?=, waypoints?=, start_position?=, start_zoom?=, final_transition_time?=, chart_mode_cutoff?=}",
        "args": {
          "type": {
            "name": "type",
            "type": "defines.controllers",
            "doc": "Which controller to use."
          },
          "character": {
            "name": "character",
            "type": "LuaEntity?",
            "doc": "Entity to control. Mandatory when type is defines.controllers.character, ignored otherwise."
          },
          "waypoints": {
            "name": "waypoints",
            "type": "CutsceneWaypoint?",
            "doc": "List of waypoints for the cutscene controller. This parameter is mandatory when type is defines.controllers.cutscene."
          },
          "start_position": {
            "name": "start_position",
            "type": "MapPosition?",
            "doc": "If specified and type is defines.controllers.cutscene, the cutscene will start at this position. If not given the start position will be the player position."
          },
          "start_zoom": {
            "name": "start_zoom",
            "type": "double?",
            "doc": "If specified and type is defines.controllers.cutscene, the cutscene will start at this zoom level. If not given the start zoom will be the players zoom."
          },
          "final_transition_time": {
            "name": "final_transition_time",
            "type": "uint?",
            "doc": "If specified and type is defines.controllers.cutscene, it is the time in ticks it will take for the camera to pan from the final waypoint back to the starting position. If not given the camera will not pan back to the start position/zoom."
          },
          "chart_mode_cutoff": {
            "name": "chart_mode_cutoff",
            "type": "double?",
            "doc": "If specified and type is defines.controllers.cutscene, the game will switch to chart-mode (map zoomed out) rendering when the zoom level is less than this value."
          }
        }
      },
      "drag_wire": {
        "name": "drag_wire",
        "type": "boolean",
        "doc": "Start/end wire dragging at the specified location, wire type is based on the cursor contents Returns: true if the action did something",
        "short": "Start/end wire dragging at the specified location, wire type is based on the cursor contents",
        "member": "drag_wire{position=}  boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Position at which cursor was clicked. Used only to decide which side of arithmetic combinator, decider combinator or power switch is to be connected. Entity itself to be connected is based on the player's selected entity."
          }
        }
      },
      "disable_recipe_groups": {
        "name": "disable_recipe_groups",
        "doc": "Disable recipe groups.",
        "short": "Disable recipe groups.",
        "member": "disable_recipe_groups()",
        "type": "function"
      },
      "enable_recipe_groups": {
        "name": "enable_recipe_groups",
        "doc": "Enable recipe groups.",
        "short": "Enable recipe groups.",
        "member": "enable_recipe_groups()",
        "type": "function"
      },
      "disable_recipe_subgroups": {
        "name": "disable_recipe_subgroups",
        "doc": "Disable recipe subgroups.",
        "short": "Disable recipe subgroups.",
        "member": "disable_recipe_subgroups()",
        "type": "function"
      },
      "enable_recipe_subgroups": {
        "name": "enable_recipe_subgroups",
        "doc": "Enable recipe subgroups.",
        "short": "Enable recipe subgroups.",
        "member": "enable_recipe_subgroups()",
        "type": "function"
      },
      "print_entity_statistics": {
        "name": "print_entity_statistics",
        "doc": "Print entity statistics to the player's console.",
        "short": "Print entity statistics to the player's console.",
        "member": "print_entity_statistics(entities?)",
        "type": "function",
        "args": {
          "entities": {
            "name": "entities",
            "type": "array[string]?",
            "doc": "Entity prototypes to get statistics for. If not specified or empty, display statistics for all entities."
          }
        }
      },
      "print_robot_jobs": {
        "name": "print_robot_jobs",
        "doc": "Print construction robot job counts to the players console.",
        "short": "Print construction robot job counts to the players console.",
        "member": "print_robot_jobs()",
        "type": "function"
      },
      "print_lua_object_statistics": {
        "name": "print_lua_object_statistics",
        "doc": "Print LuaObject counts per mod.",
        "short": "Print LuaObject counts per mod.",
        "member": "print_lua_object_statistics()",
        "type": "function"
      },
      "log_active_entity_chunk_counts": {
        "name": "log_active_entity_chunk_counts",
        "doc": "Logs a dictionary of chunks -> active entities for the surface this player is on.",
        "short": "Logs a dictionary of chunks -> active entities for the surface this player is on.",
        "member": "log_active_entity_chunk_counts()",
        "type": "function"
      },
      "log_active_entity_counts": {
        "name": "log_active_entity_counts",
        "doc": "Logs a dictionary of active entities -> count for the surface this player is on.",
        "short": "Logs a dictionary of active entities -> count for the surface this player is on.",
        "member": "log_active_entity_counts()",
        "type": "function"
      },
      "unlock_achievement": {
        "name": "unlock_achievement",
        "doc": "Unlock the achievements of the given player. This has any effect only when this is the local player, the achievement isn't unlocked so far and the achievement is of the type \"achievement\".",
        "short": "Unlock the achievements of the given player. [...]",
        "member": "unlock_achievement(name)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "name of the achievement to unlock"
          }
        }
      },
      "clear_cursor": {
        "name": "clear_cursor",
        "type": "function",
        "doc": "Invokes the \"clear cursor\" action on the player as if the user pressed it. Returns: Whether the cursor is now empty.",
        "short": "Invokes the \"clear cursor\" action on the player as if the user pressed it.",
        "member": "clear_cursor()  boolean",
        "returns": "boolean",
        "args": {
          "on_player_cursor_stack_changed?": {
            "name": "on_player_cursor_stack_changed?",
            "doc": "Raised when the cursor was successfully cleared."
          }
        }
      },
      "create_character": {
        "name": "create_character",
        "type": "function",
        "doc": "Creates and attaches a character entity to this player. Returns: Whether the character was created.",
        "short": "Creates and attaches a character entity to this player.",
        "member": "create_character(character?)  boolean",
        "returns": "boolean",
        "args": {
          "character": {
            "name": "character",
            "type": "string?",
            "doc": "The character to create else the default is used."
          }
        }
      },
      "add_alert": {
        "name": "add_alert",
        "doc": "Adds an alert to this player for the given entity of the given alert type.",
        "short": "Adds an alert to this player for the given entity of the given alert type.",
        "member": "add_alert(entity, type)",
        "type": "function",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": ""
          },
          "type": {
            "name": "type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "add_custom_alert": {
        "name": "add_custom_alert",
        "doc": "Adds a custom alert to this player.",
        "short": "Adds a custom alert to this player.",
        "member": "add_custom_alert(entity, icon, message, show_on_map)",
        "type": "function",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity",
            "doc": "If the alert is clicked, the map will open at the position of this entity."
          },
          "icon": {
            "name": "icon",
            "type": "SignalID",
            "doc": ""
          },
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": ""
          },
          "show_on_map": {
            "name": "show_on_map",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "remove_alert": {
        "name": "remove_alert",
        "doc": "Removes all alerts matching the given filters or if an empty filters table is given all alerts are removed.",
        "short": "Removes all alerts matching the given filters or if an empty filters table is given all alerts are removed.",
        "member": "remove_alert{entity?=, prototype?=, position?=, type?=, surface?=, icon?=, message?=}",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity?",
            "doc": ""
          },
          "prototype": {
            "name": "prototype",
            "type": "LuaEntityPrototype or string?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": ""
          },
          "type": {
            "name": "type",
            "type": "defines.alert_type?",
            "doc": ""
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": ""
          },
          "icon": {
            "name": "icon",
            "type": "SignalID?",
            "doc": ""
          },
          "message": {
            "name": "message",
            "type": "LocalisedString?",
            "doc": ""
          }
        }
      },
      "get_alerts": {
        "name": "get_alerts",
        "type": "uint",
        "doc": "Get all alerts matching the given filters, or all alerts if no filters are given. Returns: A mapping of surface index to an array of arrays of alerts indexed by the alert type.",
        "short": "Get all alerts matching the given filters, or all alerts if no filters are given.",
        "member": "get_alerts{entity?=, prototype?=, position?=, type?=, surface?=}  dictionary[uint dictionary[defines.alert_type array[Alert]]]",
        "returns": "dictionary[uint dictionary[defines.alert_type array[Alert]]]",
        "args": {
          "entity": {
            "name": "entity",
            "type": "LuaEntity?",
            "doc": ""
          },
          "prototype": {
            "name": "prototype",
            "type": "LuaEntityPrototype?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": ""
          },
          "type": {
            "name": "type",
            "type": "defines.alert_type?",
            "doc": ""
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification?",
            "doc": ""
          }
        }
      },
      "mute_alert": {
        "name": "mute_alert",
        "type": "function",
        "doc": "Mutes alerts for the given alert category. Returns: Whether the alert type was muted (false if it was already muted).",
        "short": "Mutes alerts for the given alert category.",
        "member": "mute_alert(alert_type)  boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "name": "alert_type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "unmute_alert": {
        "name": "unmute_alert",
        "type": "function",
        "doc": "Unmutes alerts for the given alert category. Returns: Whether the alert type was unmuted (false if it was wasn't muted).",
        "short": "Unmutes alerts for the given alert category.",
        "member": "unmute_alert(alert_type)  boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "name": "alert_type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "is_alert_muted": {
        "name": "is_alert_muted",
        "type": "function",
        "doc": "If the given alert type is currently muted.",
        "short": "If the given alert type is currently muted.",
        "member": "is_alert_muted(alert_type)  boolean",
        "args": {
          "alert_type": {
            "name": "alert_type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "enable_alert": {
        "name": "enable_alert",
        "type": "function",
        "doc": "Enables alerts for the given alert category. Returns: Whether the alert type was enabled (false if it was already enabled).",
        "short": "Enables alerts for the given alert category.",
        "member": "enable_alert(alert_type)  boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "name": "alert_type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "disable_alert": {
        "name": "disable_alert",
        "type": "function",
        "doc": "Disables alerts for the given alert category. Returns: Whether the alert type was disabled (false if it was already disabled).",
        "short": "Disables alerts for the given alert category.",
        "member": "disable_alert(alert_type)  boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "name": "alert_type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "is_alert_enabled": {
        "name": "is_alert_enabled",
        "type": "function",
        "doc": "If the given alert type is currently enabled.",
        "short": "If the given alert type is currently enabled.",
        "member": "is_alert_enabled(alert_type)  boolean",
        "args": {
          "alert_type": {
            "name": "alert_type",
            "type": "defines.alert_type",
            "doc": ""
          }
        }
      },
      "pipette_entity": {
        "name": "pipette_entity",
        "type": "function",
        "doc": "Invokes the \"smart pipette\" action on the player as if the user pressed it. Returns: Whether the smart pipette found something to place.",
        "short": "Invokes the \"smart pipette\" action on the player as if the user pressed it.",
        "member": "pipette_entity(entity)  boolean",
        "returns": "boolean",
        "args": {
          "entity": {
            "name": "entity",
            "type": "string or LuaEntity or LuaEntityPrototype",
            "doc": ""
          },
          "on_player_pipette?": {
            "name": "on_player_pipette?",
            "doc": "Raised if the entity was successfully pipetted."
          }
        }
      },
      "can_place_entity": {
        "name": "can_place_entity",
        "type": "boolean",
        "doc": "Checks if this player can build the given entity at the given location on the surface the player is on.",
        "short": "Checks if this player can build the given entity at the given location on the surface the player is on.",
        "member": "can_place_entity{name=, position=, direction?=}  boolean",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the entity to check."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where the entity would be placed."
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "Direction the entity would be placed. Defaults to north."
          }
        }
      },
      "can_build_from_cursor": {
        "name": "can_build_from_cursor",
        "type": "boolean",
        "doc": "Checks if this player can build what ever is in the cursor on the surface the player is on.",
        "short": "Checks if this player can build what ever is in the cursor on the surface the player is on.",
        "member": "can_build_from_cursor{position=, direction?=, alt?=, terrain_building_size?=, skip_fog_of_war?=}  boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where the entity would be placed"
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "Direction the entity would be placed"
          },
          "alt": {
            "name": "alt",
            "type": "boolean?",
            "doc": "If alt build should be used instead of normal build. Defaults to normal."
          },
          "terrain_building_size": {
            "name": "terrain_building_size",
            "type": "uint?",
            "doc": "The size for building terrain if building terrain. Defaults to 2."
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          }
        }
      },
      "build_from_cursor": {
        "name": "build_from_cursor",
        "doc": "Builds whatever is in the cursor on the surface the player is on. The cursor stack will automatically be reduced as if the player built normally.",
        "short": "Builds whatever is in the cursor on the surface the player is on. [...]",
        "member": "build_from_cursor{position=, direction?=, alt?=, terrain_building_size?=, skip_fog_of_war?=}",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where the entity would be placed"
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "Direction the entity would be placed"
          },
          "alt": {
            "name": "alt",
            "type": "boolean?",
            "doc": "If alt build should be used instead of normal build. Defaults to normal."
          },
          "terrain_building_size": {
            "name": "terrain_building_size",
            "type": "uint?",
            "doc": "The size for building terrain if building terrain. Defaults to 2."
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "on_pre_build?": {
            "name": "on_pre_build?",
            "doc": "Raised if the cursor was successfully built."
          },
          "on_built_entity?": {
            "name": "on_built_entity?",
            "doc": "Raised if the cursor was successfully built."
          }
        }
      },
      "use_from_cursor": {
        "name": "use_from_cursor",
        "doc": "Uses the current item in the cursor if it's a capsule or does nothing if not.",
        "short": "Uses the current item in the cursor if it's a capsule or does nothing if not.",
        "member": "use_from_cursor(position)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where the item would be used."
          }
        }
      },
      "play_sound": {
        "name": "play_sound",
        "doc": "Play a sound for this player.",
        "short": "Play a sound for this player.",
        "member": "play_sound{path=, position?=, volume_modifier?=, override_sound_type?=}",
        "args": {
          "path": {
            "name": "path",
            "type": "SoundPath",
            "doc": "The sound to play."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Where the sound should be played. If not given, it's played at the current position of the player."
          },
          "volume_modifier": {
            "name": "volume_modifier",
            "type": "double?",
            "doc": "The volume of the sound to play. Must be between 0 and 1 inclusive."
          },
          "override_sound_type": {
            "name": "override_sound_type",
            "type": "SoundType?",
            "doc": "The volume mixer to play the sound through. Defaults to the default mixer for the given sound type."
          }
        }
      },
      "get_associated_characters": {
        "name": "get_associated_characters",
        "type": "function",
        "doc": "The characters associated with this player.",
        "short": "The characters associated with this player.",
        "member": "get_associated_characters()  array[LuaEntity]"
      },
      "associate_character": {
        "name": "associate_character",
        "doc": "Associates a character with this player.",
        "short": "Associates a character with this player.",
        "member": "associate_character(character)",
        "type": "function",
        "args": {
          "character": {
            "name": "character",
            "type": "LuaEntity",
            "doc": "The character entity."
          }
        }
      },
      "disassociate_character": {
        "name": "disassociate_character",
        "doc": "Disassociates a character from this player. This is functionally the same as setting LuaEntity::associated_player to nil.",
        "short": "Disassociates a character from this player. [...]",
        "member": "disassociate_character(character)",
        "type": "function",
        "args": {
          "character": {
            "name": "character",
            "type": "LuaEntity",
            "doc": "The character entity"
          }
        }
      },
      "create_local_flying_text": {
        "name": "create_local_flying_text",
        "doc": "Spawn flying text that is only visible to this player. Either position or create_at_cursor are required. When create_at_cursor is true, all parameters other than text are ignored.",
        "short": "Spawn flying text that is only visible to this player. [...]",
        "member": "create_local_flying_text{text=, position?=, create_at_cursor?=, color?=, time_to_live?=, speed?=}",
        "args": {
          "text": {
            "name": "text",
            "type": "LocalisedString",
            "doc": "The flying text to show."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "The location on the map at which to show the flying text."
          },
          "create_at_cursor": {
            "name": "create_at_cursor",
            "type": "boolean?",
            "doc": "If true, the flying text is created at the player's cursor. Defaults to false."
          },
          "color": {
            "name": "color",
            "type": "Color?",
            "doc": "The color of the flying text. Defaults to white text."
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "The amount of ticks that the flying text will be shown for. Defaults to 80."
          },
          "speed": {
            "name": "speed",
            "type": "double?",
            "doc": "The speed at which the text rises upwards in tiles/second. Can't be a negative value."
          }
        }
      },
      "get_quick_bar_slot": {
        "name": "get_quick_bar_slot",
        "type": "function",
        "doc": "Gets the quick bar filter for the given slot or nil.",
        "short": "Gets the quick bar filter for the given slot or nil.",
        "member": "get_quick_bar_slot(index)  LuaItemPrototype?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The slot index. 1 for the first slot of page one, 2 for slot two of page one, 11 for the first slot of page 2, etc."
          }
        }
      },
      "set_quick_bar_slot": {
        "name": "set_quick_bar_slot",
        "doc": "Sets the quick bar filter for the given slot.",
        "short": "Sets the quick bar filter for the given slot.",
        "member": "set_quick_bar_slot(index, filter)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The slot index. 1 for the first slot of page one, 2 for slot two of page one, 11 for the first slot of page 2, etc."
          },
          "filter": {
            "name": "filter",
            "type": "string or LuaItemPrototype or LuaItemStack",
            "doc": "The filter or nil."
          }
        }
      },
      "get_active_quick_bar_page": {
        "name": "get_active_quick_bar_page",
        "type": "function",
        "doc": "Gets which quick bar page is being used for the given screen page or nil if not known.",
        "short": "Gets which quick bar page is being used for the given screen page or nil if not known.",
        "member": "get_active_quick_bar_page(index)  uint8?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The screen page. Index 1 is the top row in the gui. Index can go beyond the visible number of bars on the screen to account for the interface config setting change."
          }
        }
      },
      "set_active_quick_bar_page": {
        "name": "set_active_quick_bar_page",
        "doc": "Sets which quick bar page is being used for the given screen page.",
        "short": "Sets which quick bar page is being used for the given screen page.",
        "member": "set_active_quick_bar_page(screen_index, page_index)",
        "type": "function",
        "args": {
          "screen_index": {
            "name": "screen_index",
            "type": "uint",
            "doc": "The screen page. Index 1 is the top row in the gui. Index can go beyond the visible number of bars on the screen to account for the interface config setting change."
          },
          "page_index": {
            "name": "page_index",
            "type": "uint",
            "doc": "The new quick bar page."
          }
        }
      },
      "jump_to_cutscene_waypoint": {
        "name": "jump_to_cutscene_waypoint",
        "doc": "Jump to the specified cutscene waypoint. Only works when the player is viewing a cutscene.",
        "short": "Jump to the specified cutscene waypoint. [...]",
        "member": "jump_to_cutscene_waypoint(waypoint_index)",
        "type": "function",
        "args": {
          "waypoint_index": {
            "name": "waypoint_index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "exit_cutscene": {
        "name": "exit_cutscene",
        "doc": "Exit the current cutscene. Errors if not in a cutscene.",
        "short": "Exit the current cutscene. [...]",
        "member": "exit_cutscene()",
        "type": "function"
      },
      "open_map": {
        "name": "open_map",
        "doc": "Queues a request to open the map at the specified position. If the map is already opened, the request will simply set the position, scale, and entity to follow. Render mode change requests are processed before rendering of the next frame.",
        "short": "Queues a request to open the map at the specified position. [...]",
        "member": "open_map(position, scale?, entity?)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "scale": {
            "name": "scale",
            "type": "double?",
            "doc": ""
          },
          "entity": {
            "name": "entity",
            "type": "LuaEntity?",
            "doc": "The entity to follow. If not given the current entity being followed will be cleared."
          }
        }
      },
      "zoom_to_world": {
        "name": "zoom_to_world",
        "doc": "Queues a request to zoom to world at the specified position. If the player is already zooming to world, the request will simply set the position, scale, and entity to follow. Render mode change requests are processed before rendering of the next frame.",
        "short": "Queues a request to zoom to world at the specified position. [...]",
        "member": "zoom_to_world(position, scale?, entity?)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "scale": {
            "name": "scale",
            "type": "double?",
            "doc": ""
          },
          "entity": {
            "name": "entity",
            "type": "LuaEntity?",
            "doc": "The entity to follow. If not given the current entity being followed will be cleared."
          }
        }
      },
      "close_map": {
        "name": "close_map",
        "doc": "Queues request to switch to the normal game view from the map or zoom to world view. Render mode change requests are processed before rendering of the next frame.",
        "short": "Queues request to switch to the normal game view from the map or zoom to world view. [...]",
        "member": "close_map()",
        "type": "function"
      },
      "is_shortcut_toggled": {
        "name": "is_shortcut_toggled",
        "type": "function",
        "doc": "Is a custom Lua shortcut currently toggled?",
        "short": "Is a custom Lua shortcut currently toggled?",
        "member": "is_shortcut_toggled(prototype_name)  boolean",
        "args": {
          "prototype_name": {
            "name": "prototype_name",
            "type": "string",
            "doc": "Prototype name of the custom shortcut."
          }
        }
      },
      "is_shortcut_available": {
        "name": "is_shortcut_available",
        "type": "function",
        "doc": "Is a custom Lua shortcut currently available?",
        "short": "Is a custom Lua shortcut currently available?",
        "member": "is_shortcut_available(prototype_name)  boolean",
        "args": {
          "prototype_name": {
            "name": "prototype_name",
            "type": "string",
            "doc": "Prototype name of the custom shortcut."
          }
        }
      },
      "set_shortcut_toggled": {
        "name": "set_shortcut_toggled",
        "doc": "Toggle or untoggle a custom Lua shortcut",
        "short": "Toggle or untoggle a custom Lua shortcut",
        "member": "set_shortcut_toggled(prototype_name, toggled)",
        "type": "function",
        "args": {
          "prototype_name": {
            "name": "prototype_name",
            "type": "string",
            "doc": "Prototype name of the custom shortcut."
          },
          "toggled": {
            "name": "toggled",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "set_shortcut_available": {
        "name": "set_shortcut_available",
        "doc": "Make a custom Lua shortcut available or unavailable.",
        "short": "Make a custom Lua shortcut available or unavailable.",
        "member": "set_shortcut_available(prototype_name, available)",
        "type": "function",
        "args": {
          "prototype_name": {
            "name": "prototype_name",
            "type": "string",
            "doc": "Prototype name of the custom shortcut."
          },
          "available": {
            "name": "available",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "connect_to_server": {
        "name": "connect_to_server",
        "doc": "Asks the player if they would like to connect to the given server.",
        "short": "Asks the player if they would like to connect to the given server.",
        "member": "connect_to_server{address=, name?=, description?=, password?=}",
        "args": {
          "address": {
            "name": "address",
            "type": "string",
            "doc": "The server (address:port) if port is not given the default Factorio port is used."
          },
          "name": {
            "name": "name",
            "type": "LocalisedString?",
            "doc": "The name of the server."
          },
          "description": {
            "name": "description",
            "type": "LocalisedString?",
            "doc": ""
          },
          "password": {
            "name": "password",
            "type": "string?",
            "doc": "The password if different from the one used to join this game. Note, if the current password is not empty but the one required to join the new server is an empty string should be given for this field."
          }
        }
      },
      "toggle_map_editor": {
        "name": "toggle_map_editor",
        "doc": "Toggles this player into or out of the map editor. Does nothing if this player isn't an admin or if the player doesn't have permission to use the map editor.",
        "short": "Toggles this player into or out of the map editor. [...]",
        "member": "toggle_map_editor()",
        "type": "function",
        "args": {
          "on_pre_player_toggled_map_editor?": {
            "name": "on_pre_player_toggled_map_editor?",
            "doc": "Raised if the map editor was successfully toggled."
          },
          "on_player_toggled_map_editor?": {
            "name": "on_player_toggled_map_editor?",
            "doc": "Raised if the map editor was successfully toggled."
          }
        }
      },
      "request_translation": {
        "name": "request_translation",
        "type": "function",
        "doc": "Requests a translation for the given localised string. If the request is successful, the on_string_translated event will be fired with the results. Returns: The unique ID for the requested translation.",
        "short": "Requests a translation for the given localised string. [...]",
        "member": "request_translation(localised_string)  uint?",
        "returns": "uint?",
        "args": {
          "localised_string": {
            "name": "localised_string",
            "type": "LocalisedString",
            "doc": ""
          },
          "on_string_translated?": {
            "name": "on_string_translated?",
            "doc": "Raised if the request was successfully sent."
          }
        }
      },
      "request_translations": {
        "name": "request_translations",
        "type": "function",
        "doc": "Requests translation for the given set of localised strings. If the request is successful, a on_string_translated event will be fired for each string with the results. Returns: The unique IDs for the requested translations.",
        "short": "Requests translation for the given set of localised strings. [...]",
        "member": "request_translations(localised_strings)  array[uint]?",
        "returns": "array[uint]?",
        "args": {
          "localised_strings": {
            "name": "localised_strings",
            "type": "array[LocalisedString]",
            "doc": ""
          },
          "on_string_translated?": {
            "name": "on_string_translated?",
            "doc": "Raised if the request was successfully sent."
          }
        }
      },
      "get_infinity_inventory_filter": {
        "name": "get_infinity_inventory_filter",
        "type": "function",
        "doc": "Gets the filter for this map editor infinity filters at the given index or nil if the filter index doesn't exist or is empty.",
        "short": "Gets the filter for this map editor infinity filters at the given index or nil if the filter index doesn't exist or is empty.",
        "member": "get_infinity_inventory_filter(index)  InfinityInventoryFilter?",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index to get."
          }
        }
      },
      "set_infinity_inventory_filter": {
        "name": "set_infinity_inventory_filter",
        "doc": "Sets the filter for this map editor infinity filters at the given index.",
        "short": "Sets the filter for this map editor infinity filters at the given index.",
        "member": "set_infinity_inventory_filter(index, filter)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": "The index to set."
          },
          "filter": {
            "name": "filter",
            "type": "InfinityInventoryFilter or nil",
            "doc": "The new filter or nil to clear the filter."
          }
        }
      },
      "clear_recipe_notifications": {
        "name": "clear_recipe_notifications",
        "doc": "Clears all recipe notifications for this player.",
        "short": "Clears all recipe notifications for this player.",
        "member": "clear_recipe_notifications()",
        "type": "function"
      },
      "add_recipe_notification": {
        "name": "add_recipe_notification",
        "doc": "Adds the given recipe to the list of recipe notifications for this player.",
        "short": "Adds the given recipe to the list of recipe notifications for this player.",
        "member": "add_recipe_notification(recipe)",
        "type": "function",
        "args": {
          "recipe": {
            "name": "recipe",
            "type": "string",
            "doc": "Name of the recipe prototype to add."
          }
        }
      },
      "add_to_clipboard": {
        "name": "add_to_clipboard",
        "doc": "Adds the given blueprint to this player's clipboard queue.",
        "short": "Adds the given blueprint to this player's clipboard queue.",
        "member": "add_to_clipboard(blueprint)",
        "type": "function",
        "args": {
          "blueprint": {
            "name": "blueprint",
            "type": "LuaItemStack",
            "doc": "The blueprint to add."
          }
        }
      },
      "activate_paste": {
        "name": "activate_paste",
        "doc": "Gets a copy of the currently selected blueprint in the clipboard queue into the player's cursor, as if the player activated Paste.",
        "short": "Gets a copy of the currently selected blueprint in the clipboard queue into the player's cursor, as if the player activated Paste.",
        "member": "activate_paste()",
        "type": "function"
      },
      "start_selection": {
        "name": "start_selection",
        "doc": "Starts selection with selection tool from the specified position. Does nothing if the players cursor is not a selection tool.",
        "short": "Starts selection with selection tool from the specified position. [...]",
        "member": "start_selection(position, selection_mode)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position to start selection from."
          },
          "selection_mode": {
            "name": "selection_mode",
            "type": "\"select\" or \"alternative-select\" or \"reverse-select\"",
            "doc": "The type of selection to start."
          }
        }
      },
      "clear_selection": {
        "name": "clear_selection",
        "doc": "Clears the players selection tool selection position.",
        "short": "Clears the players selection tool selection position.",
        "member": "clear_selection()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "character": {
        "name": "character",
        "type": "LuaEntity",
        "mode": "[RW]",
        "doc": "The character attached to this player, if any. Returns nil when the player is disconnected (see LuaPlayer::connected).",
        "short": "The character attached to this player, if any. [...]",
        "member": "character  ::LuaEntity? Read/Write"
      },
      "cutscene_character": {
        "name": "cutscene_character",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "When in a cutscene; the character this player would be using once the cutscene is over, if any. Returns nil when the player is disconnected (see LuaPlayer::connected).",
        "short": "When in a cutscene; the character this player would be using once the cutscene is over, if any. [...]",
        "member": "cutscene_character  ::LuaEntity? Read"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[R]",
        "doc": "This player's index in LuaGameScript::players (unique ID). It is assigned when a player is created, and remains so (even when the player is not connected) until the player is irreversably removed. Indexes of removed players can be reused.",
        "short": "This player's index in LuaGameScript::players (unique ID). [...]",
        "member": "index  ::uint Read"
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[R]",
        "member": "gui  ::LuaGui Read"
      },
      "opened_self": {
        "name": "opened_self",
        "type": "boolean",
        "mode": "[R]",
        "doc": "true if the player opened itself. I.e. if they opened the character or god-controller GUI.",
        "short": "true if the player opened itself. [...]",
        "member": "opened_self  ::boolean Read"
      },
      "controller_type": {
        "name": "controller_type",
        "type": "defines.controllers",
        "mode": "[R]",
        "member": "controller_type  ::defines.controllers Read"
      },
      "stashed_controller_type": {
        "name": "stashed_controller_type",
        "type": "defines.controllers",
        "mode": "[R]",
        "doc": "The stashed controller type, if any.",
        "short": "The stashed controller type, if any.",
        "member": "stashed_controller_type  ::defines.controllers? Read"
      },
      "game_view_settings": {
        "name": "game_view_settings",
        "type": "GameViewSettings",
        "mode": "[RW]",
        "doc": "The player's game view settings.",
        "short": "The player's game view settings.",
        "member": "game_view_settings  ::GameViewSettings Read/Write"
      },
      "minimap_enabled": {
        "name": "minimap_enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the minimap is visible.",
        "short": "true if the minimap is visible.",
        "member": "minimap_enabled  ::boolean Read/Write"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[RW]",
        "doc": "The color associated with the player. This will be used to tint the player's character as well as their buildings and vehicles.",
        "short": "The color associated with the player. [...]",
        "member": "color  ::Color Read/Write"
      },
      "chat_color": {
        "name": "chat_color",
        "type": "Color",
        "mode": "[RW]",
        "doc": "The color used when this player talks in game.",
        "short": "The color used when this player talks in game.",
        "member": "chat_color  ::Color Read/Write"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "The player's username.",
        "short": "The player's username.",
        "member": "name  ::string Read"
      },
      "tag": {
        "name": "tag",
        "type": "string",
        "mode": "[RW]",
        "doc": "The tag that is shown after the player in chat and on the map.",
        "short": "The tag that is shown after the player in chat and on the map.",
        "member": "tag  ::string Read/Write"
      },
      "connected": {
        "name": "connected",
        "type": "boolean",
        "mode": "[R]",
        "doc": "true if the player is currently connected to the game.",
        "short": "true if the player is currently connected to the game.",
        "member": "connected  ::boolean Read"
      },
      "admin": {
        "name": "admin",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the player is an admin.",
        "short": "true if the player is an admin.",
        "member": "admin  ::boolean Read/Write"
      },
      "entity_copy_source": {
        "name": "entity_copy_source",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The source entity used during entity settings copy-paste, if any.",
        "short": "The source entity used during entity settings copy-paste, if any.",
        "member": "entity_copy_source  ::LuaEntity? Read"
      },
      "afk_time": {
        "name": "afk_time",
        "type": "uint",
        "mode": "[R]",
        "doc": "How many ticks since the last action of this player",
        "short": "How many ticks since the last action of this player",
        "member": "afk_time  ::uint Read"
      },
      "online_time": {
        "name": "online_time",
        "type": "uint",
        "mode": "[R]",
        "doc": "How many ticks did this player spend playing this save (all sessions combined)",
        "short": "How many ticks did this player spend playing this save (all sessions combined)",
        "member": "online_time  ::uint Read"
      },
      "last_online": {
        "name": "last_online",
        "type": "uint",
        "mode": "[R]",
        "doc": "At what tick this player was last online.",
        "short": "At what tick this player was last online.",
        "member": "last_online  ::uint Read"
      },
      "permission_group": {
        "name": "permission_group",
        "type": "LuaPermissionGroup",
        "mode": "[RW]",
        "doc": "The permission group this player is part of, if any.",
        "short": "The permission group this player is part of, if any.",
        "member": "permission_group  ::LuaPermissionGroup? Read/Write"
      },
      "mod_settings": {
        "name": "mod_settings",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "The current per-player settings for the this player, indexed by prototype name. Returns the same structure as LuaSettings::get_player_settings. This table becomes invalid if its associated player does.",
        "short": "The current per-player settings for the this player, indexed by prototype name. [...]",
        "member": "mod_settings  ::LuaCustomTable[string ModSetting] Read"
      },
      "ticks_to_respawn": {
        "name": "ticks_to_respawn",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The number of ticks until this player will respawn. nil if this player is not waiting to respawn.",
        "short": "The number of ticks until this player will respawn. [...]",
        "member": "ticks_to_respawn  ::uint? Read/Write"
      },
      "display_resolution": {
        "name": "display_resolution",
        "type": "DisplayResolution",
        "mode": "[R]",
        "doc": "The display resolution for this player.",
        "short": "The display resolution for this player.",
        "member": "display_resolution  ::DisplayResolution Read"
      },
      "display_scale": {
        "name": "display_scale",
        "type": "double",
        "mode": "[R]",
        "doc": "The display scale for this player.",
        "short": "The display scale for this player.",
        "member": "display_scale  ::double Read"
      },
      "blueprint_to_setup": {
        "name": "blueprint_to_setup",
        "type": "LuaItemStack",
        "mode": "[R]",
        "doc": "The item stack containing a blueprint to be setup.",
        "short": "The item stack containing a blueprint to be setup.",
        "member": "blueprint_to_setup  ::LuaItemStack Read"
      },
      "render_mode": {
        "name": "render_mode",
        "type": "defines.render_mode",
        "mode": "[R]",
        "doc": "The render mode of the player, like map or zoom to world. The render mode can be set using LuaPlayer::open_map, LuaPlayer::zoom_to_world and LuaPlayer::close_map.",
        "short": "The render mode of the player, like map or zoom to world. [...]",
        "member": "render_mode  ::defines.render_mode Read"
      },
      "input_method": {
        "name": "input_method",
        "type": "defines.input_method",
        "mode": "[R]",
        "doc": "The input method of the player, mouse and keyboard or game controller",
        "short": "The input method of the player, mouse and keyboard or game controller",
        "member": "input_method  ::defines.input_method Read"
      },
      "spectator": {
        "name": "spectator",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If true, zoom-to-world noise effect will be disabled and environmental sounds will be based on zoom-to-world view instead of position of player's character.",
        "short": "If true, zoom-to-world noise effect will be disabled and environmental sounds will be based on zoom-to-world view instead of position of player's character.",
        "member": "spectator  ::boolean Read/Write"
      },
      "show_on_map": {
        "name": "show_on_map",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If true, circle and name of given player is rendered on the map/chart.",
        "short": "If true, circle and name of given player is rendered on the map/chart.",
        "member": "show_on_map  ::boolean Read/Write"
      },
      "remove_unfiltered_items": {
        "name": "remove_unfiltered_items",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If items not included in this map editor infinity inventory filters should be removed.",
        "short": "If items not included in this map editor infinity inventory filters should be removed.",
        "member": "remove_unfiltered_items  ::boolean Read/Write"
      },
      "infinity_inventory_filters": {
        "name": "infinity_inventory_filters",
        "type": "InfinityInventoryFilter",
        "mode": "[RW]",
        "doc": "The filters for this map editor infinity inventory settings.",
        "short": "The filters for this map editor infinity inventory settings.",
        "member": "infinity_inventory_filters  ::array[InfinityInventoryFilter] Read/Write"
      },
      "auto_sort_main_inventory": {
        "name": "auto_sort_main_inventory",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the main inventory will be auto sorted.",
        "short": "If the main inventory will be auto sorted.",
        "member": "auto_sort_main_inventory  ::boolean Read"
      },
      "hand_location": {
        "name": "hand_location",
        "type": "ItemStackLocation",
        "mode": "[RW]",
        "doc": "The original location of the item in the cursor, marked with a hand. nil if the cursor stack is empty. When writing, the specified inventory slot must be empty and the cursor stack must not be empty.",
        "short": "The original location of the item in the cursor, marked with a hand. [...]",
        "member": "hand_location  ::ItemStackLocation? Read/Write"
      },
      "cursor_stack_temporary": {
        "name": "cursor_stack_temporary",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Returns true if the current item stack in cursor will be destroyed after clearing the cursor. Manually putting it into inventory still preserves the item. If the cursor stack is not one of the supported types (blueprint, blueprint-book, deconstruction-planner, upgrade-planner), write operation will be silently ignored.",
        "short": "Returns true if the current item stack in cursor will be destroyed after clearing the cursor. [...]",
        "member": "cursor_stack_temporary  ::boolean Read/Write"
      },
      "drag_target": {
        "name": "drag_target",
        "type": "DragTarget",
        "mode": "[R]",
        "doc": "The wire drag target for this player, if any.",
        "short": "The wire drag target for this player, if any.",
        "member": "drag_target  ::DragTarget? Read"
      },
      "zoom": {
        "name": "zoom",
        "type": "double",
        "mode": "[W]",
        "doc": "The player's zoom-level.",
        "short": "The player's zoom-level.",
        "member": "zoom  ::double Write"
      },
      "map_view_settings": {
        "name": "map_view_settings",
        "type": "MapViewSettings",
        "mode": "[W]",
        "doc": "The player's map view settings. To write to this, use a table containing the fields that should be changed.",
        "short": "The player's map view settings. [...]",
        "member": "map_view_settings  ::MapViewSettings Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaProfiler": {
    "name": "LuaProfiler",
    "type": "LuaProfiler",
    "inherits": [],
    "properties": {
      "reset": {
        "name": "reset",
        "doc": "Resets the clock, also restarting it.",
        "short": "Resets the clock, also restarting it.",
        "member": "reset()",
        "type": "function"
      },
      "stop": {
        "name": "stop",
        "doc": "Stops the clock.",
        "short": "Stops the clock.",
        "member": "stop()",
        "type": "function"
      },
      "restart": {
        "name": "restart",
        "doc": "Start the clock again, without resetting it.",
        "short": "Start the clock again, without resetting it.",
        "member": "restart()",
        "type": "function"
      },
      "add": {
        "name": "add",
        "doc": "Add the duration of another timer to this timer. Useful to reduce start/stop overhead when accumulating time onto many timers at once.",
        "short": "Add the duration of another timer to this timer. [...]",
        "member": "add(other)",
        "type": "function",
        "args": {
          "other": {
            "name": "other",
            "type": "LuaProfiler",
            "doc": "The timer to add to this timer."
          }
        }
      },
      "divide": {
        "name": "divide",
        "doc": "Divides the current duration by a set value. Useful for calculating the average of many iterations.",
        "short": "Divides the current duration by a set value. [...]",
        "member": "divide(number)",
        "type": "function",
        "args": {
          "number": {
            "name": "number",
            "type": "double",
            "doc": "The number to divide by. Must be > 0."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaProgrammableSpeakerControlBehavior": {
    "name": "LuaProgrammableSpeakerControlBehavior",
    "type": "LuaProgrammableSpeakerControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "circuit_parameters": {
        "name": "circuit_parameters",
        "type": "ProgrammableSpeakerCircuitParameters",
        "mode": "[RW]",
        "member": "circuit_parameters  ::ProgrammableSpeakerCircuitParameters Read/Write"
      },
      "circuit_condition": {
        "name": "circuit_condition",
        "type": "CircuitConditionDefinition",
        "mode": "[RW]",
        "member": "circuit_condition  ::CircuitConditionDefinition Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRCON": {
    "name": "LuaRCON",
    "type": "LuaRCON",
    "inherits": [],
    "properties": {
      "print": {
        "name": "print",
        "doc": "Print text to the calling RCON interface if any.",
        "short": "Print text to the calling RCON interface if any.",
        "member": "print(message)",
        "type": "function",
        "args": {
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": ""
          }
        }
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRailChainSignalControlBehavior": {
    "name": "LuaRailChainSignalControlBehavior",
    "type": "LuaRailChainSignalControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "red_signal": {
        "name": "red_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "red_signal  ::SignalID Read/Write"
      },
      "orange_signal": {
        "name": "orange_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "orange_signal  ::SignalID Read/Write"
      },
      "green_signal": {
        "name": "green_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "green_signal  ::SignalID Read/Write"
      },
      "blue_signal": {
        "name": "blue_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "blue_signal  ::SignalID Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRailPath": {
    "name": "LuaRailPath",
    "type": "LuaRailPath",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "size": {
        "name": "size",
        "type": "uint",
        "mode": "[R]",
        "doc": "The total number of rails in this path.",
        "short": "The total number of rails in this path.",
        "member": "size  ::uint Read"
      },
      "current": {
        "name": "current",
        "type": "uint",
        "mode": "[R]",
        "doc": "The current rail index.",
        "short": "The current rail index.",
        "member": "current  ::uint Read"
      },
      "total_distance": {
        "name": "total_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The total path distance.",
        "short": "The total path distance.",
        "member": "total_distance  ::double Read"
      },
      "travelled_distance": {
        "name": "travelled_distance",
        "type": "double",
        "mode": "[R]",
        "doc": "The total distance travelled.",
        "short": "The total distance travelled.",
        "member": "travelled_distance  ::double Read"
      },
      "rails": {
        "name": "rails",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Array of the rails that this path travels over.",
        "short": "Array of the rails that this path travels over.",
        "member": "rails  ::LuaCustomTable[uint LuaEntity] Read"
      },
      "is_front": {
        "name": "is_front",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the path goes from the front of the train",
        "short": "If the path goes from the front of the train",
        "member": "is_front  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRailSignalControlBehavior": {
    "name": "LuaRailSignalControlBehavior",
    "type": "LuaRailSignalControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "red_signal": {
        "name": "red_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "red_signal  ::SignalID Read/Write"
      },
      "orange_signal": {
        "name": "orange_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "orange_signal  ::SignalID Read/Write"
      },
      "green_signal": {
        "name": "green_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "green_signal  ::SignalID Read/Write"
      },
      "close_signal": {
        "name": "close_signal",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If this will close the rail signal based off the circuit condition.",
        "short": "If this will close the rail signal based off the circuit condition.",
        "member": "close_signal  ::boolean Read/Write"
      },
      "read_signal": {
        "name": "read_signal",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If this will read the rail signal state.",
        "short": "If this will read the rail signal state.",
        "member": "read_signal  ::boolean Read/Write"
      },
      "circuit_condition": {
        "name": "circuit_condition",
        "type": "CircuitConditionDefinition",
        "mode": "[RW]",
        "doc": "The circuit condition when controlling the signal through the circuit network.",
        "short": "The circuit condition when controlling the signal through the circuit network.",
        "member": "circuit_condition  ::CircuitConditionDefinition Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRandomGenerator": {
    "name": "LuaRandomGenerator",
    "type": "LuaRandomGenerator",
    "inherits": [],
    "properties": {
      "re_seed": {
        "name": "re_seed",
        "doc": "Re-seeds the random generator with the given value.",
        "short": "Re-seeds the random generator with the given value.",
        "member": "re_seed(seed)",
        "type": "function",
        "args": {
          "seed": {
            "name": "seed",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "() (call)": {
        "name": "() (call)",
        "type": "double",
        "doc": "Generates a random number. [...]"
      }
    }
  },
  "LuaRecipe": {
    "name": "LuaRecipe",
    "type": "LuaRecipe",
    "inherits": [],
    "properties": {
      "reload": {
        "name": "reload",
        "doc": "Reload the recipe from the prototype.",
        "short": "Reload the recipe from the prototype.",
        "member": "reload()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the recipe. This can be different than the name of the result items as there could be more recipes to make the same item.",
        "short": "Name of the recipe. [...]",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of the recipe.",
        "short": "Localised name of the recipe.",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaRecipePrototype",
        "mode": "[R]",
        "doc": "The prototype for this recipe.",
        "short": "The prototype for this recipe.",
        "member": "prototype  ::LuaRecipePrototype Read"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Can the recipe be used?",
        "short": "Can the recipe be used?",
        "member": "enabled  ::boolean Read/Write"
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[R]",
        "doc": "Category of the recipe.",
        "short": "Category of the recipe.",
        "member": "category  ::string Read"
      },
      "ingredients": {
        "name": "ingredients",
        "type": "Ingredient",
        "mode": "[R]",
        "doc": "The ingredients to this recipe.",
        "short": "The ingredients to this recipe.",
        "member": "ingredients  ::array[Ingredient] Read"
      },
      "products": {
        "name": "products",
        "type": "Product",
        "mode": "[R]",
        "doc": "The results/products of this recipe.",
        "short": "The results/products of this recipe.",
        "member": "products  ::array[Product] Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is the recipe hidden? Hidden recipe don't show up in the crafting menu.",
        "short": "Is the recipe hidden? [...]",
        "member": "hidden  ::boolean Read"
      },
      "hidden_from_flow_stats": {
        "name": "hidden_from_flow_stats",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Is the recipe hidden from flow statistics?",
        "short": "Is the recipe hidden from flow statistics?",
        "member": "hidden_from_flow_stats  ::boolean Read/Write"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Energy required to execute this recipe. This directly affects the crafting time: Recipe's energy is exactly its crafting time in seconds, when crafted in an assembling machine with crafting speed exactly equal to one.",
        "short": "Energy required to execute this recipe. [...]",
        "member": "energy  ::double Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Group of this recipe.",
        "short": "Group of this recipe.",
        "member": "group  ::LuaGroup Read"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Subgroup of this recipe.",
        "short": "Subgroup of this recipe.",
        "member": "subgroup  ::LuaGroup Read"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force that owns this recipe.",
        "short": "The force that owns this recipe.",
        "member": "force  ::LuaForce Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRecipeCategoryPrototype": {
    "name": "LuaRecipeCategoryPrototype",
    "type": "LuaRecipeCategoryPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRecipePrototype": {
    "name": "LuaRecipePrototype",
    "type": "LuaRecipePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this recipe prototype is enabled by default (enabled at the beginning of a game).",
        "short": "If this recipe prototype is enabled by default (enabled at the beginning of a game).",
        "member": "enabled  ::boolean Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of the recipe. This can be different than the name of the result items as there could be more recipes to make the same item.",
        "short": "Name of the recipe. [...]",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of the recipe.",
        "short": "Localised name of the recipe.",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[R]",
        "doc": "Category of the recipe.",
        "short": "Category of the recipe.",
        "member": "category  ::string Read"
      },
      "ingredients": {
        "name": "ingredients",
        "type": "Ingredient",
        "mode": "[R]",
        "doc": "The ingredients to this recipe.",
        "short": "The ingredients to this recipe.",
        "member": "ingredients  ::array[Ingredient] Read"
      },
      "products": {
        "name": "products",
        "type": "Product",
        "mode": "[R]",
        "doc": "The results/products of this recipe.",
        "short": "The results/products of this recipe.",
        "member": "products  ::array[Product] Read"
      },
      "main_product": {
        "name": "main_product",
        "type": "Product",
        "mode": "[R]",
        "doc": "The main product of this recipe, if any.",
        "short": "The main product of this recipe, if any.",
        "member": "main_product  ::Product? Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is the recipe hidden? Hidden recipe don't show up in the crafting menu.",
        "short": "Is the recipe hidden? [...]",
        "member": "hidden  ::boolean Read"
      },
      "hidden_from_flow_stats": {
        "name": "hidden_from_flow_stats",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is the recipe hidden from flow statistics (item/fluid production statistics)?",
        "short": "Is the recipe hidden from flow statistics (item/fluid production statistics)?",
        "member": "hidden_from_flow_stats  ::boolean Read"
      },
      "hidden_from_player_crafting": {
        "name": "hidden_from_player_crafting",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is the recipe hidden from player crafting? The recipe will still show up for selection in machines.",
        "short": "Is the recipe hidden from player crafting? [...]",
        "member": "hidden_from_player_crafting  ::boolean Read"
      },
      "always_show_made_in": {
        "name": "always_show_made_in",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Should this recipe always show \"Made in\" in the tooltip?",
        "short": "Should this recipe always show \"Made in\" in the tooltip?",
        "member": "always_show_made_in  ::boolean Read"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Energy required to execute this recipe. This directly affects the crafting time: Recipe's energy is exactly its crafting time in seconds, when crafted in an assembling machine with crafting speed exactly equal to one.",
        "short": "Energy required to execute this recipe. [...]",
        "member": "energy  ::double Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Group of this recipe.",
        "short": "Group of this recipe.",
        "member": "group  ::LuaGroup Read"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[R]",
        "doc": "Subgroup of this recipe.",
        "short": "Subgroup of this recipe.",
        "member": "subgroup  ::LuaGroup Read"
      },
      "request_paste_multiplier": {
        "name": "request_paste_multiplier",
        "type": "uint",
        "mode": "[R]",
        "doc": "The multiplier used when this recipe is copied from an assembling machine to a requester chest. For each item in the recipe the item count * this value is set in the requester chest.",
        "short": "The multiplier used when this recipe is copied from an assembling machine to a requester chest. [...]",
        "member": "request_paste_multiplier  ::uint Read"
      },
      "overload_multiplier": {
        "name": "overload_multiplier",
        "type": "uint",
        "mode": "[R]",
        "doc": "Used to determine how many extra items are put into an assembling machine before it's considered \"full enough\".",
        "short": "Used to determine how many extra items are put into an assembling machine before it's considered \"full enough\".",
        "member": "overload_multiplier  ::uint Read"
      },
      "allow_inserter_overload": {
        "name": "allow_inserter_overload",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the recipe is allowed to have the extra inserter overload bonus applied (4 * stack inserter stack size).",
        "short": "If the recipe is allowed to have the extra inserter overload bonus applied (4 * stack inserter stack size).",
        "member": "allow_inserter_overload  ::boolean Read"
      },
      "allow_as_intermediate": {
        "name": "allow_as_intermediate",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this recipe is enabled for the purpose of intermediate hand-crafting.",
        "short": "If this recipe is enabled for the purpose of intermediate hand-crafting.",
        "member": "allow_as_intermediate  ::boolean Read"
      },
      "allow_intermediates": {
        "name": "allow_intermediates",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this recipe is allowed to use intermediate recipes when hand-crafting.",
        "short": "If this recipe is allowed to use intermediate recipes when hand-crafting.",
        "member": "allow_intermediates  ::boolean Read"
      },
      "show_amount_in_title": {
        "name": "show_amount_in_title",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the amount is shown in the recipe tooltip title when the recipe produces more than 1 product.",
        "short": "If the amount is shown in the recipe tooltip title when the recipe produces more than 1 product.",
        "member": "show_amount_in_title  ::boolean Read"
      },
      "always_show_products": {
        "name": "always_show_products",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the products are always shown in the recipe tooltip.",
        "short": "If the products are always shown in the recipe tooltip.",
        "member": "always_show_products  ::boolean Read"
      },
      "emissions_multiplier": {
        "name": "emissions_multiplier",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions multiplier for this recipe.",
        "short": "The emissions multiplier for this recipe.",
        "member": "emissions_multiplier  ::double Read"
      },
      "allow_decomposition": {
        "name": "allow_decomposition",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this recipe allowed to be broken down for the recipe tooltip \"Total raw\" calculations?",
        "short": "Is this recipe allowed to be broken down for the recipe tooltip \"Total raw\" calculations?",
        "member": "allow_decomposition  ::boolean Read"
      },
      "unlock_results": {
        "name": "unlock_results",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this recipe unlocks the result item(s) so they're shown in filter-select GUIs.",
        "short": "Is this recipe unlocks the result item(s) so they're shown in filter-select GUIs.",
        "member": "unlock_results  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRemote": {
    "name": "LuaRemote",
    "type": "LuaRemote",
    "inherits": [],
    "properties": {
      "add_interface": {
        "name": "add_interface",
        "doc": "Add a remote interface.",
        "short": "Add a remote interface.",
        "member": "add_interface(name, functions)",
        "type": "function",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the interface. If the name matches any existing interface, an error is thrown."
          },
          "functions": {
            "name": "functions",
            "type": "dictionary[string function()]",
            "doc": "List of functions that are members of the new interface."
          }
        }
      },
      "remove_interface": {
        "name": "remove_interface",
        "type": "function",
        "doc": "Removes an interface with the given name. Returns: Whether the interface was removed. False if the interface didn't exist.",
        "short": "Removes an interface with the given name.",
        "member": "remove_interface(name)  boolean",
        "returns": "boolean",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the interface."
          }
        }
      },
      "call": {
        "name": "call",
        "type": "function",
        "doc": "Call a function of an interface.",
        "short": "Call a function of an interface.",
        "member": "call(interface, function, ...)  Any?",
        "args": {
          "interface": {
            "name": "interface",
            "type": "string",
            "doc": "Interface to look up function in."
          },
          "function": {
            "name": "function",
            "type": "string",
            "doc": "Function name that belongs to the interface."
          },
          "...": {
            "name": "...",
            "type": "Any",
            "doc": "Arguments to pass to the called function. Note that any arguments passed through the interface are a copy of the original, not a reference. Metatables are not retained, while references to LuaObjects stay intact."
          }
        }
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      },
      "interfaces": {
        "name": "interfaces",
        "type": "string",
        "mode": "[R]",
        "doc": "List of all registered interfaces. For each interface name, remote.interfaces[name] is a dictionary mapping the interface's registered functions to true.",
        "short": "List of all registered interfaces. [...]",
        "member": "interfaces  ::dictionary[string dictionary[string true]] Read"
      }
    }
  },
  "LuaRendering": {
    "name": "LuaRendering",
    "type": "LuaRendering",
    "inherits": [],
    "properties": {
      "draw_line": {
        "name": "draw_line",
        "type": "uint64",
        "doc": "Create a line.",
        "short": "Create a line.",
        "member": "draw_line{color=, width=, gap_length?=, dash_length?=, dash_offset?=, from=, from_offset?=, to=, to_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, draw_on_ground?=, only_in_alt_mode?=}  uint64",
        "args": {
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          },
          "width": {
            "name": "width",
            "type": "float",
            "doc": "In pixels (32 per tile)."
          },
          "gap_length": {
            "name": "gap_length",
            "type": "double?",
            "doc": "Length of the gaps that this line has, in tiles. Default is 0."
          },
          "dash_length": {
            "name": "dash_length",
            "type": "double?",
            "doc": "Length of the dashes that this line has. Used only if gap_length > 0. Default is 0."
          },
          "dash_offset": {
            "name": "dash_offset",
            "type": "double?",
            "doc": "Starting offset to apply to dashes. Cannot be greater than dash_length + gap_length. Default is 0."
          },
          "from": {
            "name": "from",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "from_offset": {
            "name": "from_offset",
            "type": "Vector?",
            "doc": "Only used if from is a LuaEntity."
          },
          "to": {
            "name": "to",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "to_offset": {
            "name": "to_offset",
            "type": "Vector?",
            "doc": "Only used if to is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean?",
            "doc": "If this should be drawn below sprites and entities."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_text": {
        "name": "draw_text",
        "type": "uint64",
        "doc": "Create a text. Returns: Id of the render object",
        "short": "Create a text.",
        "member": "draw_text{text=, surface=, target=, target_offset?=, color=, scale?=, font?=, time_to_live?=, forces?=, players?=, visible?=, draw_on_ground?=, orientation?=, alignment?=, vertical_alignment?=, scale_with_zoom?=, only_in_alt_mode?=, use_rich_text?=}  uint64",
        "returns": "uint64",
        "args": {
          "text": {
            "name": "text",
            "type": "LocalisedString",
            "doc": "The text to display."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          },
          "scale": {
            "name": "scale",
            "type": "double?",
            "doc": ""
          },
          "font": {
            "name": "font",
            "type": "string?",
            "doc": "Name of font to use. Defaults to the same font as flying-text."
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean?",
            "doc": "If this should be drawn below sprites and entities. Rich text does not support this option."
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation?",
            "doc": "The orientation of the text. Default is 0."
          },
          "alignment": {
            "name": "alignment",
            "type": "TextAlign?",
            "doc": "Defaults to \"left\"."
          },
          "vertical_alignment": {
            "name": "vertical_alignment",
            "type": "VerticalTextAlign?",
            "doc": "Defaults to \"top\"."
          },
          "scale_with_zoom": {
            "name": "scale_with_zoom",
            "type": "boolean?",
            "doc": "Defaults to false. If true, the text scales with player zoom, resulting in it always being the same size on screen, and the size compared to the game world changes."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          },
          "use_rich_text": {
            "name": "use_rich_text",
            "type": "boolean?",
            "doc": "If rich text rendering is enabled. Defaults to false."
          }
        }
      },
      "draw_circle": {
        "name": "draw_circle",
        "type": "uint64",
        "doc": "Create a circle. Returns: Id of the render object",
        "short": "Create a circle.",
        "member": "draw_circle{color=, radius=, width?=, filled?=, target=, target_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, draw_on_ground?=, only_in_alt_mode?=}  uint64",
        "returns": "uint64",
        "args": {
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          },
          "radius": {
            "name": "radius",
            "type": "double",
            "doc": "In tiles."
          },
          "width": {
            "name": "width",
            "type": "float?",
            "doc": "Width of the outline, used only if filled = false. Value is in pixels (32 per tile). Defaults to 1."
          },
          "filled": {
            "name": "filled",
            "type": "boolean?",
            "doc": "If the circle should be filled. Defaults to false."
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean?",
            "doc": "If this should be drawn below sprites and entities."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_rectangle": {
        "name": "draw_rectangle",
        "type": "uint64",
        "doc": "Create a rectangle.",
        "short": "Create a rectangle.",
        "member": "draw_rectangle{color=, width?=, filled?=, left_top=, left_top_offset?=, right_bottom=, right_bottom_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, draw_on_ground?=, only_in_alt_mode?=}  uint64",
        "args": {
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          },
          "width": {
            "name": "width",
            "type": "float?",
            "doc": "Width of the outline, used only if filled = false. Value is in pixels (32 per tile). Defaults to 1."
          },
          "filled": {
            "name": "filled",
            "type": "boolean?",
            "doc": "If the rectangle should be filled. Defaults to false."
          },
          "left_top": {
            "name": "left_top",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "left_top_offset": {
            "name": "left_top_offset",
            "type": "Vector?",
            "doc": "Only used if left_top is a LuaEntity."
          },
          "right_bottom": {
            "name": "right_bottom",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "right_bottom_offset": {
            "name": "right_bottom_offset",
            "type": "Vector?",
            "doc": "Only used if right_bottom is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean?",
            "doc": "If this should be drawn below sprites and entities."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_arc": {
        "name": "draw_arc",
        "type": "uint64",
        "doc": "Create an arc. Returns: Id of the render object",
        "short": "Create an arc.",
        "member": "draw_arc{color=, max_radius=, min_radius=, start_angle=, angle=, target=, target_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, draw_on_ground?=, only_in_alt_mode?=}  uint64",
        "returns": "uint64",
        "args": {
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          },
          "max_radius": {
            "name": "max_radius",
            "type": "double",
            "doc": "The radius of the outer edge of the arc, in tiles."
          },
          "min_radius": {
            "name": "min_radius",
            "type": "double",
            "doc": "The radius of the inner edge of the arc, in tiles."
          },
          "start_angle": {
            "name": "start_angle",
            "type": "float",
            "doc": "Where the arc starts, in radian."
          },
          "angle": {
            "name": "angle",
            "type": "float",
            "doc": "The angle of the arc, in radian."
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean?",
            "doc": "If this should be drawn below sprites and entities."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_polygon": {
        "name": "draw_polygon",
        "type": "uint64",
        "doc": "Create a triangle mesh defined by a triangle strip. Returns: Id of the render object",
        "short": "Create a triangle mesh defined by a triangle strip.",
        "member": "draw_polygon{color=, vertices=, target?=, target_offset?=, orientation?=, orientation_target?=, orientation_target_offset?=, use_target_orientation?=, surface=, time_to_live?=, forces?=, players?=, visible?=, draw_on_ground?=, only_in_alt_mode?=}  uint64",
        "returns": "uint64",
        "args": {
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          },
          "vertices": {
            "name": "vertices",
            "type": "array[ScriptRenderVertexTarget]",
            "doc": ""
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity?",
            "doc": "Acts like an offset applied to all vertices that are not set to an entity."
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation?",
            "doc": "The orientation applied to all vertices. Default is 0."
          },
          "orientation_target": {
            "name": "orientation_target",
            "type": "MapPosition or LuaEntity?",
            "doc": "If given, the vertices (that are not set to an entity) rotate so that it faces this target. Note that orientation is still applied."
          },
          "orientation_target_offset": {
            "name": "orientation_target_offset",
            "type": "Vector?",
            "doc": "Only used if orientation_target is a LuaEntity."
          },
          "use_target_orientation": {
            "name": "use_target_orientation",
            "type": "boolean?",
            "doc": "Only used if orientation_target is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean?",
            "doc": "If this should be drawn below sprites and entities."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_sprite": {
        "name": "draw_sprite",
        "type": "uint64",
        "doc": "Create a sprite.",
        "short": "Create a sprite.",
        "member": "draw_sprite{sprite=, orientation?=, x_scale?=, y_scale?=, tint?=, render_layer?=, orientation_target?=, orientation_target_offset?=, use_target_orientation?=, oriented_offset?=, target=, target_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, only_in_alt_mode?=}  uint64",
        "args": {
          "sprite": {
            "name": "sprite",
            "type": "SpritePath",
            "doc": ""
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation?",
            "doc": "The orientation of the sprite. Default is 0."
          },
          "x_scale": {
            "name": "x_scale",
            "type": "double?",
            "doc": "Horizontal scale of the sprite. Default is 1."
          },
          "y_scale": {
            "name": "y_scale",
            "type": "double?",
            "doc": "Vertical scale of the sprite. Default is 1."
          },
          "tint": {
            "name": "tint",
            "type": "Color?",
            "doc": ""
          },
          "render_layer": {
            "name": "render_layer",
            "type": "RenderLayer?",
            "doc": "Render layer of the sprite. Defaults to \"arrow\"."
          },
          "orientation_target": {
            "name": "orientation_target",
            "type": "MapPosition or LuaEntity?",
            "doc": "If given, the sprite rotates so that it faces this target. Note that orientation is still applied to the sprite."
          },
          "orientation_target_offset": {
            "name": "orientation_target_offset",
            "type": "Vector?",
            "doc": "Only used if orientation_target is a LuaEntity."
          },
          "use_target_orientation": {
            "name": "use_target_orientation",
            "type": "boolean?",
            "doc": "Only used if orientation_target is a LuaEntity."
          },
          "oriented_offset": {
            "name": "oriented_offset",
            "type": "Vector?",
            "doc": "Offsets the center of the sprite if orientation_target is given. This offset will rotate together with the sprite."
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": "Center of the sprite."
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_light": {
        "name": "draw_light",
        "type": "uint64",
        "doc": "Create a light. Returns: Id of the render object",
        "short": "Create a light.",
        "member": "draw_light{sprite=, orientation?=, scale?=, intensity?=, minimum_darkness?=, oriented?=, color?=, target=, target_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, only_in_alt_mode?=}  uint64",
        "returns": "uint64",
        "args": {
          "sprite": {
            "name": "sprite",
            "type": "SpritePath",
            "doc": ""
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation?",
            "doc": "The orientation of the light. Default is 0."
          },
          "scale": {
            "name": "scale",
            "type": "float?",
            "doc": "Default is 1."
          },
          "intensity": {
            "name": "intensity",
            "type": "float?",
            "doc": "Default is 1."
          },
          "minimum_darkness": {
            "name": "minimum_darkness",
            "type": "float?",
            "doc": "The minimum darkness at which this light is rendered. Default is 0."
          },
          "oriented": {
            "name": "oriented",
            "type": "boolean?",
            "doc": "If this light has the same orientation as the entity target, default is false. Note that orientation is still applied to the sprite."
          },
          "color": {
            "name": "color",
            "type": "Color?",
            "doc": "Defaults to white (no tint)."
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": "Center of the light."
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "draw_animation": {
        "name": "draw_animation",
        "type": "uint64",
        "doc": "Create an animation. Returns: Id of the render object",
        "short": "Create an animation.",
        "member": "draw_animation{animation=, orientation?=, x_scale?=, y_scale?=, tint?=, render_layer?=, animation_speed?=, animation_offset?=, orientation_target?=, orientation_target_offset?=, use_target_orientation?=, oriented_offset?=, target=, target_offset?=, surface=, time_to_live?=, forces?=, players?=, visible?=, only_in_alt_mode?=}  uint64",
        "returns": "uint64",
        "args": {
          "animation": {
            "name": "animation",
            "type": "string",
            "doc": "Name of an AnimationPrototype."
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation?",
            "doc": "The orientation of the animation. Default is 0."
          },
          "x_scale": {
            "name": "x_scale",
            "type": "double?",
            "doc": "Horizontal scale of the animation. Default is 1."
          },
          "y_scale": {
            "name": "y_scale",
            "type": "double?",
            "doc": "Vertical scale of the animation. Default is 1."
          },
          "tint": {
            "name": "tint",
            "type": "Color?",
            "doc": ""
          },
          "render_layer": {
            "name": "render_layer",
            "type": "RenderLayer?",
            "doc": "Render layer of the animation. Defaults to \"arrow\"."
          },
          "animation_speed": {
            "name": "animation_speed",
            "type": "double?",
            "doc": "How many frames the animation goes forward per tick. Default is 1."
          },
          "animation_offset": {
            "name": "animation_offset",
            "type": "double?",
            "doc": "Offset of the animation in frames. Default is 0."
          },
          "orientation_target": {
            "name": "orientation_target",
            "type": "MapPosition or LuaEntity?",
            "doc": "If given, the animation rotates so that it faces this target. Note that orientation is still applied to the animation."
          },
          "orientation_target_offset": {
            "name": "orientation_target_offset",
            "type": "Vector?",
            "doc": "Only used if orientation_target is a LuaEntity."
          },
          "use_target_orientation": {
            "name": "use_target_orientation",
            "type": "boolean?",
            "doc": "Only used if orientation_target is a LuaEntity."
          },
          "oriented_offset": {
            "name": "oriented_offset",
            "type": "Vector?",
            "doc": "Offsets the center of the animation if orientation_target is given. This offset will rotate together with the animation."
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": "Center of the animation."
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": "Only used if target is a LuaEntity."
          },
          "surface": {
            "name": "surface",
            "type": "SurfaceIdentification",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "In ticks. Defaults to living forever."
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]?",
            "doc": "The forces that this object is rendered to. Passing nil or an empty table will render it to all forces."
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]?",
            "doc": "The players that this object is rendered to. Passing nil or an empty table will render it to all players."
          },
          "visible": {
            "name": "visible",
            "type": "boolean?",
            "doc": "If this is rendered to anyone at all. Defaults to true."
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean?",
            "doc": "If this should only be rendered in alt mode. Defaults to false."
          }
        }
      },
      "destroy": {
        "name": "destroy",
        "doc": "Destroy the object with the given id. Does not error when the object is invalid.",
        "short": "Destroy the object with the given id. [...]",
        "member": "destroy(id)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "is_font_valid": {
        "name": "is_font_valid",
        "type": "function",
        "doc": "Does a font with this name exist?",
        "short": "Does a font with this name exist?",
        "member": "is_font_valid(font_name)  boolean",
        "args": {
          "font_name": {
            "name": "font_name",
            "type": "string",
            "doc": ""
          }
        }
      },
      "is_valid": {
        "name": "is_valid",
        "type": "function",
        "doc": "Does a valid object with this id exist?",
        "short": "Does a valid object with this id exist?",
        "member": "is_valid(id)  boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "get_all_ids": {
        "name": "get_all_ids",
        "type": "function",
        "doc": "Gets an array of all valid object ids.",
        "short": "Gets an array of all valid object ids.",
        "member": "get_all_ids(mod_name?)  array[uint64]",
        "args": {
          "mod_name": {
            "name": "mod_name",
            "type": "string?",
            "doc": "If provided, get only the render objects created by this mod. An empty string (\"\") refers to all objects not belonging to a mod, such as those created using console commands."
          }
        }
      },
      "clear": {
        "name": "clear",
        "doc": "Destroys all render objects.",
        "short": "Destroys all render objects.",
        "member": "clear(mod_name?)",
        "type": "function",
        "args": {
          "mod_name": {
            "name": "mod_name",
            "type": "string?",
            "doc": "If provided, only the render objects created by this mod are destroyed. An empty string (\"\") refers to all objects not belonging to a mod, such as those created using console commands."
          }
        }
      },
      "get_type": {
        "name": "get_type",
        "doc": "Gets the type of the given object.",
        "short": "Gets the type of the given object.",
        "member": "get_type(id)  \"text\" or \"line\" or \"circle\" or \"rectangle\" or \"arc\" or \"polygon\" or \"sprite\" or \"light\" or \"animation\"",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "bring_to_front": {
        "name": "bring_to_front",
        "doc": "Reorder this object so that it is drawn in front of the already existing objects.",
        "short": "Reorder this object so that it is drawn in front of the already existing objects.",
        "member": "bring_to_front(id)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "move_to_back": {
        "name": "move_to_back",
        "doc": "Reorder this object so that it is drawn in the back of the already existing objects.",
        "short": "Reorder this object so that it is drawn in the back of the already existing objects.",
        "member": "move_to_back(id)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "get_surface": {
        "name": "get_surface",
        "type": "function",
        "doc": "The surface the object with this id is rendered on.",
        "short": "The surface the object with this id is rendered on.",
        "member": "get_surface(id)  LuaSurface",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "get_time_to_live": {
        "name": "get_time_to_live",
        "type": "function",
        "doc": "Get the time to live of the object with this id. This will be 0 if the object does not expire.",
        "short": "Get the time to live of the object with this id. [...]",
        "member": "get_time_to_live(id)  uint",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_time_to_live": {
        "name": "set_time_to_live",
        "doc": "Set the time to live of the object with this id. Set to 0 if the object should not expire.",
        "short": "Set the time to live of the object with this id. [...]",
        "member": "set_time_to_live(id, time_to_live)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_forces": {
        "name": "get_forces",
        "type": "function",
        "doc": "Get the forces that the object with this id is rendered to or nil if visible to all forces.",
        "short": "Get the forces that the object with this id is rendered to or nil if visible to all forces.",
        "member": "get_forces(id)  array[LuaForce]?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_forces": {
        "name": "set_forces",
        "doc": "Set the forces that the object with this id is rendered to.",
        "short": "Set the forces that the object with this id is rendered to.",
        "member": "set_forces(id, forces)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "forces": {
            "name": "forces",
            "type": "array[ForceIdentification]",
            "doc": "Providing an empty array will set the object to be visible to all forces."
          }
        }
      },
      "get_players": {
        "name": "get_players",
        "type": "function",
        "doc": "Get the players that the object with this id is rendered to or nil if visible to all players.",
        "short": "Get the players that the object with this id is rendered to or nil if visible to all players.",
        "member": "get_players(id)  array[LuaPlayer]?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_players": {
        "name": "set_players",
        "doc": "Set the players that the object with this id is rendered to.",
        "short": "Set the players that the object with this id is rendered to.",
        "member": "set_players(id, players)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "players": {
            "name": "players",
            "type": "array[PlayerIdentification]",
            "doc": "Providing an empty array will set the object to be visible to all players."
          }
        }
      },
      "get_visible": {
        "name": "get_visible",
        "type": "function",
        "doc": "Get whether this is rendered to anyone at all.",
        "short": "Get whether this is rendered to anyone at all.",
        "member": "get_visible(id)  boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_visible": {
        "name": "set_visible",
        "doc": "Set whether this is rendered to anyone at all.",
        "short": "Set whether this is rendered to anyone at all.",
        "member": "set_visible(id, visible)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "visible": {
            "name": "visible",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_draw_on_ground": {
        "name": "get_draw_on_ground",
        "type": "function",
        "doc": "Get whether this is being drawn on the ground, under most entities and sprites.",
        "short": "Get whether this is being drawn on the ground, under most entities and sprites.",
        "member": "get_draw_on_ground(id)  boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_draw_on_ground": {
        "name": "set_draw_on_ground",
        "doc": "Set whether this is being drawn on the ground, under most entities and sprites.",
        "short": "Set whether this is being drawn on the ground, under most entities and sprites.",
        "member": "set_draw_on_ground(id, draw_on_ground)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "draw_on_ground": {
            "name": "draw_on_ground",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_only_in_alt_mode": {
        "name": "get_only_in_alt_mode",
        "type": "function",
        "doc": "Get whether this is only rendered in alt-mode.",
        "short": "Get whether this is only rendered in alt-mode.",
        "member": "get_only_in_alt_mode(id)  boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_only_in_alt_mode": {
        "name": "set_only_in_alt_mode",
        "doc": "Set whether this is only rendered in alt-mode.",
        "short": "Set whether this is only rendered in alt-mode.",
        "member": "set_only_in_alt_mode(id, only_in_alt_mode)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "only_in_alt_mode": {
            "name": "only_in_alt_mode",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_use_target_orientation": {
        "name": "get_use_target_orientation",
        "type": "function",
        "doc": "Get whether this uses the target orientation. Returns: nil if the object is not a sprite, polygon, or animation.",
        "short": "Get whether this uses the target orientation.",
        "member": "get_use_target_orientation(id)  boolean",
        "returns": "boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_use_target_orientation": {
        "name": "set_use_target_orientation",
        "doc": "Set whether this uses the target orientation.",
        "short": "Set whether this uses the target orientation.",
        "member": "set_use_target_orientation(id, use_target_orientation)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "use_target_orientation": {
            "name": "use_target_orientation",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_color": {
        "name": "get_color",
        "type": "function",
        "doc": "Get the color or tint of the object with this id. Returns: nil if the object does not support color.",
        "short": "Get the color or tint of the object with this id.",
        "member": "get_color(id)  Color?",
        "returns": "Color?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_color": {
        "name": "set_color",
        "doc": "Set the color or tint of the object with this id. Does nothing if this object does not support color.",
        "short": "Set the color or tint of the object with this id. [...]",
        "member": "set_color(id, color)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "color": {
            "name": "color",
            "type": "Color",
            "doc": ""
          }
        }
      },
      "get_width": {
        "name": "get_width",
        "type": "function",
        "doc": "Get the width of the object with this id. Value is in pixels (32 per tile). Returns: nil if the object does not support width.",
        "short": "Get the width of the object with this id. [...]",
        "member": "get_width(id)  float?",
        "returns": "float?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_width": {
        "name": "set_width",
        "doc": "Set the width of the object with this id. Does nothing if this object does not support width. Value is in pixels (32 per tile).",
        "short": "Set the width of the object with this id. [...]",
        "member": "set_width(id, width)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "width": {
            "name": "width",
            "type": "float",
            "doc": ""
          }
        }
      },
      "get_from": {
        "name": "get_from",
        "type": "function",
        "doc": "Get from where the line with this id is drawn. Returns: nil if this object is not a line.",
        "short": "Get from where the line with this id is drawn.",
        "member": "get_from(id)  ScriptRenderTarget?",
        "returns": "ScriptRenderTarget?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_from": {
        "name": "set_from",
        "doc": "Set from where the line with this id is drawn. Does nothing if the object is not a line.",
        "short": "Set from where the line with this id is drawn. [...]",
        "member": "set_from(id, from, from_offset?)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "from": {
            "name": "from",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "from_offset": {
            "name": "from_offset",
            "type": "Vector?",
            "doc": ""
          }
        }
      },
      "get_to": {
        "name": "get_to",
        "type": "function",
        "doc": "Get where the line with this id is drawn to. Returns: nil if the object is not a line.",
        "short": "Get where the line with this id is drawn to.",
        "member": "get_to(id)  ScriptRenderTarget?",
        "returns": "ScriptRenderTarget?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_to": {
        "name": "set_to",
        "doc": "Set where the line with this id is drawn to. Does nothing if this object is not a line.",
        "short": "Set where the line with this id is drawn to. [...]",
        "member": "set_to(id, to, to_offset?)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "to": {
            "name": "to",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "to_offset": {
            "name": "to_offset",
            "type": "Vector?",
            "doc": ""
          }
        }
      },
      "get_dash_length": {
        "name": "get_dash_length",
        "type": "function",
        "doc": "Get the dash length of the line with this id. Returns: nil if the object is not a line.",
        "short": "Get the dash length of the line with this id.",
        "member": "get_dash_length(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_dash_length": {
        "name": "set_dash_length",
        "doc": "Set the dash length of the line with this id. Does nothing if this object is not a line.",
        "short": "Set the dash length of the line with this id. [...]",
        "member": "set_dash_length(id, dash_length)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "dash_length": {
            "name": "dash_length",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_gap_length": {
        "name": "get_gap_length",
        "type": "function",
        "doc": "Get the length of the gaps in the line with this id. Returns: nil if the object is not a line.",
        "short": "Get the length of the gaps in the line with this id.",
        "member": "get_gap_length(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_gap_length": {
        "name": "set_gap_length",
        "doc": "Set the length of the gaps in the line with this id. Does nothing if this object is not a line.",
        "short": "Set the length of the gaps in the line with this id. [...]",
        "member": "set_gap_length(id, gap_length)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "gap_length": {
            "name": "gap_length",
            "type": "double",
            "doc": ""
          }
        }
      },
      "set_dashes": {
        "name": "set_dashes",
        "doc": "Set the length of the dashes and the length of the gaps in the line with this id. Does nothing if this object is not a line.",
        "short": "Set the length of the dashes and the length of the gaps in the line with this id. [...]",
        "member": "set_dashes(id, dash_length, gap_length)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "dash_length": {
            "name": "dash_length",
            "type": "double",
            "doc": ""
          },
          "gap_length": {
            "name": "gap_length",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_target": {
        "name": "get_target",
        "type": "function",
        "doc": "Get where the object with this id is drawn. Returns: nil if the object does not support target.",
        "short": "Get where the object with this id is drawn.",
        "member": "get_target(id)  ScriptRenderTarget?",
        "returns": "ScriptRenderTarget?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_target": {
        "name": "set_target",
        "doc": "Set where the object with this id is drawn. Does nothing if this object does not support target.",
        "short": "Set where the object with this id is drawn. [...]",
        "member": "set_target(id, target, target_offset?)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "target": {
            "name": "target",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "target_offset": {
            "name": "target_offset",
            "type": "Vector?",
            "doc": ""
          }
        }
      },
      "get_orientation": {
        "name": "get_orientation",
        "type": "function",
        "doc": "Get the orientation of the object with this id. Returns: nil if the object is not a text, polygon, sprite, light or animation.",
        "short": "Get the orientation of the object with this id.",
        "member": "get_orientation(id)  RealOrientation?",
        "returns": "RealOrientation?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_orientation": {
        "name": "set_orientation",
        "doc": "Set the orientation of the object with this id. Does nothing if this object is not a text, polygon, sprite, light or animation.",
        "short": "Set the orientation of the object with this id. [...]",
        "member": "set_orientation(id, orientation)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation",
            "doc": ""
          }
        }
      },
      "get_scale": {
        "name": "get_scale",
        "type": "function",
        "doc": "Get the scale of the text or light with this id. Returns: nil if the object is not a text or light.",
        "short": "Get the scale of the text or light with this id.",
        "member": "get_scale(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_scale": {
        "name": "set_scale",
        "doc": "Set the scale of the text or light with this id. Does nothing if this object is not a text or light.",
        "short": "Set the scale of the text or light with this id. [...]",
        "member": "set_scale(id, scale)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "scale": {
            "name": "scale",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_text": {
        "name": "get_text",
        "type": "function",
        "doc": "Get the text that is displayed by the text with this id. Returns: nil if the object is not a text.",
        "short": "Get the text that is displayed by the text with this id.",
        "member": "get_text(id)  LocalisedString?",
        "returns": "LocalisedString?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_text": {
        "name": "set_text",
        "doc": "Set the text that is displayed by the text with this id. Does nothing if this object is not a text.",
        "short": "Set the text that is displayed by the text with this id. [...]",
        "member": "set_text(id, text)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "text": {
            "name": "text",
            "type": "LocalisedString",
            "doc": ""
          }
        }
      },
      "get_font": {
        "name": "get_font",
        "type": "function",
        "doc": "Get the font of the text with this id. Returns: nil if the object is not a text.",
        "short": "Get the font of the text with this id.",
        "member": "get_font(id)  string?",
        "returns": "string?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_font": {
        "name": "set_font",
        "doc": "Set the font of the text with this id. Does nothing if this object is not a text.",
        "short": "Set the font of the text with this id. [...]",
        "member": "set_font(id, font)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "font": {
            "name": "font",
            "type": "string",
            "doc": ""
          }
        }
      },
      "get_alignment": {
        "name": "get_alignment",
        "type": "function",
        "doc": "Get the alignment of the text with this id. Returns: nil if the object is not a text.",
        "short": "Get the alignment of the text with this id.",
        "member": "get_alignment(id)  TextAlign?",
        "returns": "TextAlign?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_alignment": {
        "name": "set_alignment",
        "doc": "Set the alignment of the text with this id. Does nothing if this object is not a text.",
        "short": "Set the alignment of the text with this id. [...]",
        "member": "set_alignment(id, alignment)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "alignment": {
            "name": "alignment",
            "type": "TextAlign",
            "doc": ""
          }
        }
      },
      "get_vertical_alignment": {
        "name": "get_vertical_alignment",
        "type": "function",
        "doc": "Get the vertical alignment of the text with this id. Returns: nil if the object is not a text.",
        "short": "Get the vertical alignment of the text with this id.",
        "member": "get_vertical_alignment(id)  VerticalTextAlign?",
        "returns": "VerticalTextAlign?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_vertical_alignment": {
        "name": "set_vertical_alignment",
        "doc": "Set the vertical alignment of the text with this id. Does nothing if this object is not a text.",
        "short": "Set the vertical alignment of the text with this id. [...]",
        "member": "set_vertical_alignment(id, alignment)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "alignment": {
            "name": "alignment",
            "type": "VerticalTextAlign",
            "doc": ""
          }
        }
      },
      "get_scale_with_zoom": {
        "name": "get_scale_with_zoom",
        "type": "function",
        "doc": "Get if the text with this id scales with player zoom. Returns: nil if the object is not a text.",
        "short": "Get if the text with this id scales with player zoom.",
        "member": "get_scale_with_zoom(id)  boolean?",
        "returns": "boolean?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_scale_with_zoom": {
        "name": "set_scale_with_zoom",
        "doc": "Set if the text with this id scales with player zoom, resulting in it always being the same size on screen, and the size compared to the game world changes. Does nothing if this object is not a text.",
        "short": "Set if the text with this id scales with player zoom, resulting in it always being the same size on screen, and the size compared to the game world changes. [...]",
        "member": "set_scale_with_zoom(id, scale_with_zoom)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "scale_with_zoom": {
            "name": "scale_with_zoom",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_use_rich_text": {
        "name": "get_use_rich_text",
        "type": "function",
        "doc": "Get if the text with this id parses rich text tags. Returns: nil if the object is not a text.",
        "short": "Get if the text with this id parses rich text tags.",
        "member": "get_use_rich_text(id)  boolean?",
        "returns": "boolean?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_use_rich_text": {
        "name": "set_use_rich_text",
        "doc": "Set if the text with this id parses rich text tags.",
        "short": "Set if the text with this id parses rich text tags.",
        "member": "set_use_rich_text(id, use_rich_text)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "use_rich_text": {
            "name": "use_rich_text",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_filled": {
        "name": "get_filled",
        "type": "function",
        "doc": "Get if the circle or rectangle with this id is filled. Returns: nil if the object is not a circle or rectangle.",
        "short": "Get if the circle or rectangle with this id is filled.",
        "member": "get_filled(id)  boolean?",
        "returns": "boolean?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_filled": {
        "name": "set_filled",
        "doc": "Set if the circle or rectangle with this id is filled. Does nothing if this object is not a circle or rectangle.",
        "short": "Set if the circle or rectangle with this id is filled. [...]",
        "member": "set_filled(id, filled)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "filled": {
            "name": "filled",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_radius": {
        "name": "get_radius",
        "type": "function",
        "doc": "Get the radius of the circle with this id. Returns: nil if the object is not a circle.",
        "short": "Get the radius of the circle with this id.",
        "member": "get_radius(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_radius": {
        "name": "set_radius",
        "doc": "Set the radius of the circle with this id. Does nothing if this object is not a circle.",
        "short": "Set the radius of the circle with this id. [...]",
        "member": "set_radius(id, radius)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "radius": {
            "name": "radius",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_left_top": {
        "name": "get_left_top",
        "type": "function",
        "doc": "Get where top left corner of the rectangle with this id is drawn. Returns: nil if the object is not a rectangle.",
        "short": "Get where top left corner of the rectangle with this id is drawn.",
        "member": "get_left_top(id)  ScriptRenderTarget?",
        "returns": "ScriptRenderTarget?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_left_top": {
        "name": "set_left_top",
        "doc": "Set where top left corner of the rectangle with this id is drawn. Does nothing if this object is not a rectangle.",
        "short": "Set where top left corner of the rectangle with this id is drawn. [...]",
        "member": "set_left_top(id, left_top, left_top_offset?)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "left_top": {
            "name": "left_top",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "left_top_offset": {
            "name": "left_top_offset",
            "type": "Vector?",
            "doc": ""
          }
        }
      },
      "get_right_bottom": {
        "name": "get_right_bottom",
        "type": "function",
        "doc": "Get where bottom right corner of the rectangle with this id is drawn. Returns: nil if the object is not a rectangle.",
        "short": "Get where bottom right corner of the rectangle with this id is drawn.",
        "member": "get_right_bottom(id)  ScriptRenderTarget?",
        "returns": "ScriptRenderTarget?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_right_bottom": {
        "name": "set_right_bottom",
        "doc": "Set where top bottom right of the rectangle with this id is drawn. Does nothing if this object is not a rectangle.",
        "short": "Set where top bottom right of the rectangle with this id is drawn. [...]",
        "member": "set_right_bottom(id, right_bottom, right_bottom_offset?)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "right_bottom": {
            "name": "right_bottom",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "right_bottom_offset": {
            "name": "right_bottom_offset",
            "type": "Vector?",
            "doc": ""
          }
        }
      },
      "set_corners": {
        "name": "set_corners",
        "doc": "Set the corners of the rectangle with this id. Does nothing if this object is not a rectangle.",
        "short": "Set the corners of the rectangle with this id. [...]",
        "member": "set_corners(id, left_top, left_top_offset, right_bottom, right_bottom_offset)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "left_top": {
            "name": "left_top",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "left_top_offset": {
            "name": "left_top_offset",
            "type": "Vector",
            "doc": ""
          },
          "right_bottom": {
            "name": "right_bottom",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "right_bottom_offset": {
            "name": "right_bottom_offset",
            "type": "Vector",
            "doc": ""
          }
        }
      },
      "get_max_radius": {
        "name": "get_max_radius",
        "type": "function",
        "doc": "Get the radius of the outer edge of the arc with this id. Returns: nil if the object is not a arc.",
        "short": "Get the radius of the outer edge of the arc with this id.",
        "member": "get_max_radius(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_max_radius": {
        "name": "set_max_radius",
        "doc": "Set the radius of the outer edge of the arc with this id. Does nothing if this object is not a arc.",
        "short": "Set the radius of the outer edge of the arc with this id. [...]",
        "member": "set_max_radius(id, max_radius)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "max_radius": {
            "name": "max_radius",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_min_radius": {
        "name": "get_min_radius",
        "type": "function",
        "doc": "Get the radius of the inner edge of the arc with this id. Returns: nil if the object is not a arc.",
        "short": "Get the radius of the inner edge of the arc with this id.",
        "member": "get_min_radius(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_min_radius": {
        "name": "set_min_radius",
        "doc": "Set the radius of the inner edge of the arc with this id. Does nothing if this object is not a arc.",
        "short": "Set the radius of the inner edge of the arc with this id. [...]",
        "member": "set_min_radius(id, min_radius)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "min_radius": {
            "name": "min_radius",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_start_angle": {
        "name": "get_start_angle",
        "type": "function",
        "doc": "Get where the arc with this id starts. Returns: Angle in radian. nil if the object is not a arc.",
        "short": "Get where the arc with this id starts.",
        "member": "get_start_angle(id)  float?",
        "returns": "float?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_start_angle": {
        "name": "set_start_angle",
        "doc": "Set where the arc with this id starts. Does nothing if this object is not a arc.",
        "short": "Set where the arc with this id starts. [...]",
        "member": "set_start_angle(id, start_angle)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "start_angle": {
            "name": "start_angle",
            "type": "float",
            "doc": "angle in radian"
          }
        }
      },
      "get_angle": {
        "name": "get_angle",
        "type": "function",
        "doc": "Get the angle of the arc with this id. Returns: Angle in radian. nil if the object is not a arc.",
        "short": "Get the angle of the arc with this id.",
        "member": "get_angle(id)  float?",
        "returns": "float?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_angle": {
        "name": "set_angle",
        "doc": "Set the angle of the arc with this id. Does nothing if this object is not a arc.",
        "short": "Set the angle of the arc with this id. [...]",
        "member": "set_angle(id, angle)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "angle": {
            "name": "angle",
            "type": "float",
            "doc": "angle in radian"
          }
        }
      },
      "get_vertices": {
        "name": "get_vertices",
        "type": "function",
        "doc": "Get the vertices of the polygon with this id. Returns: nil if the object is not a polygon.",
        "short": "Get the vertices of the polygon with this id.",
        "member": "get_vertices(id)  array[ScriptRenderTarget]?",
        "returns": "array[ScriptRenderTarget]?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_vertices": {
        "name": "set_vertices",
        "doc": "Set the vertices of the polygon with this id. Does nothing if this object is not a polygon.",
        "short": "Set the vertices of the polygon with this id. [...]",
        "member": "set_vertices(id, vertices)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "vertices": {
            "name": "vertices",
            "type": "array[ScriptRenderVertexTarget]",
            "doc": ""
          }
        }
      },
      "get_sprite": {
        "name": "get_sprite",
        "type": "function",
        "doc": "Get the sprite of the sprite or light with this id. Returns: nil if the object is not a sprite or light.",
        "short": "Get the sprite of the sprite or light with this id.",
        "member": "get_sprite(id)  SpritePath?",
        "returns": "SpritePath?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_sprite": {
        "name": "set_sprite",
        "doc": "Set the sprite of the sprite or light with this id. Does nothing if this object is not a sprite or light.",
        "short": "Set the sprite of the sprite or light with this id. [...]",
        "member": "set_sprite(id, sprite)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "sprite": {
            "name": "sprite",
            "type": "SpritePath",
            "doc": ""
          }
        }
      },
      "get_x_scale": {
        "name": "get_x_scale",
        "type": "function",
        "doc": "Get the horizontal scale of the sprite or animation with this id. Returns: nil if the object is not a sprite or animation.",
        "short": "Get the horizontal scale of the sprite or animation with this id.",
        "member": "get_x_scale(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_x_scale": {
        "name": "set_x_scale",
        "doc": "Set the horizontal scale of the sprite or animation with this id. Does nothing if this object is not a sprite or animation.",
        "short": "Set the horizontal scale of the sprite or animation with this id. [...]",
        "member": "set_x_scale(id, x_scale)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "x_scale": {
            "name": "x_scale",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_y_scale": {
        "name": "get_y_scale",
        "type": "function",
        "doc": "Get the vertical scale of the sprite or animation with this id. Returns: nil if the object is not a sprite or animation.",
        "short": "Get the vertical scale of the sprite or animation with this id.",
        "member": "get_y_scale(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_y_scale": {
        "name": "set_y_scale",
        "doc": "Set the vertical scale of the sprite or animation with this id. Does nothing if this object is not a sprite or animation.",
        "short": "Set the vertical scale of the sprite or animation with this id. [...]",
        "member": "set_y_scale(id, y_scale)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "y_scale": {
            "name": "y_scale",
            "type": "double",
            "doc": ""
          }
        }
      },
      "get_render_layer": {
        "name": "get_render_layer",
        "type": "function",
        "doc": "Get the render layer of the sprite or animation with this id. Returns: nil if the object is not a sprite or animation.",
        "short": "Get the render layer of the sprite or animation with this id.",
        "member": "get_render_layer(id)  RenderLayer?",
        "returns": "RenderLayer?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_render_layer": {
        "name": "set_render_layer",
        "doc": "Set the render layer of the sprite or animation with this id. Does nothing if this object is not a sprite or animation.",
        "short": "Set the render layer of the sprite or animation with this id. [...]",
        "member": "set_render_layer(id, render_layer)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "render_layer": {
            "name": "render_layer",
            "type": "RenderLayer",
            "doc": ""
          }
        }
      },
      "get_orientation_target": {
        "name": "get_orientation_target",
        "type": "function",
        "doc": "The object rotates so that it faces this target. Note that orientation is still applied to the object. Get the orientation_target of the object with this id. Returns: nil if no target or if this object is not a polygon, sprite, or animation.",
        "short": "The object rotates so that it faces this target. [...]",
        "member": "get_orientation_target(id)  ScriptRenderTarget?",
        "returns": "ScriptRenderTarget?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_orientation_target": {
        "name": "set_orientation_target",
        "doc": "The object rotates so that it faces this target. Note that orientation is still applied to the object. Set the orientation_target of the object with this id. Does nothing if this object is not a polygon, sprite, or animation. Set to nil if the object should not have an orientation_target.",
        "short": "The object rotates so that it faces this target. [...]",
        "member": "set_orientation_target(id, orientation_target, orientation_target_offset?)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "orientation_target": {
            "name": "orientation_target",
            "type": "MapPosition or LuaEntity",
            "doc": ""
          },
          "orientation_target_offset": {
            "name": "orientation_target_offset",
            "type": "Vector?",
            "doc": ""
          }
        }
      },
      "get_oriented_offset": {
        "name": "get_oriented_offset",
        "type": "function",
        "doc": "Offsets the center of the sprite or animation if orientation_target is given. This offset will rotate together with the sprite or animation. Get the oriented_offset of the sprite or animation with this id. Returns: nil if this object is not a sprite or animation.",
        "short": "Offsets the center of the sprite or animation if orientation_target is given. [...]",
        "member": "get_oriented_offset(id)  Vector?",
        "returns": "Vector?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_oriented_offset": {
        "name": "set_oriented_offset",
        "doc": "Offsets the center of the sprite or animation if orientation_target is given. This offset will rotate together with the sprite or animation. Set the oriented_offset of the sprite or animation with this id. Does nothing if this object is not a sprite or animation.",
        "short": "Offsets the center of the sprite or animation if orientation_target is given. [...]",
        "member": "set_oriented_offset(id, oriented_offset)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "oriented_offset": {
            "name": "oriented_offset",
            "type": "Vector",
            "doc": ""
          }
        }
      },
      "get_intensity": {
        "name": "get_intensity",
        "type": "function",
        "doc": "Get the intensity of the light with this id. Returns: nil if the object is not a light.",
        "short": "Get the intensity of the light with this id.",
        "member": "get_intensity(id)  float?",
        "returns": "float?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_intensity": {
        "name": "set_intensity",
        "doc": "Set the intensity of the light with this id. Does nothing if this object is not a light.",
        "short": "Set the intensity of the light with this id. [...]",
        "member": "set_intensity(id, intensity)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "intensity": {
            "name": "intensity",
            "type": "float",
            "doc": ""
          }
        }
      },
      "get_minimum_darkness": {
        "name": "get_minimum_darkness",
        "type": "function",
        "doc": "Get the minimum darkness at which the light with this id is rendered. Returns: nil if the object is not a light.",
        "short": "Get the minimum darkness at which the light with this id is rendered.",
        "member": "get_minimum_darkness(id)  float?",
        "returns": "float?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_minimum_darkness": {
        "name": "set_minimum_darkness",
        "doc": "Set the minimum darkness at which the light with this id is rendered. Does nothing if this object is not a light.",
        "short": "Set the minimum darkness at which the light with this id is rendered. [...]",
        "member": "set_minimum_darkness(id, minimum_darkness)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "minimum_darkness": {
            "name": "minimum_darkness",
            "type": "float",
            "doc": ""
          }
        }
      },
      "get_oriented": {
        "name": "get_oriented",
        "type": "function",
        "doc": "Get if the light with this id is rendered has the same orientation as the target entity. Note that orientation is still applied to the sprite. Returns: nil if the object is not a light.",
        "short": "Get if the light with this id is rendered has the same orientation as the target entity. [...]",
        "member": "get_oriented(id)  boolean?",
        "returns": "boolean?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_oriented": {
        "name": "set_oriented",
        "doc": "Set if the light with this id is rendered has the same orientation as the target entity. Does nothing if this object is not a light. Note that orientation is still applied to the sprite.",
        "short": "Set if the light with this id is rendered has the same orientation as the target entity. [...]",
        "member": "set_oriented(id, oriented)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "oriented": {
            "name": "oriented",
            "type": "boolean",
            "doc": ""
          }
        }
      },
      "get_animation": {
        "name": "get_animation",
        "type": "function",
        "doc": "Get the animation prototype name of the animation with this id. Returns: nil if the object is not an animation.",
        "short": "Get the animation prototype name of the animation with this id.",
        "member": "get_animation(id)  string?",
        "returns": "string?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_animation": {
        "name": "set_animation",
        "doc": "Set the animation prototype name of the animation with this id. Does nothing if this object is not an animation.",
        "short": "Set the animation prototype name of the animation with this id. [...]",
        "member": "set_animation(id, animation)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "animation": {
            "name": "animation",
            "type": "string",
            "doc": ""
          }
        }
      },
      "get_animation_speed": {
        "name": "get_animation_speed",
        "type": "function",
        "doc": "Get the animation speed of the animation with this id. Returns: Animation speed in frames per tick. nil if the object is not an animation.",
        "short": "Get the animation speed of the animation with this id.",
        "member": "get_animation_speed(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_animation_speed": {
        "name": "set_animation_speed",
        "doc": "Set the animation speed of the animation with this id. Does nothing if this object is not an animation.",
        "short": "Set the animation speed of the animation with this id. [...]",
        "member": "set_animation_speed(id, animation_speed)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "animation_speed": {
            "name": "animation_speed",
            "type": "double",
            "doc": "Animation speed in frames per tick."
          }
        }
      },
      "get_animation_offset": {
        "name": "get_animation_offset",
        "type": "function",
        "doc": "Get the animation offset of the animation with this id. Returns: Animation offset in frames. nil if the object is not an animation.",
        "short": "Get the animation offset of the animation with this id.",
        "member": "get_animation_offset(id)  double?",
        "returns": "double?",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          }
        }
      },
      "set_animation_offset": {
        "name": "set_animation_offset",
        "doc": "Set the animation offset of the animation with this id. Does nothing if this object is not an animation.",
        "short": "Set the animation offset of the animation with this id. [...]",
        "member": "set_animation_offset(id, animation_offset)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint64",
            "doc": ""
          },
          "animation_offset": {
            "name": "animation_offset",
            "type": "double",
            "doc": "Animation offset in frames."
          }
        }
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaResourceCategoryPrototype": {
    "name": "LuaResourceCategoryPrototype",
    "type": "LuaResourceCategoryPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaRoboportControlBehavior": {
    "name": "LuaRoboportControlBehavior",
    "type": "LuaRoboportControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "read_logistics": {
        "name": "read_logistics",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the roboport should report the logistics network content to the circuit network.",
        "short": "true if the roboport should report the logistics network content to the circuit network.",
        "member": "read_logistics  ::boolean Read/Write"
      },
      "read_robot_stats": {
        "name": "read_robot_stats",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the roboport should report the robot statistics to the circuit network.",
        "short": "true if the roboport should report the robot statistics to the circuit network.",
        "member": "read_robot_stats  ::boolean Read/Write"
      },
      "available_logistic_output_signal": {
        "name": "available_logistic_output_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "available_logistic_output_signal  ::SignalID Read/Write"
      },
      "total_logistic_output_signal": {
        "name": "total_logistic_output_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "total_logistic_output_signal  ::SignalID Read/Write"
      },
      "available_construction_output_signal": {
        "name": "available_construction_output_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "available_construction_output_signal  ::SignalID Read/Write"
      },
      "total_construction_output_signal": {
        "name": "total_construction_output_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "total_construction_output_signal  ::SignalID Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaSettings": {
    "name": "LuaSettings",
    "type": "LuaSettings",
    "inherits": [],
    "properties": {
      "get_player_settings": {
        "name": "get_player_settings",
        "type": "function",
        "doc": "Gets the current per-player settings for the given player, indexed by prototype name. Returns the same structure as LuaPlayer::mod_settings. This table becomes invalid if its associated player does.",
        "short": "Gets the current per-player settings for the given player, indexed by prototype name. [...]",
        "member": "get_player_settings(player)  LuaCustomTable[string ModSetting]",
        "args": {
          "player": {
            "name": "player",
            "type": "PlayerIdentification",
            "doc": ""
          }
        }
      },
      "startup": {
        "name": "startup",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "The startup mod settings, indexed by prototype name.",
        "short": "The startup mod settings, indexed by prototype name.",
        "member": "startup  ::LuaCustomTable[string ModSetting] Read"
      },
      "global": {
        "name": "global",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "The current global mod settings, indexed by prototype name.",
        "short": "The current global mod settings, indexed by prototype name. [...]",
        "member": "global  ::LuaCustomTable[string ModSetting] Read"
      },
      "player": {
        "name": "player",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "The default player mod settings for this map, indexed by prototype name.",
        "short": "The default player mod settings for this map, indexed by prototype name. [...]",
        "member": "player  ::LuaCustomTable[string ModSetting] Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "This object's name.",
        "short": "This object's name.",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaShortcutPrototype": {
    "name": "LuaShortcutPrototype",
    "type": "LuaShortcutPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "action": {
        "name": "action",
        "type": "string",
        "mode": "[R]",
        "member": "action  ::string Read"
      },
      "item_to_spawn": {
        "name": "item_to_spawn",
        "type": "LuaItemPrototype",
        "mode": "[R]",
        "doc": "The item to create when this shortcut is used, if any.",
        "short": "The item to create when this shortcut is used, if any.",
        "member": "item_to_spawn  ::LuaItemPrototype? Read"
      },
      "technology_to_unlock": {
        "name": "technology_to_unlock",
        "type": "LuaTechnologyPrototype",
        "mode": "[R]",
        "doc": "The technology that needs to be researched once (in any save) for this shortcut to be unlocked (in all saves).",
        "short": "The technology that needs to be researched once (in any save) for this shortcut to be unlocked (in all saves).",
        "member": "technology_to_unlock  ::LuaTechnologyPrototype? Read"
      },
      "toggleable": {
        "name": "toggleable",
        "type": "boolean",
        "mode": "[R]",
        "member": "toggleable  ::boolean Read"
      },
      "associated_control_input": {
        "name": "associated_control_input",
        "type": "string",
        "mode": "[R]",
        "doc": "The control input that is associated with this shortcut, if any.",
        "short": "The control input that is associated with this shortcut, if any.",
        "member": "associated_control_input  ::string? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaStorageTankControlBehavior": {
    "name": "LuaStorageTankControlBehavior",
    "type": "LuaStorageTankControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaStyle": {
    "name": "LuaStyle",
    "type": "LuaStyle",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[R]",
        "doc": "Gui of the LuaGuiElement of this style.",
        "short": "Gui of the LuaGuiElement of this style.",
        "member": "gui  ::LuaGui Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this style.",
        "short": "Name of this style.",
        "member": "name  ::string Read"
      },
      "minimal_width": {
        "name": "minimal_width",
        "type": "int",
        "mode": "[RW]",
        "doc": "Minimal width ensures, that the widget will never be smaller than than that size. It can't be squashed to be smaller.",
        "short": "Minimal width ensures, that the widget will never be smaller than than that size. [...]",
        "member": "minimal_width  ::int Read/Write"
      },
      "maximal_width": {
        "name": "maximal_width",
        "type": "int",
        "mode": "[RW]",
        "doc": "Maximal width ensures, that the widget will never be bigger than than that size. It can't be stretched to be bigger.",
        "short": "Maximal width ensures, that the widget will never be bigger than than that size. [...]",
        "member": "maximal_width  ::int Read/Write"
      },
      "minimal_height": {
        "name": "minimal_height",
        "type": "int",
        "mode": "[RW]",
        "doc": "Minimal height ensures, that the widget will never be smaller than than that size. It can't be squashed to be smaller.",
        "short": "Minimal height ensures, that the widget will never be smaller than than that size. [...]",
        "member": "minimal_height  ::int Read/Write"
      },
      "maximal_height": {
        "name": "maximal_height",
        "type": "int",
        "mode": "[RW]",
        "doc": "Maximal height ensures, that the widget will never be bigger than than that size. It can't be stretched to be bigger.",
        "short": "Maximal height ensures, that the widget will never be bigger than than that size. [...]",
        "member": "maximal_height  ::int Read/Write"
      },
      "natural_width": {
        "name": "natural_width",
        "type": "int",
        "mode": "[RW]",
        "doc": "Natural width specifies the width of the element tries to have, but it can still be squashed/stretched to have a smaller or bigger size.",
        "short": "Natural width specifies the width of the element tries to have, but it can still be squashed/stretched to have a smaller or bigger size.",
        "member": "natural_width  ::int Read/Write"
      },
      "natural_height": {
        "name": "natural_height",
        "type": "int",
        "mode": "[RW]",
        "doc": "Natural height specifies the height of the element tries to have, but it can still be squashed/stretched to have a smaller or bigger size.",
        "short": "Natural height specifies the height of the element tries to have, but it can still be squashed/stretched to have a smaller or bigger size.",
        "member": "natural_height  ::int Read/Write"
      },
      "top_padding": {
        "name": "top_padding",
        "type": "int",
        "mode": "[RW]",
        "member": "top_padding  ::int Read/Write"
      },
      "right_padding": {
        "name": "right_padding",
        "type": "int",
        "mode": "[RW]",
        "member": "right_padding  ::int Read/Write"
      },
      "bottom_padding": {
        "name": "bottom_padding",
        "type": "int",
        "mode": "[RW]",
        "member": "bottom_padding  ::int Read/Write"
      },
      "left_padding": {
        "name": "left_padding",
        "type": "int",
        "mode": "[RW]",
        "member": "left_padding  ::int Read/Write"
      },
      "top_margin": {
        "name": "top_margin",
        "type": "int",
        "mode": "[RW]",
        "member": "top_margin  ::int Read/Write"
      },
      "right_margin": {
        "name": "right_margin",
        "type": "int",
        "mode": "[RW]",
        "member": "right_margin  ::int Read/Write"
      },
      "bottom_margin": {
        "name": "bottom_margin",
        "type": "int",
        "mode": "[RW]",
        "member": "bottom_margin  ::int Read/Write"
      },
      "left_margin": {
        "name": "left_margin",
        "type": "int",
        "mode": "[RW]",
        "member": "left_margin  ::int Read/Write"
      },
      "horizontal_align": {
        "name": "horizontal_align",
        "mode": "[RW]",
        "doc": "Horizontal align of the inner content of the widget, if any.",
        "short": "Horizontal align of the inner content of the widget, if any.",
        "member": "horizontal_align  ::\"left\" or \"center\" or \"right\"? Read/Write"
      },
      "vertical_align": {
        "name": "vertical_align",
        "mode": "[RW]",
        "doc": "Vertical align of the inner content of the widget, if any.",
        "short": "Vertical align of the inner content of the widget, if any.",
        "member": "vertical_align  ::\"top\" or \"center\" or \"bottom\"? Read/Write"
      },
      "font_color": {
        "name": "font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "font_color  ::Color Read/Write"
      },
      "font": {
        "name": "font",
        "type": "string",
        "mode": "[RW]",
        "member": "font  ::string Read/Write"
      },
      "top_cell_padding": {
        "name": "top_cell_padding",
        "type": "int",
        "mode": "[RW]",
        "doc": "Space between the table cell contents top and border.",
        "short": "Space between the table cell contents top and border.",
        "member": "top_cell_padding  ::int Read/Write"
      },
      "right_cell_padding": {
        "name": "right_cell_padding",
        "type": "int",
        "mode": "[RW]",
        "doc": "Space between the table cell contents right and border.",
        "short": "Space between the table cell contents right and border.",
        "member": "right_cell_padding  ::int Read/Write"
      },
      "bottom_cell_padding": {
        "name": "bottom_cell_padding",
        "type": "int",
        "mode": "[RW]",
        "doc": "Space between the table cell contents bottom and border.",
        "short": "Space between the table cell contents bottom and border.",
        "member": "bottom_cell_padding  ::int Read/Write"
      },
      "left_cell_padding": {
        "name": "left_cell_padding",
        "type": "int",
        "mode": "[RW]",
        "doc": "Space between the table cell contents left and border.",
        "short": "Space between the table cell contents left and border.",
        "member": "left_cell_padding  ::int Read/Write"
      },
      "horizontally_stretchable": {
        "name": "horizontally_stretchable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the GUI element stretches its size horizontally to other elements. nil if this element does not support stretching.",
        "short": "Whether the GUI element stretches its size horizontally to other elements. [...]",
        "member": "horizontally_stretchable  ::boolean? Read/Write"
      },
      "vertically_stretchable": {
        "name": "vertically_stretchable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the GUI element stretches its size vertically to other elements. nil if this element does not support stretching.",
        "short": "Whether the GUI element stretches its size vertically to other elements. [...]",
        "member": "vertically_stretchable  ::boolean? Read/Write"
      },
      "horizontally_squashable": {
        "name": "horizontally_squashable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the GUI element can be squashed (by maximal width of some parent element) horizontally. nil if this element does not support squashing. This is mainly meant to be used for scroll-pane The default value is false.",
        "short": "Whether the GUI element can be squashed (by maximal width of some parent element) horizontally. [...]",
        "member": "horizontally_squashable  ::boolean? Read/Write"
      },
      "vertically_squashable": {
        "name": "vertically_squashable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Whether the GUI element can be squashed (by maximal height of some parent element) vertically. nil if this element does not support squashing. This is mainly meant to be used for scroll-pane The default (parent) value for scroll pane is true, false otherwise.",
        "short": "Whether the GUI element can be squashed (by maximal height of some parent element) vertically. [...]",
        "member": "vertically_squashable  ::boolean? Read/Write"
      },
      "rich_text_setting": {
        "name": "rich_text_setting",
        "type": "defines.rich_text_setting",
        "mode": "[RW]",
        "doc": "How this GUI element handles rich text.",
        "short": "How this GUI element handles rich text.",
        "member": "rich_text_setting  ::defines.rich_text_setting Read/Write"
      },
      "hovered_font_color": {
        "name": "hovered_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "hovered_font_color  ::Color Read/Write"
      },
      "clicked_font_color": {
        "name": "clicked_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "clicked_font_color  ::Color Read/Write"
      },
      "disabled_font_color": {
        "name": "disabled_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "disabled_font_color  ::Color Read/Write"
      },
      "pie_progress_color": {
        "name": "pie_progress_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "pie_progress_color  ::Color Read/Write"
      },
      "clicked_vertical_offset": {
        "name": "clicked_vertical_offset",
        "type": "int",
        "mode": "[RW]",
        "member": "clicked_vertical_offset  ::int Read/Write"
      },
      "selected_font_color": {
        "name": "selected_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "selected_font_color  ::Color Read/Write"
      },
      "selected_hovered_font_color": {
        "name": "selected_hovered_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "selected_hovered_font_color  ::Color Read/Write"
      },
      "selected_clicked_font_color": {
        "name": "selected_clicked_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "selected_clicked_font_color  ::Color Read/Write"
      },
      "strikethrough_color": {
        "name": "strikethrough_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "strikethrough_color  ::Color Read/Write"
      },
      "draw_grayscale_picture": {
        "name": "draw_grayscale_picture",
        "type": "boolean",
        "mode": "[RW]",
        "member": "draw_grayscale_picture  ::boolean Read/Write"
      },
      "horizontal_spacing": {
        "name": "horizontal_spacing",
        "type": "int",
        "mode": "[RW]",
        "doc": "Horizontal space between individual cells.",
        "short": "Horizontal space between individual cells.",
        "member": "horizontal_spacing  ::int Read/Write"
      },
      "vertical_spacing": {
        "name": "vertical_spacing",
        "type": "int",
        "mode": "[RW]",
        "doc": "Vertical space between individual cells.",
        "short": "Vertical space between individual cells.",
        "member": "vertical_spacing  ::int Read/Write"
      },
      "use_header_filler": {
        "name": "use_header_filler",
        "type": "boolean",
        "mode": "[RW]",
        "member": "use_header_filler  ::boolean Read/Write"
      },
      "bar_width": {
        "name": "bar_width",
        "type": "uint",
        "mode": "[RW]",
        "member": "bar_width  ::uint Read/Write"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[RW]",
        "member": "color  ::Color Read/Write"
      },
      "column_alignments": {
        "name": "column_alignments",
        "type": "LuaCustomTable",
        "mode": "[R]",
        "doc": "Array containing the alignment for every column of this table element. Even though this property is marked as read-only, the alignment can be changed by indexing the LuaCustomTable, like so:",
        "short": "Array containing the alignment for every column of this table element. [...]",
        "member": "column_alignments  ::LuaCustomTable[uint Alignment] Read"
      },
      "single_line": {
        "name": "single_line",
        "type": "boolean",
        "mode": "[RW]",
        "member": "single_line  ::boolean Read/Write"
      },
      "extra_top_padding_when_activated": {
        "name": "extra_top_padding_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_top_padding_when_activated  ::int Read/Write"
      },
      "extra_bottom_padding_when_activated": {
        "name": "extra_bottom_padding_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_bottom_padding_when_activated  ::int Read/Write"
      },
      "extra_left_padding_when_activated": {
        "name": "extra_left_padding_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_left_padding_when_activated  ::int Read/Write"
      },
      "extra_right_padding_when_activated": {
        "name": "extra_right_padding_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_right_padding_when_activated  ::int Read/Write"
      },
      "extra_top_margin_when_activated": {
        "name": "extra_top_margin_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_top_margin_when_activated  ::int Read/Write"
      },
      "extra_bottom_margin_when_activated": {
        "name": "extra_bottom_margin_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_bottom_margin_when_activated  ::int Read/Write"
      },
      "extra_left_margin_when_activated": {
        "name": "extra_left_margin_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_left_margin_when_activated  ::int Read/Write"
      },
      "extra_right_margin_when_activated": {
        "name": "extra_right_margin_when_activated",
        "type": "int",
        "mode": "[RW]",
        "member": "extra_right_margin_when_activated  ::int Read/Write"
      },
      "stretch_image_to_widget_size": {
        "name": "stretch_image_to_widget_size",
        "type": "boolean",
        "mode": "[RW]",
        "member": "stretch_image_to_widget_size  ::boolean Read/Write"
      },
      "badge_font": {
        "name": "badge_font",
        "type": "string",
        "mode": "[RW]",
        "member": "badge_font  ::string Read/Write"
      },
      "badge_horizontal_spacing": {
        "name": "badge_horizontal_spacing",
        "type": "int",
        "mode": "[RW]",
        "member": "badge_horizontal_spacing  ::int Read/Write"
      },
      "default_badge_font_color": {
        "name": "default_badge_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "default_badge_font_color  ::Color Read/Write"
      },
      "selected_badge_font_color": {
        "name": "selected_badge_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "selected_badge_font_color  ::Color Read/Write"
      },
      "disabled_badge_font_color": {
        "name": "disabled_badge_font_color",
        "type": "Color",
        "mode": "[RW]",
        "member": "disabled_badge_font_color  ::Color Read/Write"
      },
      "width": {
        "name": "width",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets both minimal and maximal width to the given value.",
        "short": "Sets both minimal and maximal width to the given value.",
        "member": "width  ::int Write"
      },
      "height": {
        "name": "height",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets both minimal and maximal height to the given value.",
        "short": "Sets both minimal and maximal height to the given value.",
        "member": "height  ::int Write"
      },
      "size": {
        "name": "size",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets both width and height to the given value. Also accepts an array with two values, setting width to the first and height to the second one.",
        "short": "Sets both width and height to the given value. [...]",
        "member": "size  ::int or array[int] Write"
      },
      "padding": {
        "name": "padding",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets top/right/bottom/left paddings to this value. An array with two values sets top/bottom padding to the first value and left/right padding to the second value. An array with four values sets top, right, bottom, left padding respectively.",
        "short": "Sets top/right/bottom/left paddings to this value. [...]",
        "member": "padding  ::int or array[int] Write"
      },
      "margin": {
        "name": "margin",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets top/right/bottom/left margins to this value. An array with two values sets top/bottom margin to the first value and left/right margin to the second value. An array with four values sets top, right, bottom, left margin respectively.",
        "short": "Sets top/right/bottom/left margins to this value. [...]",
        "member": "margin  ::int or array[int] Write"
      },
      "cell_padding": {
        "name": "cell_padding",
        "type": "int",
        "mode": "[W]",
        "doc": "Space between the table cell contents and border. Sets top/right/bottom/left cell paddings to this value.",
        "short": "Space between the table cell contents and border. [...]",
        "member": "cell_padding  ::int Write"
      },
      "extra_padding_when_activated": {
        "name": "extra_padding_when_activated",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets extra_top/right/bottom/left_padding_when_activated to this value. An array with two values sets top/bottom padding to the first value and left/right padding to the second value. An array with four values sets top, right, bottom, left padding respectively.",
        "short": "Sets extra_top/right/bottom/left_padding_when_activated to this value. [...]",
        "member": "extra_padding_when_activated  ::int or array[int] Write"
      },
      "extra_margin_when_activated": {
        "name": "extra_margin_when_activated",
        "type": "int",
        "mode": "[W]",
        "doc": "Sets extra_top/right/bottom/left_margin_when_activated to this value. An array with two values sets top/bottom margin to the first value and left/right margin to the second value. An array with four values sets top, right, bottom, left margin respectively.",
        "short": "Sets extra_top/right/bottom/left_margin_when_activated to this value. [...]",
        "member": "extra_margin_when_activated  ::int or array[int] Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaSurface": {
    "name": "LuaSurface",
    "type": "LuaSurface",
    "inherits": [],
    "properties": {
      "get_pollution": {
        "name": "get_pollution",
        "type": "function",
        "doc": "Get the pollution for a given position.",
        "short": "Get the pollution for a given position.",
        "member": "get_pollution(position)  double",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          }
        }
      },
      "can_place_entity": {
        "name": "can_place_entity",
        "type": "boolean",
        "doc": "Check for collisions with terrain or other entities.",
        "short": "Check for collisions with terrain or other entities.",
        "member": "can_place_entity{name=, position=, direction?=, force?=, build_check_type?=, forced?=, inner_name?=}  boolean",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the entity prototype to check."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where the entity would be placed."
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "Direction of the placed entity. Defaults to north."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force that would place the entity. Defaults to the \"neutral\" force."
          },
          "build_check_type": {
            "name": "build_check_type",
            "type": "defines.build_check_type?",
            "doc": "Which type of check should be carried out. Defaults to ghost_revive."
          },
          "forced": {
            "name": "forced",
            "type": "boolean?",
            "doc": "If true, entities that can be marked for deconstruction are ignored. Only used if build_check_type is either manual_ghost, script_ghost or blueprint_ghost. Defaults to false."
          },
          "inner_name": {
            "name": "inner_name",
            "type": "string?",
            "doc": "The prototype name of the entity contained in the ghost. Only used if name is entity-ghost."
          }
        }
      },
      "can_fast_replace": {
        "name": "can_fast_replace",
        "type": "boolean",
        "doc": "If there exists an entity at the given location that can be fast-replaced with the given entity parameters.",
        "short": "If there exists an entity at the given location that can be fast-replaced with the given entity parameters.",
        "member": "can_fast_replace{name=, position=, direction?=, force?=}  boolean",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Name of the entity to check."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where the entity would be placed."
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "Direction the entity would be placed. Defaults to north."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force that would place the entity. Defaults to the \"neutral\" force."
          }
        }
      },
      "find_entity": {
        "name": "find_entity",
        "type": "function",
        "doc": "Find an entity of the given name at the given position. This checks both the exact position and the bounding box of the entity.",
        "short": "Find an entity of the given name at the given position. [...]",
        "member": "find_entity(entity, position)  LuaEntity?",
        "args": {
          "entity": {
            "name": "entity",
            "type": "string",
            "doc": "Name of the entity to look for."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Coordinates to look at."
          }
        }
      },
      "find_entities": {
        "name": "find_entities",
        "type": "function",
        "doc": "Find entities in a given area.",
        "short": "Find entities in a given area. [...]",
        "member": "find_entities(area?)  array[LuaEntity]",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          }
        }
      },
      "find_entities_filtered": {
        "name": "find_entities_filtered",
        "type": "LuaEntity",
        "doc": "Find all entities of the given type or name in the given area.",
        "short": "Find all entities of the given type or name in the given area. [...]",
        "member": "find_entities_filtered{area?=, position?=, radius?=, name?=, type?=, ghost_name?=, ghost_type?=, direction?=, collision_mask?=, force?=, to_be_deconstructed?=, to_be_upgraded?=, limit?=, is_military_target?=, has_item_inside?=, invert?=}  array[LuaEntity]",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Has precedence over area field."
          },
          "radius": {
            "name": "radius",
            "type": "double?",
            "doc": ""
          },
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "type": {
            "name": "type",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "ghost_name": {
            "name": "ghost_name",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "ghost_type": {
            "name": "ghost_type",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction or array[defines.direction]?",
            "doc": ""
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskLayer or array[CollisionMaskLayer]?",
            "doc": ""
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification or array[ForceIdentification]?",
            "doc": ""
          },
          "to_be_deconstructed": {
            "name": "to_be_deconstructed",
            "type": "boolean?",
            "doc": ""
          },
          "to_be_upgraded": {
            "name": "to_be_upgraded",
            "type": "boolean?",
            "doc": ""
          },
          "limit": {
            "name": "limit",
            "type": "uint?",
            "doc": ""
          },
          "is_military_target": {
            "name": "is_military_target",
            "type": "boolean?",
            "doc": ""
          },
          "has_item_inside": {
            "name": "has_item_inside",
            "type": "LuaItemPrototype?",
            "doc": ""
          },
          "invert": {
            "name": "invert",
            "type": "boolean?",
            "doc": "Whether the filters should be inverted."
          }
        }
      },
      "find_tiles_filtered": {
        "name": "find_tiles_filtered",
        "type": "LuaTile",
        "doc": "Find all tiles of the given name in the given area.",
        "short": "Find all tiles of the given name in the given area. [...]",
        "member": "find_tiles_filtered{area?=, position?=, radius?=, name?=, force?=, limit?=, has_hidden_tile?=, has_tile_ghost?=, to_be_deconstructed?=, collision_mask?=, invert?=}  array[LuaTile]",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Ignored if not given with radius."
          },
          "radius": {
            "name": "radius",
            "type": "double?",
            "doc": "If given with position, will return all tiles within the radius of the position."
          },
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification or array[ForceIdentification]?",
            "doc": ""
          },
          "limit": {
            "name": "limit",
            "type": "uint?",
            "doc": ""
          },
          "has_hidden_tile": {
            "name": "has_hidden_tile",
            "type": "boolean?",
            "doc": ""
          },
          "has_tile_ghost": {
            "name": "has_tile_ghost",
            "type": "boolean?",
            "doc": "Can be further filtered by supplying a force filter."
          },
          "to_be_deconstructed": {
            "name": "to_be_deconstructed",
            "type": "boolean?",
            "doc": "Can be further filtered by supplying a force filter."
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskLayer or array[CollisionMaskLayer]?",
            "doc": ""
          },
          "invert": {
            "name": "invert",
            "type": "boolean?",
            "doc": "Whether the filters should be inverted."
          }
        }
      },
      "count_entities_filtered": {
        "name": "count_entities_filtered",
        "type": "uint",
        "doc": "Count entities of given type or name in a given area. Works just like LuaSurface::find_entities_filtered, except this only returns the count. As it doesn't construct all the wrapper objects, this is more efficient if one is only interested in the number of entities.",
        "short": "Count entities of given type or name in a given area. [...]",
        "member": "count_entities_filtered{area?=, position?=, radius?=, name?=, type?=, ghost_name?=, ghost_type?=, direction?=, collision_mask?=, force?=, to_be_deconstructed?=, to_be_upgraded?=, limit?=, is_military_target?=, invert?=}  uint",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": ""
          },
          "radius": {
            "name": "radius",
            "type": "double?",
            "doc": "If given with position, will count all entities within the radius of the position."
          },
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "type": {
            "name": "type",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "ghost_name": {
            "name": "ghost_name",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "ghost_type": {
            "name": "ghost_type",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction or array[defines.direction]?",
            "doc": ""
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskLayer or array[CollisionMaskLayer]?",
            "doc": ""
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification or array[ForceIdentification]?",
            "doc": ""
          },
          "to_be_deconstructed": {
            "name": "to_be_deconstructed",
            "type": "boolean?",
            "doc": ""
          },
          "to_be_upgraded": {
            "name": "to_be_upgraded",
            "type": "boolean?",
            "doc": ""
          },
          "limit": {
            "name": "limit",
            "type": "uint?",
            "doc": ""
          },
          "is_military_target": {
            "name": "is_military_target",
            "type": "boolean?",
            "doc": ""
          },
          "invert": {
            "name": "invert",
            "type": "boolean?",
            "doc": "Whether the filters should be inverted."
          }
        }
      },
      "count_tiles_filtered": {
        "name": "count_tiles_filtered",
        "type": "uint",
        "doc": "Count tiles of a given name in a given area. Works just like LuaSurface::find_tiles_filtered, except this only returns the count. As it doesn't construct all the wrapper objects, this is more efficient if one is only interested in the number of tiles.",
        "short": "Count tiles of a given name in a given area. [...]",
        "member": "count_tiles_filtered{area?=, position?=, radius?=, name?=, force?=, limit?=, has_hidden_tile?=, has_tile_ghost?=, to_be_deconstructed?=, collision_mask?=, invert?=}  uint",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Ignored if not given with radius."
          },
          "radius": {
            "name": "radius",
            "type": "double?",
            "doc": "If given with position, will return all tiles within the radius of the position."
          },
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "An empty array means the same as providing nothing (nil)."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification or array[ForceIdentification]?",
            "doc": ""
          },
          "limit": {
            "name": "limit",
            "type": "uint?",
            "doc": ""
          },
          "has_hidden_tile": {
            "name": "has_hidden_tile",
            "type": "boolean?",
            "doc": ""
          },
          "has_tile_ghost": {
            "name": "has_tile_ghost",
            "type": "boolean?",
            "doc": "Can be further filtered by supplying a force filter."
          },
          "to_be_deconstructed": {
            "name": "to_be_deconstructed",
            "type": "boolean?",
            "doc": "Can be further filtered by supplying a force filter."
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskLayer or array[CollisionMaskLayer]?",
            "doc": ""
          },
          "invert": {
            "name": "invert",
            "type": "boolean?",
            "doc": "If the filters should be inverted."
          }
        }
      },
      "find_non_colliding_position": {
        "name": "find_non_colliding_position",
        "type": "function",
        "doc": "Find a non-colliding position within a given radius. Returns: The non-colliding position. May be nil if no suitable position was found.",
        "short": "Find a non-colliding position within a given radius.",
        "member": "find_non_colliding_position(name, center, radius, precision, force_to_tile_center?)  MapPosition?",
        "returns": "MapPosition?",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Prototype name of the entity to find a position for. (The bounding box for the collision checking is taken from this prototype.)"
          },
          "center": {
            "name": "center",
            "type": "MapPosition",
            "doc": "Center of the search area."
          },
          "radius": {
            "name": "radius",
            "type": "double",
            "doc": "Max distance from center to search in. A radius of 0 means an infinitely-large search area."
          },
          "precision": {
            "name": "precision",
            "type": "double",
            "doc": "The step length from the given position as it searches, in tiles. Minimum value is 0.01."
          },
          "force_to_tile_center": {
            "name": "force_to_tile_center",
            "type": "boolean?",
            "doc": "Will only check tile centers. This can be useful when your intent is to place a building at the resulting position, as they must generally be placed at tile centers. Default false."
          }
        }
      },
      "find_non_colliding_position_in_box": {
        "name": "find_non_colliding_position_in_box",
        "type": "function",
        "doc": "Find a non-colliding position within a given rectangle. Returns: The non-colliding position. May be nil if no suitable position was found.",
        "short": "Find a non-colliding position within a given rectangle.",
        "member": "find_non_colliding_position_in_box(name, search_space, precision, force_to_tile_center?)  MapPosition?",
        "returns": "MapPosition?",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "Prototype name of the entity to find a position for. (The bounding box for the collision checking is taken from this prototype.)"
          },
          "search_space": {
            "name": "search_space",
            "type": "BoundingBox",
            "doc": "The rectangle to search inside."
          },
          "precision": {
            "name": "precision",
            "type": "double",
            "doc": "The step length from the given position as it searches, in tiles. Minimum value is 0.01."
          },
          "force_to_tile_center": {
            "name": "force_to_tile_center",
            "type": "boolean?",
            "doc": "Will only check tile centers. This can be useful when your intent is to place a building at the resulting position, as they must generally be placed at tile centers. Default false."
          }
        }
      },
      "spill_item_stack": {
        "name": "spill_item_stack",
        "type": "function",
        "doc": "Spill items on the ground centered at a given location. Returns: The created item-on-ground entities.",
        "short": "Spill items on the ground centered at a given location.",
        "member": "spill_item_stack(position, items, enable_looted?, force?, allow_belts?)  array[LuaEntity]",
        "returns": "array[LuaEntity]",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Center of the spillage"
          },
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items to spill"
          },
          "enable_looted": {
            "name": "enable_looted",
            "type": "boolean?",
            "doc": "When true, each created item will be flagged with the LuaEntity::to_be_looted flag."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "When provided (and not nil) the items will be marked for deconstruction by this force."
          },
          "allow_belts": {
            "name": "allow_belts",
            "type": "boolean?",
            "doc": "Whether items can be spilled onto belts. Defaults to true."
          }
        }
      },
      "find_enemy_units": {
        "name": "find_enemy_units",
        "type": "function",
        "doc": "Find enemy units (entities with type \"unit\") of a given force within an area.",
        "short": "Find enemy units (entities with type \"unit\") of a given force within an area.",
        "member": "find_enemy_units(center, radius, force?)  array[LuaEntity]",
        "args": {
          "center": {
            "name": "center",
            "type": "MapPosition",
            "doc": "Center of the search area"
          },
          "radius": {
            "name": "radius",
            "type": "double",
            "doc": "Radius of the circular search area"
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Force to find enemies of. If not given, uses the player force."
          }
        }
      },
      "find_units": {
        "name": "find_units",
        "type": "LuaEntity",
        "doc": "Find units (entities with type \"unit\") of a given force and force condition within a given area.",
        "short": "Find units (entities with type \"unit\") of a given force and force condition within a given area.",
        "member": "find_units{area=, force=, condition=}  array[LuaEntity]",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "Box to find units within."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force performing the search."
          },
          "condition": {
            "name": "condition",
            "type": "ForceCondition",
            "doc": "Only forces which meet the condition will be included in the search."
          }
        }
      },
      "find_nearest_enemy": {
        "name": "find_nearest_enemy",
        "type": "LuaEntity",
        "doc": "Find the enemy military target (military entity) closest to the given position. Returns: The nearest enemy military target or nil if no enemy could be found within the given area.",
        "short": "Find the enemy military target (military entity) closest to the given position.",
        "member": "find_nearest_enemy{position=, max_distance=, force?=}  LuaEntity?",
        "returns": "LuaEntity?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Center of the search area."
          },
          "max_distance": {
            "name": "max_distance",
            "type": "double",
            "doc": "Radius of the circular search area."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force the result will be an enemy of. Uses the player force if not specified."
          }
        }
      },
      "find_nearest_enemy_entity_with_owner": {
        "name": "find_nearest_enemy_entity_with_owner",
        "type": "LuaEntity",
        "doc": "Find the enemy entity-with-owner closest to the given position. Returns: The nearest enemy entity-with-owner or nil if no enemy could be found within the given area.",
        "short": "Find the enemy entity-with-owner closest to the given position.",
        "member": "find_nearest_enemy_entity_with_owner{position=, max_distance=, force?=}  LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Center of the search area."
          },
          "max_distance": {
            "name": "max_distance",
            "type": "double",
            "doc": "Radius of the circular search area."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force the result will be an enemy of. Uses the player force if not specified."
          }
        }
      },
      "set_multi_command": {
        "name": "set_multi_command",
        "type": "uint",
        "doc": "Give a command to multiple units. This will automatically select suitable units for the task. Returns: Number of units actually sent. May be less than count if not enough units were available.",
        "short": "Give a command to multiple units. [...]",
        "member": "set_multi_command{command=, unit_count=, force?=, unit_search_distance?=}  uint",
        "returns": "uint",
        "args": {
          "command": {
            "name": "command",
            "type": "Command",
            "doc": ""
          },
          "unit_count": {
            "name": "unit_count",
            "type": "uint",
            "doc": "Number of units to give the command to."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Force of the units this command is to be given to. If not specified, uses the enemy force."
          },
          "unit_search_distance": {
            "name": "unit_search_distance",
            "type": "uint?",
            "doc": "Radius to search for units. The search area is centered on the destination of the command."
          }
        }
      },
      "create_entity": {
        "name": "create_entity",
        "type": "LuaEntity",
        "doc": "Create an entity on this surface.",
        "short": "Create an entity on this surface.",
        "member": "create_entity{name=, position=, direction?=, force?=, target?=, source?=, fast_replace?=, player?=, character?=, spill?=, raise_built?=, create_build_effect_smoke?=, spawn_decorations?=, move_stuck_players?=, item?=}  LuaEntity?",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The entity prototype name to create."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where to create the entity."
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": "Desired orientation of the entity after creation."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Force of the entity, default is enemy."
          },
          "target": {
            "name": "target",
            "type": "LuaEntity",
            "doc": "The target items are to be delivered to."
          },
          "source": {
            "name": "source",
            "type": "LuaEntity or MapPosition?",
            "doc": "Source entity. Used for beams, projectiles, and highlight-boxes."
          },
          "fast_replace": {
            "name": "fast_replace",
            "type": "boolean?",
            "doc": "If true, building will attempt to simulate fast-replace building."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "If given set the last_user to this player. If fast_replace is true simulate fast replace using this player."
          },
          "character": {
            "name": "character",
            "type": "LuaEntity?",
            "doc": "If fast_replace is true simulate fast replace using this character."
          },
          "spill": {
            "name": "spill",
            "type": "boolean?",
            "doc": "If false while fast_replace is true and player is nil any items from fast-replacing will be deleted instead of dropped on the ground."
          },
          "raise_built": {
            "name": "raise_built",
            "type": "boolean?",
            "doc": "If true; defines.events.script_raised_built will be fired on successful entity creation."
          },
          "create_build_effect_smoke": {
            "name": "create_build_effect_smoke",
            "type": "boolean?",
            "doc": "If false, the building effect smoke will not be shown around the new entity."
          },
          "spawn_decorations": {
            "name": "spawn_decorations",
            "type": "boolean?",
            "doc": "If true, entity types that have spawn_decorations property will apply triggers defined in the property."
          },
          "move_stuck_players": {
            "name": "move_stuck_players",
            "type": "boolean?",
            "doc": "If true, any characters that are in the way of the entity are teleported out of the way."
          },
          "item": {
            "name": "item",
            "type": "LuaItemStack?",
            "doc": "If provided, the entity will attempt to pull stored values from this item (for example; creating a spidertron from a previously named and mined spidertron)"
          },
          "recipe": {
            "name": "recipe",
            "type": "string?",
            "doc": ""
          },
          "target_position": {
            "name": "target_position",
            "type": "MapPosition?",
            "doc": "Absolute target position that can be used instead of target entity (entity has precedence if both entity and position are defined)."
          },
          "source_position": {
            "name": "source_position",
            "type": "MapPosition?",
            "doc": "Absolute source position that can be used instead of source entity (entity has precedence if both entity and position are defined)."
          },
          "max_length": {
            "name": "max_length",
            "type": "uint?",
            "doc": "If set, beam will be destroyed when distance between source and target is greater than this value."
          },
          "duration": {
            "name": "duration",
            "type": "uint?",
            "doc": "If set, beam will be destroyed after this value of ticks."
          },
          "source_offset": {
            "name": "source_offset",
            "type": "Vector?",
            "doc": "Source position will be offset by this value when rendering the stream."
          },
          "bar": {
            "name": "bar",
            "type": "uint?",
            "doc": "Inventory index where the red limiting bar should be set."
          },
          "cliff_orientation": {
            "name": "cliff_orientation",
            "type": "CliffOrientation?",
            "doc": "If not specified, direction will be used instead."
          },
          "text": {
            "name": "text",
            "type": "LocalisedString",
            "doc": ""
          },
          "color": {
            "name": "color",
            "type": "Color?",
            "doc": "The color of this rolling stock, if it supports colors."
          },
          "render_player_index": {
            "name": "render_player_index",
            "type": "uint?",
            "doc": ""
          },
          "inner_name": {
            "name": "inner_name",
            "type": "string",
            "doc": "The prototype name of the entity contained in the ghost."
          },
          "expires": {
            "name": "expires",
            "type": "boolean?",
            "doc": "If false the ghost entity will not expire. Default is false."
          },
          "initial_ground_flame_count": {
            "name": "initial_ground_flame_count",
            "type": "uint8?",
            "doc": "With how many small flames should the fire on ground be created. Defaults to the initial flame count of the prototype."
          },
          "conditions": {
            "name": "conditions",
            "type": "InserterCircuitConditions",
            "doc": ""
          },
          "filters": {
            "name": "filters",
            "type": "array[InventoryFilter]",
            "doc": ""
          },
          "stack": {
            "name": "stack",
            "type": "SimpleItemStack",
            "doc": "The stack of items to create."
          },
          "modules": {
            "name": "modules",
            "type": "dictionary[string uint]",
            "doc": "The stacks of items to be delivered to target entity from logistic network."
          },
          "orientation": {
            "name": "orientation",
            "type": "RealOrientation?",
            "doc": "The orientation of this rolling stock."
          },
          "snap_to_train_stop": {
            "name": "snap_to_train_stop",
            "type": "boolean?",
            "doc": "Whether the locomotive should snap to an adjacent train stop. Defaults to true."
          },
          "request_filters": {
            "name": "request_filters",
            "type": "array[InventoryFilter]?",
            "doc": ""
          },
          "movement": {
            "name": "movement",
            "type": "Vector",
            "doc": ""
          },
          "height": {
            "name": "height",
            "type": "float",
            "doc": ""
          },
          "vertical_speed": {
            "name": "vertical_speed",
            "type": "float",
            "doc": ""
          },
          "frame_speed": {
            "name": "frame_speed",
            "type": "float",
            "doc": ""
          },
          "speed": {
            "name": "speed",
            "type": "double",
            "doc": ""
          },
          "max_range": {
            "name": "max_range",
            "type": "double?",
            "doc": ""
          },
          "amount": {
            "name": "amount",
            "type": "uint",
            "doc": ""
          },
          "enable_tree_removal": {
            "name": "enable_tree_removal",
            "type": "boolean?",
            "doc": "If colliding trees are removed normally for this resource entity based off the prototype tree removal values. Default is true."
          },
          "enable_cliff_removal": {
            "name": "enable_cliff_removal",
            "type": "boolean?",
            "doc": "If colliding cliffs are removed. Default is true."
          },
          "snap_to_tile_center": {
            "name": "snap_to_tile_center",
            "type": "boolean?",
            "doc": "If true, the resource entity will be placed to center of a tile as map generator would place it, otherwise standard non-resource grid alignment rules will apply. Default is true."
          },
          "type": {
            "name": "type",
            "type": "\"output\" or \"input\"?",
            "doc": "Defaults to \"input\"."
          },
          "parameters": {
            "name": "parameters",
            "type": "ProgrammableSpeakerParameters?",
            "doc": ""
          },
          "alert_parameters": {
            "name": "alert_parameters",
            "type": "ProgrammableSpeakerAlertParameters?",
            "doc": ""
          },
          "inventory_size": {
            "name": "inventory_size",
            "type": "uint?",
            "doc": ""
          },
          "player_index": {
            "name": "player_index",
            "type": "uint?",
            "doc": ""
          },
          "bounding_box": {
            "name": "bounding_box",
            "type": "BoundingBox?",
            "doc": "The bounding box defining the highlight box using absolute map coordinates. If specified, the general position parameter still needs to be present, but will be ignored. If not specified, the game falls back to the source parameter first, then the target parameter second. One of these three parameters need to be specified."
          },
          "box_type": {
            "name": "box_type",
            "type": "CursorBoxRenderType?",
            "doc": "Specifies the graphical appearance (color) of the highlight box. Defaults to \"electricity\"."
          },
          "blink_interval": {
            "name": "blink_interval",
            "type": "uint?",
            "doc": "The blink interval for this highlight box. Makes it be shown every blink_interval ticks. Defaults to 0 (constantly shown)."
          },
          "time_to_live": {
            "name": "time_to_live",
            "type": "uint?",
            "doc": "The amount of time in ticks that the highlight box will exist for. Defaults to existing forever."
          },
          "lifetime": {
            "name": "lifetime",
            "type": "uint?",
            "doc": ""
          },
          "script_raised_built?": {
            "name": "script_raised_built?",
            "doc": "Raised if the raise_built flag was set and the entity was successfully created."
          }
        }
      },
      "create_trivial_smoke": {
        "name": "create_trivial_smoke",
        "doc": "The smoke prototype name to create.",
        "member": "create_trivial_smoke{name=, position=}",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The smoke prototype name to create."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where to create the smoke."
          }
        }
      },
      "create_particle": {
        "name": "create_particle",
        "doc": "Creates a particle at the given location",
        "short": "Creates a particle at the given location",
        "member": "create_particle{name=, position=, movement=, height=, vertical_speed=, frame_speed=}",
        "args": {
          "name": {
            "name": "name",
            "type": "string",
            "doc": "The particle name."
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where to create the particle."
          },
          "movement": {
            "name": "movement",
            "type": "Vector",
            "doc": ""
          },
          "height": {
            "name": "height",
            "type": "float",
            "doc": ""
          },
          "vertical_speed": {
            "name": "vertical_speed",
            "type": "float",
            "doc": ""
          },
          "frame_speed": {
            "name": "frame_speed",
            "type": "float",
            "doc": ""
          }
        }
      },
      "create_unit_group": {
        "name": "create_unit_group",
        "type": "LuaUnitGroup",
        "doc": "Create a new unit group at a given position.",
        "short": "Create a new unit group at a given position.",
        "member": "create_unit_group{position=, force?=}  LuaUnitGroup",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Initial position of the new unit group."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Force of the new unit group. Defaults to \"enemy\"."
          },
          "on_unit_group_created": {
            "name": "on_unit_group_created",
            "doc": ""
          }
        }
      },
      "build_enemy_base": {
        "name": "build_enemy_base",
        "doc": "Send a group to build a new base.",
        "short": "Send a group to build a new base.",
        "member": "build_enemy_base(position, unit_count, force?)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Location of the new base."
          },
          "unit_count": {
            "name": "unit_count",
            "type": "uint",
            "doc": "Number of biters to send for the base-building task."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Force the new base will belong to. Defaults to enemy."
          }
        }
      },
      "get_tile": {
        "name": "get_tile",
        "type": "function",
        "doc": "Get the tile at a given position. An alternative call signature for this method is passing it a single TilePosition.",
        "short": "Get the tile at a given position. [...]",
        "member": "get_tile(x, y)  LuaTile",
        "args": {
          "x": {
            "name": "x",
            "type": "int",
            "doc": ""
          },
          "y": {
            "name": "y",
            "type": "int",
            "doc": ""
          }
        }
      },
      "set_tiles": {
        "name": "set_tiles",
        "doc": "Set tiles at specified locations. Can automatically correct the edges around modified tiles.",
        "short": "Set tiles at specified locations. [...]",
        "member": "set_tiles(tiles, correct_tiles?, remove_colliding_entities?, remove_colliding_decoratives?, raise_event?)",
        "type": "function",
        "args": {
          "tiles": {
            "name": "tiles",
            "type": "array[Tile]",
            "doc": ""
          },
          "correct_tiles": {
            "name": "correct_tiles",
            "type": "boolean?",
            "doc": "If false, the correction logic is not applied to the changed tiles. Defaults to true."
          },
          "remove_colliding_entities": {
            "name": "remove_colliding_entities",
            "type": "boolean or \"abort_on_collision\"?",
            "doc": "Defaults to true."
          },
          "remove_colliding_decoratives": {
            "name": "remove_colliding_decoratives",
            "type": "boolean?",
            "doc": "Defaults to true."
          },
          "raise_event": {
            "name": "raise_event",
            "type": "boolean?",
            "doc": "Defaults to false."
          },
          "script_raised_set_tiles?": {
            "name": "script_raised_set_tiles?",
            "doc": "Raised if the raise_event flag was set."
          }
        }
      },
      "pollute": {
        "name": "pollute",
        "doc": "Spawn pollution at the given position.",
        "short": "Spawn pollution at the given position.",
        "member": "pollute(source, amount)",
        "type": "function",
        "args": {
          "source": {
            "name": "source",
            "type": "MapPosition",
            "doc": "Where to spawn the pollution."
          },
          "amount": {
            "name": "amount",
            "type": "double",
            "doc": "How much pollution to add."
          }
        }
      },
      "get_chunks": {
        "name": "get_chunks",
        "type": "function",
        "doc": "Get an iterator going over every chunk on this surface.",
        "short": "Get an iterator going over every chunk on this surface.",
        "member": "get_chunks()  LuaChunkIterator"
      },
      "is_chunk_generated": {
        "name": "is_chunk_generated",
        "type": "function",
        "doc": "Is a given chunk generated?",
        "short": "Is a given chunk generated?",
        "member": "is_chunk_generated(position)  boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "The chunk's position."
          }
        }
      },
      "request_to_generate_chunks": {
        "name": "request_to_generate_chunks",
        "doc": "Request that the game's map generator generate chunks at the given position for the given radius on this surface. If the radius is 0, then only the chunk at the given position is generated.",
        "short": "Request that the game's map generator generate chunks at the given position for the given radius on this surface. [...]",
        "member": "request_to_generate_chunks(position, radius?)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "Where to generate the new chunks."
          },
          "radius": {
            "name": "radius",
            "type": "uint?",
            "doc": "The chunk radius from position to generate new chunks in. Defaults to 0."
          }
        }
      },
      "force_generate_chunk_requests": {
        "name": "force_generate_chunk_requests",
        "doc": "Blocks and generates all chunks that have been requested using all available threads.",
        "short": "Blocks and generates all chunks that have been requested using all available threads.",
        "member": "force_generate_chunk_requests()",
        "type": "function"
      },
      "set_chunk_generated_status": {
        "name": "set_chunk_generated_status",
        "doc": "Set generated status of a chunk. Useful when copying chunks.",
        "short": "Set generated status of a chunk. [...]",
        "member": "set_chunk_generated_status(position, status)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "The chunk's position."
          },
          "status": {
            "name": "status",
            "type": "defines.chunk_generated_status",
            "doc": "The chunk's new status."
          }
        }
      },
      "find_logistic_network_by_position": {
        "name": "find_logistic_network_by_position",
        "type": "function",
        "doc": "Find the logistic network that covers a given position. Returns: The found network or nil if no such network was found.",
        "short": "Find the logistic network that covers a given position.",
        "member": "find_logistic_network_by_position(position, force)  LuaLogisticNetwork?",
        "returns": "LuaLogisticNetwork?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force the logistic network should belong to."
          }
        }
      },
      "find_closest_logistic_network_by_position": {
        "name": "find_closest_logistic_network_by_position",
        "type": "function",
        "doc": "Find the logistic network with a cell closest to a given position. Returns: The found network or nil if no such network was found.",
        "short": "Find the logistic network with a cell closest to a given position.",
        "member": "find_closest_logistic_network_by_position(position, force)  LuaLogisticNetwork?",
        "returns": "LuaLogisticNetwork?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force the logistic network should belong to."
          }
        }
      },
      "find_logistic_networks_by_construction_area": {
        "name": "find_logistic_networks_by_construction_area",
        "type": "function",
        "doc": "Finds all of the logistics networks whose construction area intersects with the given position.",
        "short": "Finds all of the logistics networks whose construction area intersects with the given position.",
        "member": "find_logistic_networks_by_construction_area(position, force)  array[LuaLogisticNetwork]",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Force the logistic networks should belong to."
          }
        }
      },
      "deconstruct_area": {
        "name": "deconstruct_area",
        "doc": "Place a deconstruction request.",
        "short": "Place a deconstruction request.",
        "member": "deconstruct_area{area=, force=, player?=, skip_fog_of_war?=, item?=}",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area to mark for deconstruction."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose bots should perform the deconstruction."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "item": {
            "name": "item",
            "type": "LuaItemStack?",
            "doc": "The deconstruction item to use if any."
          },
          "on_marked_for_deconstruction?": {
            "name": "on_marked_for_deconstruction?",
            "doc": "Raised for every entity that has been successfully marked for deconstruction."
          }
        }
      },
      "cancel_deconstruct_area": {
        "name": "cancel_deconstruct_area",
        "doc": "Cancel a deconstruction order.",
        "short": "Cancel a deconstruction order.",
        "member": "cancel_deconstruct_area{area=, force=, player?=, skip_fog_of_war?=, item?=}",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area to cancel deconstruction orders in."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose deconstruction orders to cancel."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "item": {
            "name": "item",
            "type": "LuaItemStack?",
            "doc": "The deconstruction item to use if any."
          },
          "on_cancelled_deconstruction?": {
            "name": "on_cancelled_deconstruction?",
            "doc": "Raised for every entity whose deconstruction has been successfully cancelled."
          }
        }
      },
      "upgrade_area": {
        "name": "upgrade_area",
        "doc": "Place an upgrade request.",
        "short": "Place an upgrade request.",
        "member": "upgrade_area{area=, force=, player?=, skip_fog_of_war?=, item=}",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area to mark for upgrade."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose bots should perform the upgrade."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "item": {
            "name": "item",
            "type": "LuaItemStack",
            "doc": "The upgrade item to use."
          },
          "on_marked_for_upgrade?": {
            "name": "on_marked_for_upgrade?",
            "doc": "Raised for every entity that has been successfully marked for upgrade."
          }
        }
      },
      "cancel_upgrade_area": {
        "name": "cancel_upgrade_area",
        "doc": "Cancel a upgrade order.",
        "short": "Cancel a upgrade order.",
        "member": "cancel_upgrade_area{area=, force=, player?=, skip_fog_of_war?=, item?=}",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The area to cancel upgrade orders in."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose upgrade orders to cancel."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "skip_fog_of_war": {
            "name": "skip_fog_of_war",
            "type": "boolean?",
            "doc": "If chunks covered by fog-of-war are skipped."
          },
          "item": {
            "name": "item",
            "type": "LuaItemStack?",
            "doc": "The upgrade item to use if any."
          },
          "on_cancelled_upgrade?": {
            "name": "on_cancelled_upgrade?",
            "doc": "Raised for every entity whose upgrade has been successfully cancelled."
          }
        }
      },
      "get_hidden_tile": {
        "name": "get_hidden_tile",
        "type": "function",
        "doc": "The hidden tile name. Returns: nil if there isn't one for the given position.",
        "short": "The hidden tile name.",
        "member": "get_hidden_tile(position)  string?",
        "returns": "string?",
        "args": {
          "position": {
            "name": "position",
            "type": "TilePosition",
            "doc": "The tile position."
          }
        }
      },
      "set_hidden_tile": {
        "name": "set_hidden_tile",
        "doc": "Set the hidden tile for the specified position. While during normal gameplay only non-mineable tiles can become hidden, this method allows any kind of tile to be set as the hidden one.",
        "short": "Set the hidden tile for the specified position. [...]",
        "member": "set_hidden_tile(position, tile)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "TilePosition",
            "doc": "The tile position."
          },
          "tile": {
            "name": "tile",
            "type": "string or LuaTilePrototype",
            "doc": "The new hidden tile or nil to clear the hidden tile."
          }
        }
      },
      "get_connected_tiles": {
        "name": "get_connected_tiles",
        "type": "function",
        "doc": "Gets all tiles of the given types that are connected horizontally or vertically to the given tile position including the given tile position. Returns: The resulting set of tiles.",
        "short": "Gets all tiles of the given types that are connected horizontally or vertically to the given tile position including the given tile position.",
        "member": "get_connected_tiles(position, tiles, include_diagonal?, area?)  array[TilePosition]",
        "returns": "array[TilePosition]",
        "args": {
          "position": {
            "name": "position",
            "type": "TilePosition",
            "doc": "The tile position to start at."
          },
          "tiles": {
            "name": "tiles",
            "type": "array[string]",
            "doc": "The tiles to search for."
          },
          "include_diagonal": {
            "name": "include_diagonal",
            "type": "boolean?",
            "doc": "Include tiles that are connected diagonally."
          },
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": "The area to find connected tiles in. If provided the start position must be in this area."
          }
        }
      },
      "delete_chunk": {
        "name": "delete_chunk",
        "doc": "The chunk position to delete",
        "member": "delete_chunk(position)",
        "type": "function",
        "args": {
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "The chunk position to delete"
          },
          "on_pre_chunk_deleted": {
            "name": "on_pre_chunk_deleted",
            "doc": ""
          },
          "on_chunk_deleted": {
            "name": "on_chunk_deleted",
            "doc": ""
          }
        }
      },
      "regenerate_entity": {
        "name": "regenerate_entity",
        "doc": "Regenerate autoplacement of some entities on this surface. This can be used to autoplace newly-added entities.",
        "short": "Regenerate autoplacement of some entities on this surface. [...]",
        "member": "regenerate_entity(entities?, chunks?)",
        "type": "function",
        "args": {
          "entities": {
            "name": "entities",
            "type": "string or array[string]?",
            "doc": "Prototype names of entity or entities to autoplace. When nil all entities with an autoplace are used."
          },
          "chunks": {
            "name": "chunks",
            "type": "array[ChunkPosition]?",
            "doc": "The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored."
          }
        }
      },
      "regenerate_decorative": {
        "name": "regenerate_decorative",
        "doc": "Regenerate autoplacement of some decoratives on this surface. This can be used to autoplace newly-added decoratives.",
        "short": "Regenerate autoplacement of some decoratives on this surface. [...]",
        "member": "regenerate_decorative(decoratives?, chunks?)",
        "type": "function",
        "args": {
          "decoratives": {
            "name": "decoratives",
            "type": "string or array[string]?",
            "doc": "Prototype names of decorative or decoratives to autoplace. When nil all decoratives with an autoplace are used."
          },
          "chunks": {
            "name": "chunks",
            "type": "array[ChunkPosition]?",
            "doc": "The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored."
          }
        }
      },
      "print": {
        "name": "print",
        "doc": "Print text to the chat console of all players on this surface.",
        "short": "Print text to the chat console of all players on this surface.",
        "member": "print(message, print_settings?)",
        "type": "function",
        "args": {
          "message": {
            "name": "message",
            "type": "LocalisedString",
            "doc": ""
          },
          "print_settings": {
            "name": "print_settings",
            "type": "Color or PrintSettings?",
            "doc": ""
          }
        }
      },
      "destroy_decoratives": {
        "name": "destroy_decoratives",
        "doc": "Removes all decoratives from the given area. If no area and no position are given, then the entire surface is searched.",
        "short": "Removes all decoratives from the given area. [...]",
        "member": "destroy_decoratives{area?=, position?=, name?=, collision_mask?=, from_layer?=, to_layer?=, exclude_soft?=, limit?=, invert?=}",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "TilePosition?",
            "doc": ""
          },
          "name": {
            "name": "name",
            "type": "string or array[string] or LuaDecorativePrototype or array[LuaDecorativePrototype]?",
            "doc": ""
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskLayer or array[CollisionMaskLayer]?",
            "doc": ""
          },
          "from_layer": {
            "name": "from_layer",
            "type": "string?",
            "doc": ""
          },
          "to_layer": {
            "name": "to_layer",
            "type": "string?",
            "doc": ""
          },
          "exclude_soft": {
            "name": "exclude_soft",
            "type": "boolean?",
            "doc": "Soft decoratives can be drawn over rails."
          },
          "limit": {
            "name": "limit",
            "type": "uint?",
            "doc": ""
          },
          "invert": {
            "name": "invert",
            "type": "boolean?",
            "doc": "If the filters should be inverted."
          }
        }
      },
      "create_decoratives": {
        "name": "create_decoratives",
        "doc": "Adds the given decoratives to the surface.",
        "short": "Adds the given decoratives to the surface.",
        "member": "create_decoratives{check_collision?=, decoratives=}",
        "args": {
          "check_collision": {
            "name": "check_collision",
            "type": "boolean?",
            "doc": "If collision should be checked against entities/tiles."
          },
          "decoratives": {
            "name": "decoratives",
            "type": "array[Decorative]",
            "doc": ""
          }
        }
      },
      "find_decoratives_filtered": {
        "name": "find_decoratives_filtered",
        "type": "DecorativeResult",
        "doc": "Find decoratives of a given name in a given area.",
        "short": "Find decoratives of a given name in a given area. [...]",
        "member": "find_decoratives_filtered{area?=, position?=, name?=, collision_mask?=, from_layer?=, to_layer?=, exclude_soft?=, limit?=, invert?=}  array[DecorativeResult]",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox?",
            "doc": ""
          },
          "position": {
            "name": "position",
            "type": "TilePosition?",
            "doc": ""
          },
          "name": {
            "name": "name",
            "type": "string or array[string] or LuaDecorativePrototype or array[LuaDecorativePrototype]?",
            "doc": ""
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskLayer or array[CollisionMaskLayer]?",
            "doc": ""
          },
          "from_layer": {
            "name": "from_layer",
            "type": "string?",
            "doc": ""
          },
          "to_layer": {
            "name": "to_layer",
            "type": "string?",
            "doc": ""
          },
          "exclude_soft": {
            "name": "exclude_soft",
            "type": "boolean?",
            "doc": "Soft decoratives can be drawn over rails."
          },
          "limit": {
            "name": "limit",
            "type": "uint?",
            "doc": ""
          },
          "invert": {
            "name": "invert",
            "type": "boolean?",
            "doc": "If the filters should be inverted."
          }
        }
      },
      "get_trains": {
        "name": "get_trains",
        "type": "function",
        "doc": "The force to search. Not providing a force will match trains in any force.",
        "member": "get_trains(force?)  array[LuaTrain]",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force to search. Not providing a force will match trains in any force."
          }
        }
      },
      "clear_pollution": {
        "name": "clear_pollution",
        "doc": "Clears all pollution on this surface.",
        "short": "Clears all pollution on this surface.",
        "member": "clear_pollution()",
        "type": "function"
      },
      "play_sound": {
        "name": "play_sound",
        "doc": "Play a sound for every player on this surface.",
        "short": "Play a sound for every player on this surface.",
        "member": "play_sound{path=, position?=, volume_modifier?=, override_sound_type?=}",
        "args": {
          "path": {
            "name": "path",
            "type": "SoundPath",
            "doc": "The sound to play."
          },
          "position": {
            "name": "position",
            "type": "MapPosition?",
            "doc": "Where the sound should be played. If not given, it's played at the current position of each player."
          },
          "volume_modifier": {
            "name": "volume_modifier",
            "type": "double?",
            "doc": "The volume of the sound to play. Must be between 0 and 1 inclusive."
          },
          "override_sound_type": {
            "name": "override_sound_type",
            "type": "SoundType?",
            "doc": "The volume mixer to play the sound through. Defaults to the default mixer for the given sound type."
          }
        }
      },
      "get_resource_counts": {
        "name": "get_resource_counts",
        "type": "function",
        "doc": "Gets the resource amount of all resources on this surface",
        "short": "Gets the resource amount of all resources on this surface",
        "member": "get_resource_counts()  dictionary[string uint]"
      },
      "get_random_chunk": {
        "name": "get_random_chunk",
        "type": "function",
        "doc": "Gets a random generated chunk position or 0,0 if no chunks have been generated on this surface.",
        "short": "Gets a random generated chunk position or 0,0 if no chunks have been generated on this surface.",
        "member": "get_random_chunk()  ChunkPosition"
      },
      "clone_area": {
        "name": "clone_area",
        "doc": "Clones the given area.",
        "short": "Clones the given area.",
        "member": "clone_area{source_area=, destination_area=, destination_surface?=, destination_force?=, clone_tiles?=, clone_entities?=, clone_decoratives?=, clear_destination_entities?=, clear_destination_decoratives?=, expand_map?=, create_build_effect_smoke?=}",
        "args": {
          "source_area": {
            "name": "source_area",
            "type": "BoundingBox",
            "doc": ""
          },
          "destination_area": {
            "name": "destination_area",
            "type": "BoundingBox",
            "doc": ""
          },
          "destination_surface": {
            "name": "destination_surface",
            "type": "SurfaceIdentification?",
            "doc": ""
          },
          "destination_force": {
            "name": "destination_force",
            "type": "ForceIdentification?",
            "doc": ""
          },
          "clone_tiles": {
            "name": "clone_tiles",
            "type": "boolean?",
            "doc": "If tiles should be cloned"
          },
          "clone_entities": {
            "name": "clone_entities",
            "type": "boolean?",
            "doc": "If entities should be cloned"
          },
          "clone_decoratives": {
            "name": "clone_decoratives",
            "type": "boolean?",
            "doc": "If decoratives should be cloned"
          },
          "clear_destination_entities": {
            "name": "clear_destination_entities",
            "type": "boolean?",
            "doc": "If the destination entities should be cleared"
          },
          "clear_destination_decoratives": {
            "name": "clear_destination_decoratives",
            "type": "boolean?",
            "doc": "If the destination decoratives should be cleared"
          },
          "expand_map": {
            "name": "expand_map",
            "type": "boolean?",
            "doc": "If the destination surface should be expanded when destination_area is outside current bounds. Default false."
          },
          "create_build_effect_smoke": {
            "name": "create_build_effect_smoke",
            "type": "boolean?",
            "doc": "If true, the building effect smoke will be shown around the new entities."
          },
          "on_entity_cloned": {
            "name": "on_entity_cloned",
            "doc": "Raised for every entity that was cloned."
          },
          "on_area_cloned": {
            "name": "on_area_cloned",
            "doc": "Raised after the individual on_entity_cloned events."
          }
        }
      },
      "clone_brush": {
        "name": "clone_brush",
        "doc": "Clones the given area.",
        "short": "Clones the given area.",
        "member": "clone_brush{source_offset=, destination_offset=, source_positions=, destination_surface?=, destination_force?=, clone_tiles?=, clone_entities?=, clone_decoratives?=, clear_destination_entities?=, clear_destination_decoratives?=, expand_map?=, manual_collision_mode?=, create_build_effect_smoke?=}",
        "args": {
          "source_offset": {
            "name": "source_offset",
            "type": "TilePosition",
            "doc": ""
          },
          "destination_offset": {
            "name": "destination_offset",
            "type": "TilePosition",
            "doc": ""
          },
          "source_positions": {
            "name": "source_positions",
            "type": "array[TilePosition]",
            "doc": ""
          },
          "destination_surface": {
            "name": "destination_surface",
            "type": "SurfaceIdentification?",
            "doc": ""
          },
          "destination_force": {
            "name": "destination_force",
            "type": "LuaForce or string?",
            "doc": ""
          },
          "clone_tiles": {
            "name": "clone_tiles",
            "type": "boolean?",
            "doc": "If tiles should be cloned"
          },
          "clone_entities": {
            "name": "clone_entities",
            "type": "boolean?",
            "doc": "If entities should be cloned"
          },
          "clone_decoratives": {
            "name": "clone_decoratives",
            "type": "boolean?",
            "doc": "If decoratives should be cloned"
          },
          "clear_destination_entities": {
            "name": "clear_destination_entities",
            "type": "boolean?",
            "doc": "If the destination entities should be cleared"
          },
          "clear_destination_decoratives": {
            "name": "clear_destination_decoratives",
            "type": "boolean?",
            "doc": "If the destination decoratives should be cleared"
          },
          "expand_map": {
            "name": "expand_map",
            "type": "boolean?",
            "doc": "If the destination surface should be expanded when destination_area is outside current bounds. Default false."
          },
          "manual_collision_mode": {
            "name": "manual_collision_mode",
            "type": "boolean?",
            "doc": "If manual-style collision checks should be done."
          },
          "create_build_effect_smoke": {
            "name": "create_build_effect_smoke",
            "type": "boolean?",
            "doc": "If true, the building effect smoke will be shown around the new entities."
          }
        }
      },
      "clone_entities": {
        "name": "clone_entities",
        "doc": "Clones the given entities.",
        "short": "Clones the given entities.",
        "member": "clone_entities{entities=, destination_offset=, destination_surface?=, destination_force?=, snap_to_grid?=, create_build_effect_smoke?=}",
        "args": {
          "entities": {
            "name": "entities",
            "type": "array[LuaEntity]",
            "doc": ""
          },
          "destination_offset": {
            "name": "destination_offset",
            "type": "Vector",
            "doc": ""
          },
          "destination_surface": {
            "name": "destination_surface",
            "type": "SurfaceIdentification?",
            "doc": ""
          },
          "destination_force": {
            "name": "destination_force",
            "type": "ForceIdentification?",
            "doc": ""
          },
          "snap_to_grid": {
            "name": "snap_to_grid",
            "type": "boolean?",
            "doc": ""
          },
          "create_build_effect_smoke": {
            "name": "create_build_effect_smoke",
            "type": "boolean?",
            "doc": "If true, the building effect smoke will be shown around the new entities."
          },
          "on_entity_cloned": {
            "name": "on_entity_cloned",
            "doc": "Raised for every entity that was cloned."
          }
        }
      },
      "clear": {
        "name": "clear",
        "doc": "Clears this surface deleting all entities and chunks on it.",
        "short": "Clears this surface deleting all entities and chunks on it.",
        "member": "clear(ignore_characters?)",
        "type": "function",
        "args": {
          "ignore_characters": {
            "name": "ignore_characters",
            "type": "boolean?",
            "doc": "Whether characters on this surface that are connected to or associated with players should be ignored (not destroyed). Defaults to false."
          },
          "on_pre_surface_cleared": {
            "name": "on_pre_surface_cleared",
            "doc": ""
          },
          "on_surface_cleared": {
            "name": "on_surface_cleared",
            "doc": ""
          }
        }
      },
      "request_path": {
        "name": "request_path",
        "type": "uint",
        "doc": "Generates a path with the specified constraints (as an array of PathfinderWaypoints) using the unit pathfinding algorithm. This path can be used to emulate pathing behavior by script for non-unit entities, such as vehicles. If you want to command actual units (such as biters or spitters) to move, use LuaEntity::set_command instead. Returns: A unique handle to identify this call when on_script_path_request_finished fires.",
        "short": "Generates a path with the specified constraints (as an array of PathfinderWaypoints) using the unit pathfinding algorithm. [...]",
        "member": "request_path{bounding_box=, collision_mask=, start=, goal=, force=, radius?=, pathfind_flags?=, can_open_gates?=, path_resolution_modifier?=, entity_to_ignore?=}  uint",
        "returns": "uint",
        "args": {
          "bounding_box": {
            "name": "bounding_box",
            "type": "BoundingBox",
            "doc": "The dimensions of the object that's supposed to travel the path."
          },
          "collision_mask": {
            "name": "collision_mask",
            "type": "CollisionMaskWithFlags or array[string]",
            "doc": "The list of masks the bounding_box collides with."
          },
          "start": {
            "name": "start",
            "type": "MapPosition",
            "doc": "The position from which to start pathfinding."
          },
          "goal": {
            "name": "goal",
            "type": "MapPosition",
            "doc": "The position to find a path to."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force for which to generate the path, determining which gates can be opened for example."
          },
          "radius": {
            "name": "radius",
            "type": "double?",
            "doc": "How close the pathfinder needs to get to its goal (in tiles). Defaults to 1."
          },
          "pathfind_flags": {
            "name": "pathfind_flags",
            "type": "PathfinderFlags?",
            "doc": "Flags that affect pathfinder behavior."
          },
          "can_open_gates": {
            "name": "can_open_gates",
            "type": "boolean?",
            "doc": "Whether the path request can open gates. Defaults to false."
          },
          "path_resolution_modifier": {
            "name": "path_resolution_modifier",
            "type": "int?",
            "doc": "Defines how coarse the pathfinder's grid is, where smaller values mean a coarser grid. Defaults to 0, which equals a resolution of 1x1 tiles, centered on tile centers. Values range from -8 to 8 inclusive, where each integer increment doubles/halves the resolution. So, a resolution of -8 equals a grid of 256x256 tiles, and a resolution of 8 equals 1/256 of a tile."
          },
          "entity_to_ignore": {
            "name": "entity_to_ignore",
            "type": "LuaEntity?",
            "doc": "Makes the pathfinder ignore collisions with this entity if it is given."
          },
          "on_script_path_request_finished": {
            "name": "on_script_path_request_finished",
            "doc": ""
          }
        }
      },
      "get_script_areas": {
        "name": "get_script_areas",
        "type": "function",
        "doc": "Gets the script areas that match the given name or if no name is given all areas are returned.",
        "short": "Gets the script areas that match the given name or if no name is given all areas are returned.",
        "member": "get_script_areas(name?)  array[ScriptArea]",
        "args": {
          "name": {
            "name": "name",
            "type": "string?",
            "doc": ""
          }
        }
      },
      "get_script_area": {
        "name": "get_script_area",
        "type": "function",
        "doc": "Gets the first script area by name or id.",
        "short": "Gets the first script area by name or id.",
        "member": "get_script_area(key?)  ScriptArea?",
        "args": {
          "key": {
            "name": "key",
            "type": "string or uint?",
            "doc": "The name or id of the area to get."
          }
        }
      },
      "edit_script_area": {
        "name": "edit_script_area",
        "doc": "Sets the given script area to the new values.",
        "short": "Sets the given script area to the new values.",
        "member": "edit_script_area(id, area)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint",
            "doc": "The area to edit."
          },
          "area": {
            "name": "area",
            "type": "ScriptArea",
            "doc": ""
          }
        }
      },
      "add_script_area": {
        "name": "add_script_area",
        "type": "function",
        "doc": "Adds the given script area. Returns: The id of the created area.",
        "short": "Adds the given script area.",
        "member": "add_script_area(area)  uint",
        "returns": "uint",
        "args": {
          "area": {
            "name": "area",
            "type": "ScriptArea",
            "doc": ""
          }
        }
      },
      "remove_script_area": {
        "name": "remove_script_area",
        "type": "function",
        "doc": "Removes the given script area. Returns: If the area was actually removed. False when it didn't exist.",
        "short": "Removes the given script area.",
        "member": "remove_script_area(id)  boolean",
        "returns": "boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_script_positions": {
        "name": "get_script_positions",
        "type": "function",
        "doc": "Gets the script positions that match the given name or if no name is given all positions are returned.",
        "short": "Gets the script positions that match the given name or if no name is given all positions are returned.",
        "member": "get_script_positions(name?)  array[ScriptPosition]",
        "args": {
          "name": {
            "name": "name",
            "type": "string?",
            "doc": ""
          }
        }
      },
      "get_script_position": {
        "name": "get_script_position",
        "type": "function",
        "doc": "Gets the first script position by name or id.",
        "short": "Gets the first script position by name or id.",
        "member": "get_script_position(key?)  ScriptPosition?",
        "args": {
          "key": {
            "name": "key",
            "type": "string or uint?",
            "doc": "The name or id of the position to get."
          }
        }
      },
      "edit_script_position": {
        "name": "edit_script_position",
        "doc": "Sets the given script position to the new values.",
        "short": "Sets the given script position to the new values.",
        "member": "edit_script_position(id, area)",
        "type": "function",
        "args": {
          "id": {
            "name": "id",
            "type": "uint",
            "doc": "The position to edit."
          },
          "area": {
            "name": "area",
            "type": "ScriptPosition",
            "doc": ""
          }
        }
      },
      "add_script_position": {
        "name": "add_script_position",
        "type": "function",
        "doc": "Adds the given script position. Returns: The id of the created position.",
        "short": "Adds the given script position.",
        "member": "add_script_position(area)  uint",
        "returns": "uint",
        "args": {
          "area": {
            "name": "area",
            "type": "ScriptPosition",
            "doc": ""
          }
        }
      },
      "remove_script_position": {
        "name": "remove_script_position",
        "type": "function",
        "doc": "Removes the given script position. Returns: If the position was actually removed. False when it didn't exist.",
        "short": "Removes the given script position.",
        "member": "remove_script_position(id)  boolean",
        "returns": "boolean",
        "args": {
          "id": {
            "name": "id",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_map_exchange_string": {
        "name": "get_map_exchange_string",
        "type": "function",
        "doc": "Gets the map exchange string for the current map generation settings of this surface.",
        "short": "Gets the map exchange string for the current map generation settings of this surface.",
        "member": "get_map_exchange_string()  string"
      },
      "get_starting_area_radius": {
        "name": "get_starting_area_radius",
        "type": "function",
        "doc": "Gets the starting area radius of this surface.",
        "short": "Gets the starting area radius of this surface.",
        "member": "get_starting_area_radius()  double"
      },
      "get_closest": {
        "name": "get_closest",
        "type": "function",
        "doc": "Gets the closest entity in the list to this position.",
        "short": "Gets the closest entity in the list to this position.",
        "member": "get_closest(position, entities)  LuaEntity?",
        "args": {
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": ""
          },
          "entities": {
            "name": "entities",
            "type": "array[LuaEntity]",
            "doc": "The Entities to check"
          }
        }
      },
      "get_train_stops": {
        "name": "get_train_stops",
        "type": "LuaEntity",
        "doc": "Gets train stops matching the given filters.",
        "short": "Gets train stops matching the given filters.",
        "member": "get_train_stops{name?=, force?=}  array[LuaEntity]",
        "args": {
          "name": {
            "name": "name",
            "type": "string or array[string]?",
            "doc": "The name(s) of the train stops. Not providing names will match any stop."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force to search. Not providing a force will match stops in any force."
          }
        }
      },
      "get_total_pollution": {
        "name": "get_total_pollution",
        "type": "function",
        "doc": "Gets the total amount of pollution on the surface by iterating over all of the chunks containing pollution.",
        "short": "Gets the total amount of pollution on the surface by iterating over all of the chunks containing pollution.",
        "member": "get_total_pollution()  double"
      },
      "entity_prototype_collides": {
        "name": "entity_prototype_collides",
        "type": "function",
        "doc": "Whether the given entity prototype collides at the given position and direction.",
        "short": "Whether the given entity prototype collides at the given position and direction.",
        "member": "entity_prototype_collides(prototype, position, use_map_generation_bounding_box, direction?)  boolean",
        "args": {
          "prototype": {
            "name": "prototype",
            "type": "EntityPrototypeIdentification",
            "doc": "The entity prototype to check"
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position to check"
          },
          "use_map_generation_bounding_box": {
            "name": "use_map_generation_bounding_box",
            "type": "boolean",
            "doc": "If the map generation bounding box should be used instead of the collision bounding box"
          },
          "direction": {
            "name": "direction",
            "type": "defines.direction?",
            "doc": ""
          }
        }
      },
      "decorative_prototype_collides": {
        "name": "decorative_prototype_collides",
        "type": "function",
        "doc": "Whether the given decorative prototype collides at the given position and direction.",
        "short": "Whether the given decorative prototype collides at the given position and direction.",
        "member": "decorative_prototype_collides(prototype, position)  boolean",
        "args": {
          "prototype": {
            "name": "prototype",
            "type": "string",
            "doc": "The decorative prototype to check"
          },
          "position": {
            "name": "position",
            "type": "MapPosition",
            "doc": "The position to check"
          }
        }
      },
      "calculate_tile_properties": {
        "name": "calculate_tile_properties",
        "type": "function",
        "doc": "Names of properties (\"elevation\", etc) to calculate. Returns: Table of property value lists, keyed by property name",
        "member": "calculate_tile_properties(property_names, positions)  dictionary[string array[double]]",
        "returns": "dictionary[string array[double]]",
        "args": {
          "property_names": {
            "name": "property_names",
            "type": "array[string]",
            "doc": "Names of properties (\"elevation\", etc) to calculate."
          },
          "positions": {
            "name": "positions",
            "type": "array[MapPosition]",
            "doc": "Positions for which to calculate property values"
          }
        }
      },
      "get_entities_with_force": {
        "name": "get_entities_with_force",
        "type": "function",
        "doc": "Returns all the military targets (entities with force) on this chunk for the given force.",
        "short": "Returns all the military targets (entities with force) on this chunk for the given force.",
        "member": "get_entities_with_force(position, force)  array[LuaEntity]",
        "args": {
          "position": {
            "name": "position",
            "type": "ChunkPosition",
            "doc": "The chunk's position."
          },
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "Entities of this force will be returned."
          }
        }
      },
      "build_checkerboard": {
        "name": "build_checkerboard",
        "doc": "Sets the given area to the checkerboard lab tiles.",
        "short": "Sets the given area to the checkerboard lab tiles.",
        "member": "build_checkerboard(area)",
        "type": "function",
        "args": {
          "area": {
            "name": "area",
            "type": "BoundingBox",
            "doc": "The tile area."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[RW]",
        "doc": "The name of this surface. Names are unique among surfaces.",
        "short": "The name of this surface. [...]",
        "member": "name  ::string Read/Write",
        "args": {
          "on_surface_renamed": {
            "name": "on_surface_renamed",
            "doc": ""
          }
        }
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[R]",
        "doc": "This surface's index in LuaGameScript::surfaces (unique ID). It is assigned when a surface is created, and remains so until it is deleted. Indexes of deleted surfaces can be reused.",
        "short": "This surface's index in LuaGameScript::surfaces (unique ID). [...]",
        "member": "index  ::uint Read"
      },
      "map_gen_settings": {
        "name": "map_gen_settings",
        "type": "MapGenSettings",
        "mode": "[RW]",
        "doc": "The generation settings for this surface. These can be modified after surface generation, but note that this will not retroactively update the surface. To manually regenerate it, LuaSurface::regenerate_entity, LuaSurface::regenerate_decorative, and LuaSurface::delete_chunk can be used.",
        "short": "The generation settings for this surface. [...]",
        "member": "map_gen_settings  ::MapGenSettings Read/Write"
      },
      "generate_with_lab_tiles": {
        "name": "generate_with_lab_tiles",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "When set to true, new chunks will be generated with lab tiles, instead of using the surface's map generation settings.",
        "short": "When set to true, new chunks will be generated with lab tiles, instead of using the surface's map generation settings.",
        "member": "generate_with_lab_tiles  ::boolean Read/Write"
      },
      "always_day": {
        "name": "always_day",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "When set to true, the sun will always shine.",
        "short": "When set to true, the sun will always shine.",
        "member": "always_day  ::boolean Read/Write"
      },
      "daytime": {
        "name": "daytime",
        "type": "double",
        "mode": "[RW]",
        "doc": "Current time of day, as a number in range [0, 1).",
        "short": "Current time of day, as a number in range [0, 1).",
        "member": "daytime  ::double Read/Write"
      },
      "darkness": {
        "name": "darkness",
        "type": "float",
        "mode": "[R]",
        "doc": "Amount of darkness at the current time, as a number in range [0, 1].",
        "short": "Amount of darkness at the current time, as a number in range [0, 1].",
        "member": "darkness  ::float Read"
      },
      "wind_speed": {
        "name": "wind_speed",
        "type": "double",
        "mode": "[RW]",
        "doc": "Current wind speed in tiles per tick.",
        "short": "Current wind speed in tiles per tick.",
        "member": "wind_speed  ::double Read/Write"
      },
      "wind_orientation": {
        "name": "wind_orientation",
        "type": "RealOrientation",
        "mode": "[RW]",
        "doc": "Current wind direction.",
        "short": "Current wind direction.",
        "member": "wind_orientation  ::RealOrientation Read/Write"
      },
      "wind_orientation_change": {
        "name": "wind_orientation_change",
        "type": "double",
        "mode": "[RW]",
        "doc": "Change in wind orientation per tick.",
        "short": "Change in wind orientation per tick.",
        "member": "wind_orientation_change  ::double Read/Write"
      },
      "peaceful_mode": {
        "name": "peaceful_mode",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Is peaceful mode enabled on this surface?",
        "short": "Is peaceful mode enabled on this surface?",
        "member": "peaceful_mode  ::boolean Read/Write"
      },
      "freeze_daytime": {
        "name": "freeze_daytime",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "True if daytime is currently frozen.",
        "short": "True if daytime is currently frozen.",
        "member": "freeze_daytime  ::boolean Read/Write"
      },
      "ticks_per_day": {
        "name": "ticks_per_day",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The number of ticks per day for this surface.",
        "short": "The number of ticks per day for this surface.",
        "member": "ticks_per_day  ::uint Read/Write"
      },
      "dusk": {
        "name": "dusk",
        "type": "double",
        "mode": "[RW]",
        "doc": "The daytime when dusk starts.",
        "short": "The daytime when dusk starts.",
        "member": "dusk  ::double Read/Write"
      },
      "dawn": {
        "name": "dawn",
        "type": "double",
        "mode": "[RW]",
        "doc": "The daytime when dawn starts.",
        "short": "The daytime when dawn starts.",
        "member": "dawn  ::double Read/Write"
      },
      "evening": {
        "name": "evening",
        "type": "double",
        "mode": "[RW]",
        "doc": "The daytime when evening starts.",
        "short": "The daytime when evening starts.",
        "member": "evening  ::double Read/Write"
      },
      "morning": {
        "name": "morning",
        "type": "double",
        "mode": "[RW]",
        "doc": "The daytime when morning starts.",
        "short": "The daytime when morning starts.",
        "member": "morning  ::double Read/Write"
      },
      "solar_power_multiplier": {
        "name": "solar_power_multiplier",
        "type": "double",
        "mode": "[RW]",
        "doc": "The multiplier of solar power on this surface. Cannot be less than 0.",
        "short": "The multiplier of solar power on this surface. [...]",
        "member": "solar_power_multiplier  ::double Read/Write"
      },
      "min_brightness": {
        "name": "min_brightness",
        "type": "double",
        "mode": "[RW]",
        "doc": "The minimal brightness during the night. Defaults to 0.15. This has an effect on both rendering and game mechanics such as biter spawns and solar power.",
        "short": "The minimal brightness during the night. [...]",
        "member": "min_brightness  ::double Read/Write"
      },
      "brightness_visual_weights": {
        "name": "brightness_visual_weights",
        "type": "ColorModifier",
        "mode": "[RW]",
        "doc": "Defines how surface daytime brightness influences each color channel of the current color lookup table (LUT).",
        "short": "Defines how surface daytime brightness influences each color channel of the current color lookup table (LUT). [...]",
        "member": "brightness_visual_weights  ::ColorModifier Read/Write"
      },
      "show_clouds": {
        "name": "show_clouds",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If clouds are shown on this surface.",
        "short": "If clouds are shown on this surface.",
        "member": "show_clouds  ::boolean Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTechnology": {
    "name": "LuaTechnology",
    "type": "LuaTechnology",
    "inherits": [],
    "properties": {
      "reload": {
        "name": "reload",
        "doc": "Reload this technology from its prototype.",
        "short": "Reload this technology from its prototype.",
        "member": "reload()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force this technology belongs to.",
        "short": "The force this technology belongs to.",
        "member": "force  ::LuaForce Read"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this technology.",
        "short": "Name of this technology.",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of this technology.",
        "short": "Localised name of this technology.",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaTechnologyPrototype",
        "mode": "[R]",
        "doc": "The prototype of this technology.",
        "short": "The prototype of this technology.",
        "member": "prototype  ::LuaTechnologyPrototype Read"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Can this technology be researched?",
        "short": "Can this technology be researched?",
        "member": "enabled  ::boolean Read/Write"
      },
      "visible_when_disabled": {
        "name": "visible_when_disabled",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If this technology will be visible in the research GUI even though it is disabled.",
        "short": "If this technology will be visible in the research GUI even though it is disabled.",
        "member": "visible_when_disabled  ::boolean Read/Write"
      },
      "upgrade": {
        "name": "upgrade",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this an upgrade-type research?",
        "short": "Is this an upgrade-type research?",
        "member": "upgrade  ::boolean Read"
      },
      "researched": {
        "name": "researched",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "Has this technology been researched? Switching from false to true will trigger the technology advancement perks; switching from true to false will reverse them.",
        "short": "Has this technology been researched? [...]",
        "member": "researched  ::boolean Read/Write"
      },
      "prerequisites": {
        "name": "prerequisites",
        "type": "string",
        "mode": "[R]",
        "doc": "Prerequisites of this technology. The result maps technology name to the LuaTechnology object.",
        "short": "Prerequisites of this technology. [...]",
        "member": "prerequisites  ::dictionary[string LuaTechnology] Read"
      },
      "research_unit_ingredients": {
        "name": "research_unit_ingredients",
        "type": "Ingredient",
        "mode": "[R]",
        "doc": "The types of ingredients that labs will require to research this technology.",
        "short": "The types of ingredients that labs will require to research this technology.",
        "member": "research_unit_ingredients  ::array[Ingredient] Read"
      },
      "effects": {
        "name": "effects",
        "type": "TechnologyModifier",
        "mode": "[R]",
        "doc": "Effects applied when this technology is researched.",
        "short": "Effects applied when this technology is researched.",
        "member": "effects  ::array[TechnologyModifier] Read"
      },
      "research_unit_count": {
        "name": "research_unit_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of research units required for this technology.",
        "short": "The number of research units required for this technology.",
        "member": "research_unit_count  ::uint Read"
      },
      "research_unit_energy": {
        "name": "research_unit_energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Amount of energy required to finish a unit of research.",
        "short": "Amount of energy required to finish a unit of research.",
        "member": "research_unit_energy  ::double Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "level": {
        "name": "level",
        "type": "uint",
        "mode": "[RW]",
        "doc": "The current level of this technology. For level-based technology writing to this is the same as researching the technology to the previous level. Writing the level will set LuaTechnology::enabled to true.",
        "short": "The current level of this technology. [...]",
        "member": "level  ::uint Read/Write"
      },
      "research_unit_count_formula": {
        "name": "research_unit_count_formula",
        "type": "string",
        "mode": "[R]",
        "doc": "The count formula, if this research has any. See TechnologyUnit::count_formula for details.",
        "short": "The count formula, if this research has any. [...]",
        "member": "research_unit_count_formula  ::string? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTechnologyPrototype": {
    "name": "LuaTechnologyPrototype",
    "type": "LuaTechnologyPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this technology.",
        "short": "Name of this technology.",
        "member": "name  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "doc": "Localised name of this technology.",
        "short": "Localised name of this technology.",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this technology prototype is enabled by default (enabled at the beginning of a game).",
        "short": "If this technology prototype is enabled by default (enabled at the beginning of a game).",
        "member": "enabled  ::boolean Read"
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this technology prototype is hidden.",
        "short": "If this technology prototype is hidden.",
        "member": "hidden  ::boolean Read"
      },
      "visible_when_disabled": {
        "name": "visible_when_disabled",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this technology will be visible in the research GUI even though it is disabled.",
        "short": "If this technology will be visible in the research GUI even though it is disabled.",
        "member": "visible_when_disabled  ::boolean Read"
      },
      "ignore_tech_cost_multiplier": {
        "name": "ignore_tech_cost_multiplier",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this technology ignores the technology cost multiplier setting.",
        "short": "If this technology ignores the technology cost multiplier setting.",
        "member": "ignore_tech_cost_multiplier  ::boolean Read"
      },
      "upgrade": {
        "name": "upgrade",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If the is technology prototype is an upgrade to some other technology.",
        "short": "If the is technology prototype is an upgrade to some other technology.",
        "member": "upgrade  ::boolean Read"
      },
      "prerequisites": {
        "name": "prerequisites",
        "type": "string",
        "mode": "[R]",
        "doc": "Prerequisites of this technology. The result maps technology name to the LuaTechnologyPrototype object.",
        "short": "Prerequisites of this technology. [...]",
        "member": "prerequisites  ::dictionary[string LuaTechnologyPrototype] Read"
      },
      "research_unit_ingredients": {
        "name": "research_unit_ingredients",
        "type": "Ingredient",
        "mode": "[R]",
        "doc": "The types of ingredients that labs will require to research this technology.",
        "short": "The types of ingredients that labs will require to research this technology.",
        "member": "research_unit_ingredients  ::array[Ingredient] Read"
      },
      "effects": {
        "name": "effects",
        "type": "TechnologyModifier",
        "mode": "[R]",
        "doc": "Effects applied when this technology is researched.",
        "short": "Effects applied when this technology is researched.",
        "member": "effects  ::array[TechnologyModifier] Read"
      },
      "research_unit_count": {
        "name": "research_unit_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The number of research units required for this technology.",
        "short": "The number of research units required for this technology.",
        "member": "research_unit_count  ::uint Read"
      },
      "research_unit_energy": {
        "name": "research_unit_energy",
        "type": "double",
        "mode": "[R]",
        "doc": "Amount of energy required to finish a unit of research.",
        "short": "Amount of energy required to finish a unit of research.",
        "member": "research_unit_energy  ::double Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "level": {
        "name": "level",
        "type": "uint",
        "mode": "[R]",
        "doc": "The level of this research.",
        "short": "The level of this research.",
        "member": "level  ::uint Read"
      },
      "max_level": {
        "name": "max_level",
        "type": "uint",
        "mode": "[R]",
        "doc": "The max level of this research.",
        "short": "The max level of this research.",
        "member": "max_level  ::uint Read"
      },
      "research_unit_count_formula": {
        "name": "research_unit_count_formula",
        "type": "string",
        "mode": "[R]",
        "doc": "The count formula, if this research has any. See TechnologyUnit::count_formula for details.",
        "short": "The count formula, if this research has any. [...]",
        "member": "research_unit_count_formula  ::string? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTile": {
    "name": "LuaTile",
    "type": "LuaTile",
    "inherits": [],
    "properties": {
      "collides_with": {
        "name": "collides_with",
        "type": "function",
        "doc": "What type of things can collide with this tile?",
        "short": "What type of things can collide with this tile?",
        "member": "collides_with(layer)  boolean",
        "args": {
          "layer": {
            "name": "layer",
            "type": "CollisionMaskLayer",
            "doc": ""
          }
        }
      },
      "to_be_deconstructed": {
        "name": "to_be_deconstructed",
        "type": "function",
        "doc": "Is this tile marked for deconstruction?",
        "short": "Is this tile marked for deconstruction?",
        "member": "to_be_deconstructed(force?)  boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "The force who did the deconstruction order."
          }
        }
      },
      "order_deconstruction": {
        "name": "order_deconstruction",
        "type": "function",
        "doc": "Orders deconstruction of this tile by the given force. Returns: The deconstructible tile proxy created, if any.",
        "short": "Orders deconstruction of this tile by the given force.",
        "member": "order_deconstruction(force, player?)  LuaEntity?",
        "returns": "LuaEntity?",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force whose robots are supposed to do the deconstruction."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "on_marked_for_deconstruction?": {
            "name": "on_marked_for_deconstruction?",
            "doc": "Raised if the tile was successfully marked for deconstruction."
          }
        }
      },
      "cancel_deconstruction": {
        "name": "cancel_deconstruction",
        "doc": "Cancels deconstruction if it is scheduled, does nothing otherwise.",
        "short": "Cancels deconstruction if it is scheduled, does nothing otherwise.",
        "member": "cancel_deconstruction(force, player?)",
        "type": "function",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification",
            "doc": "The force who did the deconstruction order."
          },
          "player": {
            "name": "player",
            "type": "PlayerIdentification?",
            "doc": "The player to set the last_user to if any."
          },
          "on_cancelled_deconstruction?": {
            "name": "on_cancelled_deconstruction?",
            "doc": "Raised if the tile's deconstruction was successfully cancelled."
          }
        }
      },
      "has_tile_ghost": {
        "name": "has_tile_ghost",
        "type": "function",
        "doc": "Does this tile have any tile ghosts on it.",
        "short": "Does this tile have any tile ghosts on it.",
        "member": "has_tile_ghost(force?)  boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Check for tile ghosts of this force."
          }
        }
      },
      "get_tile_ghosts": {
        "name": "get_tile_ghosts",
        "type": "function",
        "doc": "Gets all tile ghosts on this tile.",
        "short": "Gets all tile ghosts on this tile.",
        "member": "get_tile_ghosts(force?)  array[LuaTile]",
        "args": {
          "force": {
            "name": "force",
            "type": "ForceIdentification?",
            "doc": "Get tile ghosts of this force."
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Prototype name of this tile. E.g. \"sand-3\" or \"grass-2\".",
        "short": "Prototype name of this tile. [...]",
        "member": "name  ::string Read"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaTilePrototype",
        "mode": "[R]",
        "member": "prototype  ::LuaTilePrototype Read"
      },
      "position": {
        "name": "position",
        "type": "TilePosition",
        "mode": "[R]",
        "doc": "The position this tile references.",
        "short": "The position this tile references.",
        "member": "position  ::TilePosition Read"
      },
      "hidden_tile": {
        "name": "hidden_tile",
        "type": "string",
        "mode": "[R]",
        "doc": "The name of the LuaTilePrototype hidden under this tile, if any. During normal gameplay, only non-mineable tiles can become hidden. This can however be circumvented with LuaSurface::set_hidden_tile.",
        "short": "The name of the LuaTilePrototype hidden under this tile, if any. [...]",
        "member": "hidden_tile  ::string? Read"
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[R]",
        "doc": "The surface this tile is on.",
        "short": "The surface this tile is on.",
        "member": "surface  ::LuaSurface Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTilePrototype": {
    "name": "LuaTilePrototype",
    "type": "LuaTilePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "CollisionMask",
        "mode": "[R]",
        "doc": "The collision mask this tile uses",
        "short": "The collision mask this tile uses",
        "member": "collision_mask  ::CollisionMask Read"
      },
      "collision_mask_with_flags": {
        "name": "collision_mask_with_flags",
        "type": "CollisionMaskWithFlags",
        "mode": "[R]",
        "member": "collision_mask_with_flags  ::CollisionMaskWithFlags Read"
      },
      "layer": {
        "name": "layer",
        "type": "uint",
        "mode": "[R]",
        "member": "layer  ::uint Read"
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[R]",
        "doc": "Autoplace specification for this prototype, if any.",
        "short": "Autoplace specification for this prototype, if any.",
        "member": "autoplace_specification  ::AutoplaceSpecification? Read"
      },
      "walking_speed_modifier": {
        "name": "walking_speed_modifier",
        "type": "float",
        "mode": "[R]",
        "member": "walking_speed_modifier  ::float Read"
      },
      "vehicle_friction_modifier": {
        "name": "vehicle_friction_modifier",
        "type": "float",
        "mode": "[R]",
        "member": "vehicle_friction_modifier  ::float Read"
      },
      "map_color": {
        "name": "map_color",
        "type": "Color",
        "mode": "[R]",
        "member": "map_color  ::Color Read"
      },
      "decorative_removal_probability": {
        "name": "decorative_removal_probability",
        "type": "float",
        "mode": "[R]",
        "doc": "The probability that decorative entities will be removed from on top of this tile when this tile is generated.",
        "short": "The probability that decorative entities will be removed from on top of this tile when this tile is generated.",
        "member": "decorative_removal_probability  ::float Read"
      },
      "automatic_neighbors": {
        "name": "automatic_neighbors",
        "type": "boolean",
        "mode": "[R]",
        "member": "automatic_neighbors  ::boolean Read"
      },
      "allowed_neighbors": {
        "name": "allowed_neighbors",
        "type": "string",
        "mode": "[R]",
        "member": "allowed_neighbors  ::dictionary[string LuaTilePrototype] Read"
      },
      "needs_correction": {
        "name": "needs_correction",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this tile needs correction logic applied when it's generated in the world.",
        "short": "If this tile needs correction logic applied when it's generated in the world.",
        "member": "needs_correction  ::boolean Read"
      },
      "mineable_properties": {
        "name": "mineable_properties",
        "mode": "[R]",
        "doc": "Is this tile mineable at all?",
        "member": "mineable_properties  ::table Read",
        "args": {
          "minable": {
            "name": "minable",
            "type": "boolean",
            "doc": "Is this tile mineable at all?"
          },
          "mining_time": {
            "name": "mining_time",
            "type": "double",
            "doc": "Energy required to mine a tile."
          },
          "mining_particle": {
            "name": "mining_particle",
            "type": "string?",
            "doc": "Prototype name of the particle produced when mining this tile. Will only be present if this tile produces any particle during mining."
          },
          "products": {
            "name": "products",
            "type": "array[Product]",
            "doc": "Products obtained by mining this tile."
          }
        }
      },
      "next_direction": {
        "name": "next_direction",
        "type": "LuaTilePrototype",
        "mode": "[R]",
        "doc": "The next direction of this tile, if any. Used when a tile has multiple directions (such as hazard concrete)",
        "short": "The next direction of this tile, if any. [...]",
        "member": "next_direction  ::LuaTilePrototype? Read"
      },
      "items_to_place_this": {
        "name": "items_to_place_this",
        "type": "ItemStackDefinition",
        "mode": "[R]",
        "doc": "Items that when placed will produce this tile, if any. Construction bots will choose the first item in the list to build this tile.",
        "short": "Items that when placed will produce this tile, if any. [...]",
        "member": "items_to_place_this  ::array[ItemStackDefinition]? Read"
      },
      "can_be_part_of_blueprint": {
        "name": "can_be_part_of_blueprint",
        "type": "boolean",
        "mode": "[R]",
        "doc": "False if this tile is not allowed in blueprints regardless of the ability to build it.",
        "short": "False if this tile is not allowed in blueprints regardless of the ability to build it.",
        "member": "can_be_part_of_blueprint  ::boolean Read"
      },
      "emissions_per_second": {
        "name": "emissions_per_second",
        "type": "double",
        "mode": "[R]",
        "doc": "Amount of pollution emissions per second this tile will absorb.",
        "short": "Amount of pollution emissions per second this tile will absorb.",
        "member": "emissions_per_second  ::double Read"
      },
      "check_collision_with_entities": {
        "name": "check_collision_with_entities",
        "type": "boolean",
        "mode": "[R]",
        "doc": "True if building this tile should check for colliding entities above and prevent building if such are found. Also during mining tiles above this tile checks for entities colliding with this tile and prevents mining if such are found.",
        "short": "True if building this tile should check for colliding entities above and prevent building if such are found. [...]",
        "member": "check_collision_with_entities  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTrain": {
    "name": "LuaTrain",
    "type": "LuaTrain",
    "inherits": [],
    "properties": {
      "get_item_count": {
        "name": "get_item_count",
        "type": "function",
        "doc": "Get the amount of a particular item stored in the train.",
        "short": "Get the amount of a particular item stored in the train.",
        "member": "get_item_count(item?)  uint",
        "args": {
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "Item name to count. If not given, counts all items."
          }
        }
      },
      "get_contents": {
        "name": "get_contents",
        "type": "function",
        "doc": "Get a mapping of the train's inventory. Returns: The counts, indexed by item names.",
        "short": "Get a mapping of the train's inventory.",
        "member": "get_contents()  dictionary[string uint]",
        "returns": "dictionary[string uint]"
      },
      "remove_item": {
        "name": "remove_item",
        "type": "function",
        "doc": "Remove some items from the train. Returns: Number of items actually removed.",
        "short": "Remove some items from the train.",
        "member": "remove_item(stack)  uint",
        "returns": "uint",
        "args": {
          "stack": {
            "name": "stack",
            "type": "ItemStackIdentification",
            "doc": "The amount and type of items to remove"
          }
        }
      },
      "insert": {
        "name": "insert",
        "doc": "Insert a stack into the train.",
        "short": "Insert a stack into the train.",
        "member": "insert(stack)",
        "type": "function",
        "args": {
          "stack": {
            "name": "stack",
            "type": "ItemStackIdentification",
            "doc": ""
          }
        }
      },
      "clear_items_inside": {
        "name": "clear_items_inside",
        "doc": "Clear all items in this train.",
        "short": "Clear all items in this train.",
        "member": "clear_items_inside()",
        "type": "function"
      },
      "recalculate_path": {
        "name": "recalculate_path",
        "type": "function",
        "doc": "Checks if the path is invalid and tries to re-path if it isn't. Returns: If the train has a path after the repath attempt.",
        "short": "Checks if the path is invalid and tries to re-path if it isn't.",
        "member": "recalculate_path(force?)  boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "name": "force",
            "type": "boolean?",
            "doc": "Forces the train to re-path regardless of the current path being valid or not."
          }
        }
      },
      "get_fluid_count": {
        "name": "get_fluid_count",
        "type": "function",
        "doc": "Get the amount of a particular fluid stored in the train.",
        "short": "Get the amount of a particular fluid stored in the train.",
        "member": "get_fluid_count(fluid?)  double",
        "args": {
          "fluid": {
            "name": "fluid",
            "type": "string?",
            "doc": "Fluid name to count. If not given, counts all fluids."
          }
        }
      },
      "get_fluid_contents": {
        "name": "get_fluid_contents",
        "type": "function",
        "doc": "Gets a mapping of the train's fluid inventory. Returns: The counts, indexed by fluid names.",
        "short": "Gets a mapping of the train's fluid inventory.",
        "member": "get_fluid_contents()  dictionary[string double]",
        "returns": "dictionary[string double]"
      },
      "remove_fluid": {
        "name": "remove_fluid",
        "type": "function",
        "doc": "Remove some fluid from the train. Returns: The amount of fluid actually removed.",
        "short": "Remove some fluid from the train.",
        "member": "remove_fluid(fluid)  double",
        "returns": "double",
        "args": {
          "fluid": {
            "name": "fluid",
            "type": "Fluid",
            "doc": ""
          }
        }
      },
      "insert_fluid": {
        "name": "insert_fluid",
        "type": "function",
        "doc": "Inserts the given fluid into the first available location in this train. Returns: The amount inserted.",
        "short": "Inserts the given fluid into the first available location in this train.",
        "member": "insert_fluid(fluid)  double",
        "returns": "double",
        "args": {
          "fluid": {
            "name": "fluid",
            "type": "Fluid",
            "doc": ""
          }
        }
      },
      "clear_fluids_inside": {
        "name": "clear_fluids_inside",
        "doc": "Clears all fluids in this train.",
        "short": "Clears all fluids in this train.",
        "member": "clear_fluids_inside()",
        "type": "function"
      },
      "go_to_station": {
        "name": "go_to_station",
        "doc": "Go to the station specified by the index in the train's schedule.",
        "short": "Go to the station specified by the index in the train's schedule.",
        "member": "go_to_station(index)",
        "type": "function",
        "args": {
          "index": {
            "name": "index",
            "type": "uint",
            "doc": ""
          }
        }
      },
      "get_rails": {
        "name": "get_rails",
        "type": "function",
        "doc": "Gets all rails under the train.",
        "short": "Gets all rails under the train.",
        "member": "get_rails()  array[LuaEntity]"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "manual_mode": {
        "name": "manual_mode",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "When true, the train is explicitly controlled by the player or script. When false, the train moves autonomously according to its schedule.",
        "short": "When true, the train is explicitly controlled by the player or script. [...]",
        "member": "manual_mode  ::boolean Read/Write"
      },
      "speed": {
        "name": "speed",
        "type": "double",
        "mode": "[RW]",
        "doc": "Current speed.",
        "short": "Current speed.",
        "member": "speed  ::double Read/Write"
      },
      "max_forward_speed": {
        "name": "max_forward_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "Current max speed when moving forward, depends on locomotive prototype and fuel.",
        "short": "Current max speed when moving forward, depends on locomotive prototype and fuel.",
        "member": "max_forward_speed  ::double Read"
      },
      "max_backward_speed": {
        "name": "max_backward_speed",
        "type": "double",
        "mode": "[R]",
        "doc": "Current max speed when moving backwards, depends on locomotive prototype and fuel.",
        "short": "Current max speed when moving backwards, depends on locomotive prototype and fuel.",
        "member": "max_backward_speed  ::double Read"
      },
      "weight": {
        "name": "weight",
        "type": "double",
        "mode": "[R]",
        "doc": "The weight of this train.",
        "short": "The weight of this train.",
        "member": "weight  ::double Read"
      },
      "carriages": {
        "name": "carriages",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The rolling stocks this train is composed of, with the numbering starting at the front of the train.",
        "short": "The rolling stocks this train is composed of, with the numbering starting at the front of the train.",
        "member": "carriages  ::array[LuaEntity] Read"
      },
      "locomotives": {
        "name": "locomotives",
        "mode": "[R]",
        "doc": "Locomotives of the train.",
        "short": "Locomotives of the train.",
        "member": "locomotives  ::table Read",
        "args": {
          "front_movers": {
            "name": "front_movers",
            "type": "array[LuaEntity]",
            "doc": "Array of locomotives."
          },
          "back_movers": {
            "name": "back_movers",
            "type": "array[LuaEntity]",
            "doc": "Array of locomotives."
          }
        }
      },
      "cargo_wagons": {
        "name": "cargo_wagons",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The cargo carriages the train contains.",
        "short": "The cargo carriages the train contains.",
        "member": "cargo_wagons  ::array[LuaEntity] Read"
      },
      "fluid_wagons": {
        "name": "fluid_wagons",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The fluid carriages the train contains.",
        "short": "The fluid carriages the train contains.",
        "member": "fluid_wagons  ::array[LuaEntity] Read"
      },
      "schedule": {
        "name": "schedule",
        "type": "TrainSchedule",
        "mode": "[RW]",
        "doc": "This train's current schedule, if any. Set to nil to clear.",
        "short": "This train's current schedule, if any. [...]",
        "member": "schedule  ::TrainSchedule? Read/Write"
      },
      "state": {
        "name": "state",
        "type": "defines.train_state",
        "mode": "[R]",
        "doc": "This train's current state.",
        "short": "This train's current state.",
        "member": "state  ::defines.train_state Read"
      },
      "front_rail": {
        "name": "front_rail",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The rail at the front end of the train, if any.",
        "short": "The rail at the front end of the train, if any.",
        "member": "front_rail  ::LuaEntity? Read"
      },
      "back_rail": {
        "name": "back_rail",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The rail at the back end of the train, if any.",
        "short": "The rail at the back end of the train, if any.",
        "member": "back_rail  ::LuaEntity? Read"
      },
      "rail_direction_from_front_rail": {
        "name": "rail_direction_from_front_rail",
        "type": "defines.rail_direction",
        "mode": "[R]",
        "member": "rail_direction_from_front_rail  ::defines.rail_direction Read"
      },
      "rail_direction_from_back_rail": {
        "name": "rail_direction_from_back_rail",
        "type": "defines.rail_direction",
        "mode": "[R]",
        "member": "rail_direction_from_back_rail  ::defines.rail_direction Read"
      },
      "front_stock": {
        "name": "front_stock",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The front stock of this train, if any. The front of the train is in the direction that a majority of locomotives are pointing in. If it's a tie, the North and West directions take precedence.",
        "short": "The front stock of this train, if any. [...]",
        "member": "front_stock  ::LuaEntity? Read"
      },
      "back_stock": {
        "name": "back_stock",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The back stock of this train, if any. The back of the train is at the opposite end of the front.",
        "short": "The back stock of this train, if any. [...]",
        "member": "back_stock  ::LuaEntity? Read"
      },
      "station": {
        "name": "station",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The train stop this train is stopped at, if any.",
        "short": "The train stop this train is stopped at, if any.",
        "member": "station  ::LuaEntity? Read"
      },
      "has_path": {
        "name": "has_path",
        "type": "boolean",
        "mode": "[R]",
        "doc": "If this train has a path.",
        "short": "If this train has a path.",
        "member": "has_path  ::boolean Read"
      },
      "path_end_rail": {
        "name": "path_end_rail",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The destination rail this train is currently pathing to, if any.",
        "short": "The destination rail this train is currently pathing to, if any.",
        "member": "path_end_rail  ::LuaEntity? Read"
      },
      "path_end_stop": {
        "name": "path_end_stop",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The destination train stop this train is currently pathing to, if any.",
        "short": "The destination train stop this train is currently pathing to, if any.",
        "member": "path_end_stop  ::LuaEntity? Read"
      },
      "id": {
        "name": "id",
        "type": "uint",
        "mode": "[R]",
        "doc": "The unique train ID.",
        "short": "The unique train ID.",
        "member": "id  ::uint Read"
      },
      "passengers": {
        "name": "passengers",
        "type": "LuaPlayer",
        "mode": "[R]",
        "doc": "The player passengers on the train",
        "short": "The player passengers on the train",
        "member": "passengers  ::array[LuaPlayer] Read"
      },
      "riding_state": {
        "name": "riding_state",
        "type": "RidingState",
        "mode": "[R]",
        "doc": "The riding state of this train.",
        "short": "The riding state of this train.",
        "member": "riding_state  ::RidingState Read"
      },
      "killed_players": {
        "name": "killed_players",
        "type": "uint",
        "mode": "[R]",
        "doc": "The players killed by this train.",
        "short": "The players killed by this train. [...]",
        "member": "killed_players  ::dictionary[uint uint] Read"
      },
      "kill_count": {
        "name": "kill_count",
        "type": "uint",
        "mode": "[R]",
        "doc": "The total number of kills by this train.",
        "short": "The total number of kills by this train.",
        "member": "kill_count  ::uint Read"
      },
      "path": {
        "name": "path",
        "type": "LuaRailPath",
        "mode": "[R]",
        "doc": "The path this train is using, if any.",
        "short": "The path this train is using, if any.",
        "member": "path  ::LuaRailPath? Read"
      },
      "signal": {
        "name": "signal",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The signal this train is arriving or waiting at, if any.",
        "short": "The signal this train is arriving or waiting at, if any.",
        "member": "signal  ::LuaEntity? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTrainStopControlBehavior": {
    "name": "LuaTrainStopControlBehavior",
    "type": "LuaTrainStopControlBehavior",
    "inherits": [
      "Inherited from LuaGenericOnOffControlBehavior: disabled, circuit_condition, logistic_condition, connect_to_logistic_network, valid, object_name, help",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "send_to_train": {
        "name": "send_to_train",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the train stop should send the circuit network contents to the train to use.",
        "short": "true if the train stop should send the circuit network contents to the train to use.",
        "member": "send_to_train  ::boolean Read/Write"
      },
      "read_from_train": {
        "name": "read_from_train",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the train stop should send the train contents to the circuit network.",
        "short": "true if the train stop should send the train contents to the circuit network.",
        "member": "read_from_train  ::boolean Read/Write"
      },
      "read_stopped_train": {
        "name": "read_stopped_train",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the train stop should send the stopped train id to the circuit network.",
        "short": "true if the train stop should send the stopped train id to the circuit network.",
        "member": "read_stopped_train  ::boolean Read/Write"
      },
      "set_trains_limit": {
        "name": "set_trains_limit",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the trains_limit_signal is used to set a limit of trains incoming for train stop.",
        "short": "true if the trains_limit_signal is used to set a limit of trains incoming for train stop.",
        "member": "set_trains_limit  ::boolean Read/Write"
      },
      "read_trains_count": {
        "name": "read_trains_count",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the train stop should send amount of incoming trains to the circuit network.",
        "short": "true if the train stop should send amount of incoming trains to the circuit network.",
        "member": "read_trains_count  ::boolean Read/Write"
      },
      "enable_disable": {
        "name": "enable_disable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "true if the train stop is enabled/disabled through the circuit network.",
        "short": "true if the train stop is enabled/disabled through the circuit network.",
        "member": "enable_disable  ::boolean Read/Write"
      },
      "stopped_train_signal": {
        "name": "stopped_train_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "doc": "The signal that will be sent when using the send-train-id option.",
        "short": "The signal that will be sent when using the send-train-id option.",
        "member": "stopped_train_signal  ::SignalID Read/Write"
      },
      "trains_count_signal": {
        "name": "trains_count_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "doc": "The signal that will be sent when using the read-trains-count option.",
        "short": "The signal that will be sent when using the read-trains-count option.",
        "member": "trains_count_signal  ::SignalID Read/Write"
      },
      "trains_limit_signal": {
        "name": "trains_limit_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "doc": "The signal to be used by set-trains-limit to limit amount of incoming trains",
        "short": "The signal to be used by set-trains-limit to limit amount of incoming trains",
        "member": "trains_limit_signal  ::SignalID Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTransportBeltControlBehavior": {
    "name": "LuaTransportBeltControlBehavior",
    "type": "LuaTransportBeltControlBehavior",
    "inherits": [
      "Inherited from LuaGenericOnOffControlBehavior: disabled, circuit_condition, logistic_condition, connect_to_logistic_network, valid, object_name, help",
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "enable_disable": {
        "name": "enable_disable",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If the belt will be enabled/disabled based off the circuit network.",
        "short": "If the belt will be enabled/disabled based off the circuit network.",
        "member": "enable_disable  ::boolean Read/Write"
      },
      "read_contents": {
        "name": "read_contents",
        "type": "boolean",
        "mode": "[RW]",
        "doc": "If the belt will read the contents and send them to the circuit network.",
        "short": "If the belt will read the contents and send them to the circuit network.",
        "member": "read_contents  ::boolean Read/Write"
      },
      "read_contents_mode": {
        "name": "read_contents_mode",
        "type": "defines.control_behavior.transport_belt.content_read_mode",
        "mode": "[RW]",
        "doc": "The read mode for the belt.",
        "short": "The read mode for the belt.",
        "member": "read_contents_mode  ::defines.control_behavior.transport_belt.content_read_mode Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaTransportLine": {
    "name": "LuaTransportLine",
    "type": "LuaTransportLine",
    "inherits": [],
    "properties": {
      "clear": {
        "name": "clear",
        "doc": "Remove all items from this transport line.",
        "short": "Remove all items from this transport line.",
        "member": "clear()",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count",
        "type": "function",
        "doc": "Count some or all items on this line, similar to how LuaInventory::get_item_count does.",
        "short": "Count some or all items on this line, similar to how LuaInventory::get_item_count does.",
        "member": "get_item_count(item?)  uint",
        "args": {
          "item": {
            "name": "item",
            "type": "string?",
            "doc": "Prototype name of the item to count. If not specified, count all items."
          }
        }
      },
      "remove_item": {
        "name": "remove_item",
        "type": "function",
        "doc": "Remove some items from this line. Returns: Number of items actually removed.",
        "short": "Remove some items from this line.",
        "member": "remove_item(items)  uint",
        "returns": "uint",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items to remove."
          }
        }
      },
      "can_insert_at": {
        "name": "can_insert_at",
        "type": "function",
        "doc": "Can an item be inserted at a given position?",
        "short": "Can an item be inserted at a given position?",
        "member": "can_insert_at(position)  boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "float",
            "doc": "Where to insert an item."
          }
        }
      },
      "can_insert_at_back": {
        "name": "can_insert_at_back",
        "type": "function",
        "doc": "Can an item be inserted at the back of this line?",
        "short": "Can an item be inserted at the back of this line?",
        "member": "can_insert_at_back()  boolean"
      },
      "insert_at": {
        "name": "insert_at",
        "type": "function",
        "doc": "Insert items at a given position. Returns: Were the items inserted successfully?",
        "short": "Insert items at a given position.",
        "member": "insert_at(position, items)  boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "name": "position",
            "type": "float",
            "doc": "Where on the line to insert the items."
          },
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": "Items to insert."
          }
        }
      },
      "insert_at_back": {
        "name": "insert_at_back",
        "type": "function",
        "doc": "Insert items at the back of this line. Returns: Were the items inserted successfully?",
        "short": "Insert items at the back of this line.",
        "member": "insert_at_back(items)  boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "name": "items",
            "type": "ItemStackIdentification",
            "doc": ""
          }
        }
      },
      "get_contents": {
        "name": "get_contents",
        "type": "function",
        "doc": "Get counts of all items on this line, similar to how LuaInventory::get_contents does. Returns: The counts, indexed by item names.",
        "short": "Get counts of all items on this line, similar to how LuaInventory::get_contents does.",
        "member": "get_contents()  dictionary[string uint]",
        "returns": "dictionary[string uint]"
      },
      "line_equals": {
        "name": "line_equals",
        "type": "function",
        "doc": "Returns whether the associated internal transport line of this line is the same as the others associated internal transport line.",
        "short": "Returns whether the associated internal transport line of this line is the same as the others associated internal transport line.",
        "member": "line_equals(other)  boolean",
        "args": {
          "other": {
            "name": "other",
            "type": "LuaTransportLine",
            "doc": ""
          }
        }
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "The entity this transport line belongs to.",
        "short": "The entity this transport line belongs to.",
        "member": "owner  ::LuaEntity Read"
      },
      "output_lines": {
        "name": "output_lines",
        "type": "LuaTransportLine",
        "mode": "[R]",
        "doc": "The transport lines that this transport line outputs items to or an empty table if none.",
        "short": "The transport lines that this transport line outputs items to or an empty table if none.",
        "member": "output_lines  ::array[LuaTransportLine] Read"
      },
      "input_lines": {
        "name": "input_lines",
        "type": "LuaTransportLine",
        "mode": "[R]",
        "doc": "The transport lines that this transport line is fed by or an empty table if none.",
        "short": "The transport lines that this transport line is fed by or an empty table if none.",
        "member": "input_lines  ::array[LuaTransportLine] Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      },
      "# (length)": {
        "name": "# (length)",
        "type": "uint",
        "mode": "[R]",
        "doc": "Get the number of items on this transport line."
      },
      "[] (index)": {
        "name": "[] (index)",
        "type": "LuaItemStack",
        "mode": "[R]",
        "doc": "The indexing operator."
      }
    }
  },
  "LuaTrivialSmokePrototype": {
    "name": "LuaTrivialSmokePrototype",
    "type": "LuaTrivialSmokePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[R]",
        "member": "color  ::Color Read"
      },
      "start_scale": {
        "name": "start_scale",
        "type": "double",
        "mode": "[R]",
        "member": "start_scale  ::double Read"
      },
      "end_scale": {
        "name": "end_scale",
        "type": "double",
        "mode": "[R]",
        "member": "end_scale  ::double Read"
      },
      "movement_slow_down_factor": {
        "name": "movement_slow_down_factor",
        "type": "double",
        "mode": "[R]",
        "member": "movement_slow_down_factor  ::double Read"
      },
      "duration": {
        "name": "duration",
        "type": "uint",
        "mode": "[R]",
        "member": "duration  ::uint Read"
      },
      "spread_duration": {
        "name": "spread_duration",
        "type": "uint",
        "mode": "[R]",
        "member": "spread_duration  ::uint Read"
      },
      "fade_away_duration": {
        "name": "fade_away_duration",
        "type": "uint",
        "mode": "[R]",
        "member": "fade_away_duration  ::uint Read"
      },
      "fade_in_duration": {
        "name": "fade_in_duration",
        "type": "uint",
        "mode": "[R]",
        "member": "fade_in_duration  ::uint Read"
      },
      "glow_fade_away_duration": {
        "name": "glow_fade_away_duration",
        "type": "uint",
        "mode": "[R]",
        "member": "glow_fade_away_duration  ::uint Read"
      },
      "cyclic": {
        "name": "cyclic",
        "type": "boolean",
        "mode": "[R]",
        "member": "cyclic  ::boolean Read"
      },
      "affected_by_wind": {
        "name": "affected_by_wind",
        "type": "boolean",
        "mode": "[R]",
        "member": "affected_by_wind  ::boolean Read"
      },
      "show_when_smoke_off": {
        "name": "show_when_smoke_off",
        "type": "boolean",
        "mode": "[R]",
        "member": "show_when_smoke_off  ::boolean Read"
      },
      "glow_animation": {
        "name": "glow_animation",
        "type": "boolean",
        "mode": "[R]",
        "member": "glow_animation  ::boolean Read"
      },
      "render_layer": {
        "name": "render_layer",
        "type": "RenderLayer",
        "mode": "[R]",
        "member": "render_layer  ::RenderLayer Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaUnitGroup": {
    "name": "LuaUnitGroup",
    "type": "LuaUnitGroup",
    "inherits": [],
    "properties": {
      "add_member": {
        "name": "add_member",
        "doc": "Make a unit a member of this group. Has the same effect as giving a group_command with this group to the unit.",
        "short": "Make a unit a member of this group. [...]",
        "member": "add_member(unit)",
        "type": "function",
        "args": {
          "unit": {
            "name": "unit",
            "type": "LuaEntity",
            "doc": ""
          }
        }
      },
      "set_command": {
        "name": "set_command",
        "doc": "Give this group a command.",
        "short": "Give this group a command.",
        "member": "set_command(command)",
        "type": "function",
        "args": {
          "command": {
            "name": "command",
            "type": "Command",
            "doc": ""
          }
        }
      },
      "set_distraction_command": {
        "name": "set_distraction_command",
        "doc": "Give this group a distraction command.",
        "short": "Give this group a distraction command.",
        "member": "set_distraction_command(command)",
        "type": "function",
        "args": {
          "command": {
            "name": "command",
            "type": "Command",
            "doc": ""
          }
        }
      },
      "set_autonomous": {
        "name": "set_autonomous",
        "doc": "Make this group autonomous. Autonomous groups will automatically attack polluted areas. Autonomous groups aren't considered to be script-driven.",
        "short": "Make this group autonomous. [...]",
        "member": "set_autonomous()",
        "type": "function"
      },
      "start_moving": {
        "name": "start_moving",
        "doc": "Make the group start moving even if some of its members haven't yet arrived.",
        "short": "Make the group start moving even if some of its members haven't yet arrived.",
        "member": "start_moving()",
        "type": "function"
      },
      "destroy": {
        "name": "destroy",
        "doc": "Dissolve this group. Its members won't be destroyed, they will be merely unlinked from this group.",
        "short": "Dissolve this group. [...]",
        "member": "destroy()",
        "type": "function"
      },
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "members": {
        "name": "members",
        "type": "LuaEntity",
        "mode": "[R]",
        "doc": "Members of this group.",
        "short": "Members of this group.",
        "member": "members  ::array[LuaEntity] Read"
      },
      "position": {
        "name": "position",
        "type": "MapPosition",
        "mode": "[R]",
        "doc": "Group position. This can have different meanings depending on the group state. When the group is gathering, the position is the place of gathering. When the group is moving, the position is the expected position of its members along the path. When the group is attacking, it is the average position of its members.",
        "short": "Group position. [...]",
        "member": "position  ::MapPosition Read"
      },
      "state": {
        "name": "state",
        "type": "defines.group_state",
        "mode": "[R]",
        "doc": "Whether this group is gathering, moving or attacking.",
        "short": "Whether this group is gathering, moving or attacking.",
        "member": "state  ::defines.group_state Read"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[R]",
        "doc": "The force of this unit group.",
        "short": "The force of this unit group.",
        "member": "force  ::LuaForce Read"
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[R]",
        "doc": "The surface of this unit group.",
        "short": "The surface of this unit group.",
        "member": "surface  ::LuaSurface Read"
      },
      "group_number": {
        "name": "group_number",
        "type": "uint",
        "mode": "[R]",
        "doc": "The group number for this unit group.",
        "short": "The group number for this unit group.",
        "member": "group_number  ::uint Read"
      },
      "is_script_driven": {
        "name": "is_script_driven",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this unit group is controlled by a script or by the game engine. This can be changed using LuaUnitGroup::set_autonomous.",
        "short": "Whether this unit group is controlled by a script or by the game engine. [...]",
        "member": "is_script_driven  ::boolean Read"
      },
      "command": {
        "name": "command",
        "type": "Command",
        "mode": "[R]",
        "doc": "The command given to this group, if any.",
        "short": "The command given to this group, if any.",
        "member": "command  ::Command? Read"
      },
      "distraction_command": {
        "name": "distraction_command",
        "type": "Command",
        "mode": "[R]",
        "doc": "The distraction command given to this group, if any.",
        "short": "The distraction command given to this group, if any.",
        "member": "distraction_command  ::Command? Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaVirtualSignalPrototype": {
    "name": "LuaVirtualSignalPrototype",
    "type": "LuaVirtualSignalPrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[R]",
        "doc": "Name of this prototype.",
        "short": "Name of this prototype.",
        "member": "name  ::string Read"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[R]",
        "doc": "The string used to alphabetically sort these prototypes. It is a simple string that has no additional semantic meaning.",
        "short": "The string used to alphabetically sort these prototypes. [...]",
        "member": "order  ::string Read"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_name  ::LocalisedString Read"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[R]",
        "member": "localised_description  ::LocalisedString Read"
      },
      "special": {
        "name": "special",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Whether this is a special signal. The everything, anything, each, and unknown signals are considered special.",
        "short": "Whether this is a special signal. [...]",
        "member": "special  ::boolean Read"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[R]",
        "member": "subgroup  ::LuaGroup Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaVoidEnergySourcePrototype": {
    "name": "LuaVoidEnergySourcePrototype",
    "type": "LuaVoidEnergySourcePrototype",
    "inherits": [],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[R]",
        "doc": "The emissions of this energy source in pollution/Joule. Multiplying it by energy consumption in Watt gives pollution/second.",
        "short": "The emissions of this energy source in pollution/Joule. [...]",
        "member": "emissions  ::double Read"
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_network_icon  ::boolean Read"
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[R]",
        "member": "render_no_power_icon  ::boolean Read"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  },
  "LuaWallControlBehavior": {
    "name": "LuaWallControlBehavior",
    "type": "LuaWallControlBehavior",
    "inherits": [
      "Inherited from LuaControlBehavior: type, entity, get_circuit_network"
    ],
    "properties": {
      "help": {
        "name": "help",
        "type": "function",
        "doc": "All methods and properties that this object supports.",
        "short": "All methods and properties that this object supports.",
        "member": "help()  string"
      },
      "circuit_condition": {
        "name": "circuit_condition",
        "type": "CircuitConditionDefinition",
        "mode": "[RW]",
        "doc": "The circuit condition.",
        "short": "The circuit condition.",
        "member": "circuit_condition  ::CircuitConditionDefinition Read/Write"
      },
      "open_gate": {
        "name": "open_gate",
        "type": "boolean",
        "mode": "[RW]",
        "member": "open_gate  ::boolean Read/Write"
      },
      "read_sensor": {
        "name": "read_sensor",
        "type": "boolean",
        "mode": "[RW]",
        "member": "read_sensor  ::boolean Read/Write"
      },
      "output_signal": {
        "name": "output_signal",
        "type": "SignalID",
        "mode": "[RW]",
        "member": "output_signal  ::SignalID Read/Write"
      },
      "valid": {
        "name": "valid",
        "type": "boolean",
        "mode": "[R]",
        "doc": "Is this object valid? This Lua object holds a reference to an object within the game engine. It is possible that the game-engine object is removed whilst a mod still holds the corresponding Lua object. If that happens, the object becomes invalid, i.e. this attribute will be false. Mods are advised to check for object validity if any change to the game state might have occurred between the creation of the Lua object and its access.",
        "short": "Is this object valid? [...]",
        "member": "valid  ::boolean Read"
      },
      "object_name": {
        "name": "object_name",
        "type": "string",
        "mode": "[R]",
        "doc": "The class name of this object. Available even when valid is false. For LuaStruct objects it may also be suffixed with a dotted path to a member of the struct.",
        "short": "The class name of this object. [...]",
        "member": "object_name  ::string Read"
      }
    }
  }
}